{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230 Flask \u00b6 \u6b22\u8fce\u6765\u5230 Flask \u7684\u6587\u6863\u3002 \u5f00\u59cb\u4f7f\u7528 installation \uff0c\u7136\u540e\u4f7f\u7528 quickstart \u8fdb\u884c\u6982\u8ff0\u3002 \u8fd8\u6709\u4e00\u4e2a\u66f4\u8be6\u7ec6\u7684 \u6559\u7a0b \uff0c\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 Flask \u521b\u5efa\u4e00\u4e2a\u5c0f\u800c\u5b8c\u6574\u7684\u5e94\u7528\u7a0b\u5e8f\u3002 \u5e38\u89c1\u7684\u6a21\u5f0f\u5728 patterns \u90e8\u5206\u4e2d\u63cf\u8ff0\u3002 \u5176\u4f59\u7684\u6587\u6863\u8be6\u7ec6\u63cf\u8ff0\u4e86 Flask \u7684\u6bcf\u4e2a\u7ec4\u4ef6\uff0c\u5e76\u5728 api \u90e8\u5206\u4e2d\u63d0\u4f9b\u4e86\u5b8c\u6574\u7684\u53c2\u8003\u3002 Flask \u4f9d\u8d56\u4e8e Jinja \u6a21\u677f\u5f15\u64ce\u548c Werkzeug WSGI \u5de5\u5177\u5305\u3002 \u53ef\u4ee5\u5728\u4ee5\u4e0b\u4f4d\u7f6e\u627e\u5230\u8fd9\u4e9b\u5e93\u7684\u6587\u6863: Jinja \u6587\u6863 Werkzeug \u6587\u6863 .. include:: contents.rst.inc","title":"\u6b22\u8fce\u6765\u5230 Flask"},{"location":"#flask","text":"\u6b22\u8fce\u6765\u5230 Flask \u7684\u6587\u6863\u3002 \u5f00\u59cb\u4f7f\u7528 installation \uff0c\u7136\u540e\u4f7f\u7528 quickstart \u8fdb\u884c\u6982\u8ff0\u3002 \u8fd8\u6709\u4e00\u4e2a\u66f4\u8be6\u7ec6\u7684 \u6559\u7a0b \uff0c\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528 Flask \u521b\u5efa\u4e00\u4e2a\u5c0f\u800c\u5b8c\u6574\u7684\u5e94\u7528\u7a0b\u5e8f\u3002 \u5e38\u89c1\u7684\u6a21\u5f0f\u5728 patterns \u90e8\u5206\u4e2d\u63cf\u8ff0\u3002 \u5176\u4f59\u7684\u6587\u6863\u8be6\u7ec6\u63cf\u8ff0\u4e86 Flask \u7684\u6bcf\u4e2a\u7ec4\u4ef6\uff0c\u5e76\u5728 api \u90e8\u5206\u4e2d\u63d0\u4f9b\u4e86\u5b8c\u6574\u7684\u53c2\u8003\u3002 Flask \u4f9d\u8d56\u4e8e Jinja \u6a21\u677f\u5f15\u64ce\u548c Werkzeug WSGI \u5de5\u5177\u5305\u3002 \u53ef\u4ee5\u5728\u4ee5\u4e0b\u4f4d\u7f6e\u627e\u5230\u8fd9\u4e9b\u5e93\u7684\u6587\u6863: Jinja \u6587\u6863 Werkzeug \u6587\u6863 .. include:: contents.rst.inc","title":"\u6b22\u8fce\u6765\u5230 Flask"},{"location":"10.foreword/","text":"\u524d\u8a00 \u00b6 Read this before you get started with Flask. This hopefully answers some questions about the purpose and goals of the project, and when you should or should not be using it. \u201c\u5fae\u201d\u662f\u4ec0\u4e48\u610f\u601d\uff1f \u00b6 \u201cMicro\u201d does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The \"micro\" in microframework means Flask aims to keep the core simple but extensible. Flask won't make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don't. By default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be \"micro\", but it's ready for production use on a variety of needs. \u914d\u7f6e\u548c\u7ea6\u5b9a \u00b6 Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application's Python source tree, with the names :file: templates and :file: static respectively. While this can be changed, you usually don't have to, especially when getting started. \u4e0e\u70e7\u74f6\u4e00\u8d77\u6210\u957f \u00b6 Once you have Flask up and running, you'll find a variety of extensions available in the community to integrate your project for production. The Flask core team reviews extensions and ensures approved extensions do not break with future releases. As your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface. Flask includes many hooks to customize its behavior. Should you need more customization, the Flask class is built for subclassing. If you are interested in that, check out the :ref: becomingbig chapter. If you are curious about the Flask design principles, head over to the section about :ref: design . Continue to :ref: installation , the :ref: quickstart , or the :ref: advanced_foreword .","title":"\u524d\u8a00"},{"location":"10.foreword/#_1","text":"Read this before you get started with Flask. This hopefully answers some questions about the purpose and goals of the project, and when you should or should not be using it.","title":"\u524d\u8a00"},{"location":"10.foreword/#_2","text":"\u201cMicro\u201d does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The \"micro\" in microframework means Flask aims to keep the core simple but extensible. Flask won't make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don't. By default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be \"micro\", but it's ready for production use on a variety of needs.","title":"\u201c\u5fae\u201d\u662f\u4ec0\u4e48\u610f\u601d\uff1f"},{"location":"10.foreword/#_3","text":"Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application's Python source tree, with the names :file: templates and :file: static respectively. While this can be changed, you usually don't have to, especially when getting started.","title":"\u914d\u7f6e\u548c\u7ea6\u5b9a"},{"location":"10.foreword/#_4","text":"Once you have Flask up and running, you'll find a variety of extensions available in the community to integrate your project for production. The Flask core team reviews extensions and ensures approved extensions do not break with future releases. As your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface. Flask includes many hooks to customize its behavior. Should you need more customization, the Flask class is built for subclassing. If you are interested in that, check out the :ref: becomingbig chapter. If you are curious about the Flask design principles, head over to the section about :ref: design . Continue to :ref: installation , the :ref: quickstart , or the :ref: advanced_foreword .","title":"\u4e0e\u70e7\u74f6\u4e00\u8d77\u6210\u957f"},{"location":"11.advanced_foreword/","text":"\u6709\u7ecf\u9a8c\u7684\u7a0b\u5e8f\u5458\u7684\u524d\u8a00 \u00b6 Flask \u4e2d\u7684\u7ebf\u7a0b\u672c\u5730\u4eba \u00b6 One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don\u2019t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used. \u8c28\u614e\u5f00\u53d1 Web \u00b6 Always keep security in mind when building web applications. If you write a web application, you are probably allowing users to register and leave their data on your server. The users are entrusting you with data. And even if you are the only user that might leave data in your application, you still want that data to be stored securely. Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems. The documentation will warn you about aspects of web development that require attention to security. Some of these security concerns are far more complex than one might think, and we all sometimes underestimate the likelihood that a vulnerability will be exploited - until a clever attacker figures out a way to exploit our applications. And don't think that your application is not important enough to attract an attacker. Depending on the kind of attack, chances are that automated bots are probing for ways to fill your database with spam, links to malicious software, and the like. Flask is no different from any other framework in that you the developer must build with caution, watching for exploits when building to your requirements.","title":"\u6709\u7ecf\u9a8c\u7684\u7a0b\u5e8f\u5458\u7684\u524d\u8a00"},{"location":"11.advanced_foreword/#_1","text":"","title":"\u6709\u7ecf\u9a8c\u7684\u7a0b\u5e8f\u5458\u7684\u524d\u8a00"},{"location":"11.advanced_foreword/#flask","text":"One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don\u2019t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.","title":"Flask \u4e2d\u7684\u7ebf\u7a0b\u672c\u5730\u4eba"},{"location":"11.advanced_foreword/#web","text":"Always keep security in mind when building web applications. If you write a web application, you are probably allowing users to register and leave their data on your server. The users are entrusting you with data. And even if you are the only user that might leave data in your application, you still want that data to be stored securely. Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems. The documentation will warn you about aspects of web development that require attention to security. Some of these security concerns are far more complex than one might think, and we all sometimes underestimate the likelihood that a vulnerability will be exploited - until a clever attacker figures out a way to exploit our applications. And don't think that your application is not important enough to attract an attacker. Depending on the kind of attack, chances are that automated bots are probing for ways to fill your database with spam, links to malicious software, and the like. Flask is no different from any other framework in that you the developer must build with caution, watching for exploits when building to your requirements.","title":"\u8c28\u614e\u5f00\u53d1 Web"},{"location":"12.installation/","text":"\u5b89\u88c5 \u00b6 Python \u7248\u672c \u00b6 \u6211\u4eec\u5efa\u8bae\u4f7f\u7528\u6700\u65b0\u7248\u672c\u7684 Python 3. Flask \u652f\u6301 Python 3.4 \u53ca\u66f4\u65b0\u7248\u672c\uff0cPython 2.7 \u548c PyPy\u3002 \u4f9d\u8d56 \u00b6 \u5b89\u88c5 Flask \u65f6\u5c06\u81ea\u52a8\u5b89\u88c5\u8fd9\u4e9b\u53d1\u884c\u7248\u3002 Werkzeug \u5b9e\u73b0\u4e86 WSGI\uff0c\u5b83\u662f\u5e94\u7528\u7a0b\u5e8f\u548c\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u6807\u51c6 Python \u63a5\u53e3\u3002 Jinja \u662f\u4e00\u79cd\u6a21\u677f\u8bed\u8a00\uff0c\u7528\u4e8e\u5448\u73b0\u5e94\u7528\u7a0b\u5e8f\u6240\u670d\u52a1\u7684\u9875\u9762\u3002 MarkupSafe \u4f34\u968f\u7740 Jinja\u3002\u5b83\u5728\u6e32\u67d3\u6a21\u677f\u65f6\u9003\u907f\u4e0d\u53d7\u4fe1\u4efb\u7684\u8f93\u5165\u4ee5\u907f\u514d\u6ce8\u5165\u653b\u51fb\u3002 ItsDangerous \u5b89\u5168\u5730\u7b7e\u7f72\u6570\u636e\u4ee5\u786e\u4fdd\u5176\u5b8c\u6574\u6027\u3002\u8fd9\u7528\u4e8e\u4fdd\u62a4 Flask \u7684\u4f1a\u8bdd cookie\u3002 Click \u662f\u4e00\u4e2a\u7528\u4e8e\u7f16\u5199\u547d\u4ee4\u884c\u5e94\u7528\u7a0b\u5e8f\u7684\u6846\u67b6\u3002 \u5b83\u63d0\u4f9b flask \u547d\u4ee4\u5e76\u5141\u8bb8\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7ba1\u7406\u547d\u4ee4\u3002 \u53ef\u9009\u7684\u4f9d\u8d56\u9879 \u00b6 \u8fd9\u4e9b\u53d1\u884c\u7248\u4e0d\u4f1a\u81ea\u52a8\u5b89\u88c5\u3002 \u5982\u679c\u5b89\u88c5\u5b83\u4eec\uff0cFlask \u5c06\u68c0\u6d4b\u5e76\u4f7f\u7528\u5b83\u4eec\u3002 Blinker \u4e3a[signals]\u63d0\u4f9b\u652f\u6301\u3002 SimpleJSON \u662f\u4e00\u4e2a\u5feb\u901f\u7684 JSON \u5b9e\u73b0\uff0c\u5b83\u4e0e Python \u7684 json \u6a21\u5757\u517c\u5bb9\u3002\u5982\u679c\u5b89\u88c5\u4e86 JSON \u64cd\u4f5c\uff0c\u5219\u9996\u9009\u5b83\u3002 python-dotenv \u5728\u8fd0\u884c[flask]\u547d\u4ee4\u65f6\u652f\u6301[dotenv]\u3002 Watchdog \u4e3a\u5f00\u53d1\u670d\u52a1\u5668\u63d0\u4f9b\u4e86\u66f4\u5feb\uff0c\u66f4\u9ad8\u6548\u7684\u91cd\u65b0\u52a0\u8f7d\u5668\u3002 \u865a\u62df\u73af\u5883 \u00b6 \u4f7f\u7528\u865a\u62df\u73af\u5883\u5728\u5f00\u53d1\u548c\u751f\u4ea7\u4e2d\u7ba1\u7406\u9879\u76ee\u7684\u4f9d\u8d56\u5173\u7cfb\u3002 What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project. Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system's packages. Python 3 comes bundled with the :mod: venv module to create virtual environments. If you're using a modern version of Python, you can continue on to the next section. If you're using Python 2, see :ref: install-install-virtualenv first. \u521b\u5efa\u4e00\u4e2a\u73af\u5883 \u00b6 Create a project folder and a :file: venv folder within: $ mkdir myproject $ cd myproject $ python3 -m venv venv On Windows: $ py -3 -m venv venv If you needed to install virtualenv because you are using Python 2, use the following command instead: $ python2 -m virtualenv venv On Windows: > \\Python27\\Scripts\\virtualenv.exe venv \u6fc0\u6d3b\u73af\u5883 \u00b6 Before you work on your project, activate the corresponding environment: $ . venv/bin/activate On Windows: > venv\\Scripts\\activate Your shell prompt will change to show the name of the activated environment. \u5b89\u88c5\u70e7\u74f6 \u00b6 Within the activated environment, use the following command to install Flask: $ pip install Flask Flask is now installed. Check out the :doc: /quickstart or go to the :doc: Documentation Overview </index> . \u751f\u6d3b\u5728\u8fb9\u7f18 \u00b6 If you want to work with the latest Flask code before it's released, install or update the code from the master branch: $ pip install -U https://github.com/pallets/flask/archive/master.tar.gz .. install-install-virtualenv: \u5b89\u88c5 virtualenv \u00b6 If you are using Python 2, the venv module is not available. Instead, install virtualenv . On Linux, virtualenv is provided by your package manager: # Debian, Ubuntu $ sudo apt-get install python-virtualenv # CentOS, Fedora $ sudo yum install python-virtualenv # Arch $ sudo pacman -S python-virtualenv If you are on Mac OS X or Windows, download get-pip.py , then: $ sudo python2 Downloads/get-pip.py $ sudo python2 -m pip install virtualenv On Windows, as an administrator: > \\Python27\\python.exe Downloads\\get-pip.py > \\Python27\\python.exe -m pip install virtualenv Now you can return above and :ref: install-create-env .","title":"\u5b89\u88c5"},{"location":"12.installation/#_1","text":"","title":"\u5b89\u88c5"},{"location":"12.installation/#python","text":"\u6211\u4eec\u5efa\u8bae\u4f7f\u7528\u6700\u65b0\u7248\u672c\u7684 Python 3. Flask \u652f\u6301 Python 3.4 \u53ca\u66f4\u65b0\u7248\u672c\uff0cPython 2.7 \u548c PyPy\u3002","title":"Python \u7248\u672c"},{"location":"12.installation/#_2","text":"\u5b89\u88c5 Flask \u65f6\u5c06\u81ea\u52a8\u5b89\u88c5\u8fd9\u4e9b\u53d1\u884c\u7248\u3002 Werkzeug \u5b9e\u73b0\u4e86 WSGI\uff0c\u5b83\u662f\u5e94\u7528\u7a0b\u5e8f\u548c\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u6807\u51c6 Python \u63a5\u53e3\u3002 Jinja \u662f\u4e00\u79cd\u6a21\u677f\u8bed\u8a00\uff0c\u7528\u4e8e\u5448\u73b0\u5e94\u7528\u7a0b\u5e8f\u6240\u670d\u52a1\u7684\u9875\u9762\u3002 MarkupSafe \u4f34\u968f\u7740 Jinja\u3002\u5b83\u5728\u6e32\u67d3\u6a21\u677f\u65f6\u9003\u907f\u4e0d\u53d7\u4fe1\u4efb\u7684\u8f93\u5165\u4ee5\u907f\u514d\u6ce8\u5165\u653b\u51fb\u3002 ItsDangerous \u5b89\u5168\u5730\u7b7e\u7f72\u6570\u636e\u4ee5\u786e\u4fdd\u5176\u5b8c\u6574\u6027\u3002\u8fd9\u7528\u4e8e\u4fdd\u62a4 Flask \u7684\u4f1a\u8bdd cookie\u3002 Click \u662f\u4e00\u4e2a\u7528\u4e8e\u7f16\u5199\u547d\u4ee4\u884c\u5e94\u7528\u7a0b\u5e8f\u7684\u6846\u67b6\u3002 \u5b83\u63d0\u4f9b flask \u547d\u4ee4\u5e76\u5141\u8bb8\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7ba1\u7406\u547d\u4ee4\u3002","title":"\u4f9d\u8d56"},{"location":"12.installation/#_3","text":"\u8fd9\u4e9b\u53d1\u884c\u7248\u4e0d\u4f1a\u81ea\u52a8\u5b89\u88c5\u3002 \u5982\u679c\u5b89\u88c5\u5b83\u4eec\uff0cFlask \u5c06\u68c0\u6d4b\u5e76\u4f7f\u7528\u5b83\u4eec\u3002 Blinker \u4e3a[signals]\u63d0\u4f9b\u652f\u6301\u3002 SimpleJSON \u662f\u4e00\u4e2a\u5feb\u901f\u7684 JSON \u5b9e\u73b0\uff0c\u5b83\u4e0e Python \u7684 json \u6a21\u5757\u517c\u5bb9\u3002\u5982\u679c\u5b89\u88c5\u4e86 JSON \u64cd\u4f5c\uff0c\u5219\u9996\u9009\u5b83\u3002 python-dotenv \u5728\u8fd0\u884c[flask]\u547d\u4ee4\u65f6\u652f\u6301[dotenv]\u3002 Watchdog \u4e3a\u5f00\u53d1\u670d\u52a1\u5668\u63d0\u4f9b\u4e86\u66f4\u5feb\uff0c\u66f4\u9ad8\u6548\u7684\u91cd\u65b0\u52a0\u8f7d\u5668\u3002","title":"\u53ef\u9009\u7684\u4f9d\u8d56\u9879"},{"location":"12.installation/#_4","text":"\u4f7f\u7528\u865a\u62df\u73af\u5883\u5728\u5f00\u53d1\u548c\u751f\u4ea7\u4e2d\u7ba1\u7406\u9879\u76ee\u7684\u4f9d\u8d56\u5173\u7cfb\u3002 What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project. Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system's packages. Python 3 comes bundled with the :mod: venv module to create virtual environments. If you're using a modern version of Python, you can continue on to the next section. If you're using Python 2, see :ref: install-install-virtualenv first.","title":"\u865a\u62df\u73af\u5883"},{"location":"12.installation/#_5","text":"Create a project folder and a :file: venv folder within: $ mkdir myproject $ cd myproject $ python3 -m venv venv On Windows: $ py -3 -m venv venv If you needed to install virtualenv because you are using Python 2, use the following command instead: $ python2 -m virtualenv venv On Windows: > \\Python27\\Scripts\\virtualenv.exe venv","title":"\u521b\u5efa\u4e00\u4e2a\u73af\u5883"},{"location":"12.installation/#_6","text":"Before you work on your project, activate the corresponding environment: $ . venv/bin/activate On Windows: > venv\\Scripts\\activate Your shell prompt will change to show the name of the activated environment.","title":"\u6fc0\u6d3b\u73af\u5883"},{"location":"12.installation/#_7","text":"Within the activated environment, use the following command to install Flask: $ pip install Flask Flask is now installed. Check out the :doc: /quickstart or go to the :doc: Documentation Overview </index> .","title":"\u5b89\u88c5\u70e7\u74f6"},{"location":"12.installation/#_8","text":"If you want to work with the latest Flask code before it's released, install or update the code from the master branch: $ pip install -U https://github.com/pallets/flask/archive/master.tar.gz .. install-install-virtualenv:","title":"\u751f\u6d3b\u5728\u8fb9\u7f18"},{"location":"12.installation/#virtualenv","text":"If you are using Python 2, the venv module is not available. Instead, install virtualenv . On Linux, virtualenv is provided by your package manager: # Debian, Ubuntu $ sudo apt-get install python-virtualenv # CentOS, Fedora $ sudo yum install python-virtualenv # Arch $ sudo pacman -S python-virtualenv If you are on Mac OS X or Windows, download get-pip.py , then: $ sudo python2 Downloads/get-pip.py $ sudo python2 -m pip install virtualenv On Windows, as an administrator: > \\Python27\\python.exe Downloads\\get-pip.py > \\Python27\\python.exe -m pip install virtualenv Now you can return above and :ref: install-create-env .","title":"\u5b89\u88c5 virtualenv"},{"location":"13.quickstart/","text":"Quickstart \u00b6 Eager to get started? This page gives a good introduction to Flask. It assumes you already have Flask installed. If you do not, head over to the :ref: installation section. A Minimal Application \u00b6 A minimal Flask application looks something like this:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello_world (): return 'Hello, World!' So what did that code do? First we imported the :class: ~flask.Flask class. An instance of this class will be our WSGI application. Next we create an instance of this class. The first argument is the name of the application's module or package. If you are using a single module (as in this example), you should use __name__ because depending on if it's started as application or imported as module the name will be different ( '__main__' versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the :class: ~flask.Flask documentation. We then use the :meth: ~flask.Flask.route decorator to tell Flask what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user's browser. Just save it as :file: hello.py or something similar. Make sure to not call your application :file: flask.py because this would conflict with Flask itself. To run the application you can either use the :command: flask command or python's -m switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable:: $ export FLASK_APP = hello.py $ flask run * Running on http://127.0.0.1:5000/ If you are on Windows, the environment variable syntax depends on command line interpreter. On Command Prompt:: C : \\ path \\ to \\ app & gt ; set FLASK_APP = hello . py And on PowerShell:: PS C : \\ path \\ to \\ app & gt ; $ env : FLASK_APP = \"hello.py\" Alternatively you can use :command: python -m flask :: $ export FLASK_APP = hello.py $ python -m flask run * Running on http://127.0.0.1:5000/ This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see :ref: deployment . Now head over to http://127.0.0.1:5000/ <http://127.0.0.1:5000/> _, and you should see your hello world greeting. .. admonition:: Externally Visible Server If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line:: $ flask run --host=0.0.0.0 This tells your operating system to listen on all public IPs. What to do if the Server does not Start \u00b6 In case the :command: python -m flask fails or :command: flask does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message. Old Version of Flask Versions of Flask older than 0.11 use to have different ways to start the application . In short , the : command : `flask` command did not exist , and neither did : command : `python -m flask` . In that case you have two options : either upgrade to newer Flask versions or have a look at the : ref : `server` docs to see the alternative method for running a server . Invalid Import Name `````````````````` ` The `` FLASK_APP `` environment variable is the name of the module to import at : command : `flask run` . In case that module is incorrectly named you will get an import error upon start ( or if debug is enabled when you navigate to the application ) . It will tell you what it tried to import and why it failed. The most common reason is a typo or because you did not actually create an `` app `` object . .. _debug - mode : Debug Mode ---------- ( Want to just log errors and stack traces ? See : ref : `application-errors` ) The : command : `flask` script is nice to start a local development server , but you would have to restart it manually after each change to your code . That is not very nice and Flask can do better . If you enable debug support the server will reload itself on code changes , and it will also provide you with a helpful debugger if things go wrong . To enable all development features ( including debug mode ) you can export the `` FLASK_ENV `` environment variable and set it to `` development `` before running the server :: $ export FLASK_ENV = development $ flask run ( On Windows you need to use `` set `` instead of `` export `` . ) This does the following things : 1. it activates the debugger 2. it activates the automatic reloader 3. it enables the debug mode on the Flask application . You can also control debug mode separately from the environment by exporting `` FLASK_DEBUG = 1 `` . There are more parameters that are explained in the : ref : `server` docs . .. admonition :: Attention Even though the interactive debugger does not work in forking environments ( which makes it nearly impossible to use on production servers ), it still allows the execution of arbitrary code . This makes it a major security risk and therefore it ** must never be used on production machines **. Screenshot of the debugger in action : .. image :: _static / debugger . png : align : center : class : screenshot : alt : screenshot of debugger in action More information on using the debugger can be found in the ` Werkzeug documentation ` _ . .. _Werkzeug documentation : http : // werkzeug . pocoo . org / docs / debug / #using-the-debugger Have another debugger in mind ? See : ref : `working-with-debuggers` . Routing ------- Modern web applications use meaningful URLs to help users . Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page . Use the : meth : `~flask.Flask.route` decorator to bind a function to a URL . :: @app.route ( '/' ) def index (): return 'Index Page' @app.route ( '/hello' ) def hello (): return 'Hello, World' You can do more ! You can make parts of the URL dynamic and attach multiple rules to a function . Variable Rules `````````````` You can add variable sections to a URL by marking sections with `` < variable_name > `` . Your function then receives the `` < variable_name > `` as a keyword argument . Optionally , you can use a converter to specify the type of the argument like `` < converter : variable_name > `` . :: @app.route ( '/user/<username>' ) def show_user_profile ( username ): # show the user profile for that user return 'User %s ' % username @app.route ( '/post/<int:post_id>' ) def show_post ( post_id ): # show the post with the given id, the id is an integer return 'Post %d ' % post_id @app.route ( '/path/<path:subpath>' ) def show_subpath ( subpath ): # show the subpath after /path/ return 'Subpath %s ' % subpath Converter types : ========== ========================================== `` string `` ( default ) accepts any text without a slash `` int `` accepts positive integers `` float `` accepts positive floating point values `` path `` like `` string `` but also accepts slashes `` uuid `` accepts UUID strings ========== ========================================== Unique URLs / Redirection Behavior The following two rules differ in their use of a trailing slash. :: @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page' The canonical URL for the projects endpoint has a trailing slash. It's similar to a folder in a file system. If you access the URL without a trailing slash, Flask redirects you to the canonical URL with the trailing slash. The canonical URL for the about endpoint does not have a trailing slash. It's similar to the pathname of a file. Accessing the URL with a trailing slash produces a 404 \"Not Found\" error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. URL Building To build a URL to a specific function, use the :func:`~flask.url_for` function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters. Why would you want to build URLs using the URL reversing function :func:`~flask.url_for` instead of hard-coding them into your templates? 1. Reversing is often more descriptive than hard-coding the URLs. 2. You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs. 3. URL building handles escaping of special characters and Unicode data transparently. 4. The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers. 5. If your application is placed outside the URL root, for example, in ``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly handles that for you. For example, here we use the :meth:`~flask.Flask.test_request_context` method to try out :func:`~flask.url_for`. :meth:`~flask.Flask.test_request_context` tells Flask to behave as though it's handling a request even while we use a Python shell. See :ref:`context-locals`. .. code-block:: python from flask import Flask, url_for app = Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/login') def login(): return 'login' @app.route('/user/<username>') def profile(username): return '{}\\'s profile'.format(username) with app.test_request_context(): print(url_for('index')) print(url_for('login')) print(url_for('login', next='/')) print(url_for('profile', username='John Doe')) .. code-block:: text / /login /login?next=/ /user/John%20Doe HTTP Methods Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the :meth: ~flask.Flask.route decorator to handle different HTTP methods. :: from flask import request @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : return do_the_login () else : return show_the_login_form () If GET is present, Flask automatically adds support for the HEAD method and handles HEAD requests according to the HTTP RFC _. Likewise, OPTIONS is automatically implemented for you. .. _HTTP RFC: https://www.ietf.org/rfc/rfc2068.txt Static Files \u00b6 Dynamic web applications also need static files. That's usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called :file: static in your package or next to your module and it will be available at /static on the application. To generate URLs for static files, use the special 'static' endpoint name:: url_for('static', filename='style.css') The file has to be stored on the filesystem as :file: static/style.css . Rendering Templates \u00b6 Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 <http://jinja.pocoo.org/> _ template engine for you automatically. To render a template you can use the :func: ~flask.render_template method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here's a simple example of how to render a template:: from flask import render_template @app.route ( '/hello/' ) @app.route ( '/hello/&lt;name&gt;' ) def hello ( name = None ): return render_template ( 'hello.html' , name = name ) Flask will look for templates in the :file: templates folder. So if your application is a module, this folder is next to that module, if it's a package it's actually inside your package: Case 1 : a module:: /application.py /templates /hello.html Case 2 : a package:: /application /__init__.py /templates /hello.html For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation <http://jinja.pocoo.org/docs/templates> _ for more information. Here is an example template: .. sourcecode:: html+jinja &lt;!doctype html&gt; &lt;title&gt;Hello from Flask&lt;/title&gt; {% if name %} &lt;h1&gt;Hello {{ name }} !&lt;/h1&gt; {% else %} &lt;h1&gt;Hello, World!&lt;/h1&gt; {% endif %} Inside templates you also have access to the :class: ~flask.request , :class: ~flask.session and :class: ~flask.g [#]_ objects as well as the :func: ~flask.get_flashed_messages function. Templates are especially useful if inheritance is used. If you want to know how that works, head over to the :ref: template-inheritance pattern documentation. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer). Automatic escaping is enabled, so if name contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the :class: ~jinja2.Markup class or by using the |safe filter in the template. Head over to the Jinja 2 documentation for more examples. Here is a basic introduction to how the :class: ~jinja2.Markup class works:: & gt ; & gt ; & gt ; from flask import Markup & gt ; & gt ; & gt ; Markup ( '&lt;strong&gt;Hello %s !&lt;/strong&gt;' ) % '&lt;blink&gt;hacker&lt;/blink&gt;' Markup ( u '&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;' ) & gt ; & gt ; & gt ; Markup . escape ( '&lt;blink&gt;hacker&lt;/blink&gt;' ) Markup ( u '&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;' ) & gt ; & gt ; & gt ; Markup ( '&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML' ) . striptags () u 'Marked up \\xbb HTML' .. versionchanged:: 0.5 Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: .html , .htm , .xml , .xhtml . Templates loaded from a string will have autoescaping disabled. .. [#] Unsure what that :class: ~flask.g object is? It's something in which you can store information for your own needs, check the documentation of that object (:class: ~flask.g ) and the :ref: sqlite3 for more information. Accessing Request Data \u00b6 For web applications it's crucial to react to the data a client sends to the server. In Flask this information is provided by the global :class: ~flask.request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals: Context Locals .. admonition:: Insider Information If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it. Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand. Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking. So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the :meth:`~flask.Flask.test_request_context` context manager. In combination with the ``with`` statement it will bind a test request so that you can interact with it. Here is an example:: from flask import request with app.test_request_context('/hello', method='POST'): # now you can do something with the request until the # end of the with block, such as basic assertions: assert request.path == '/hello' assert request.method == 'POST' The other possibility is passing a whole WSGI environment to the :meth:`~flask.Flask.request_context` method:: from flask import request with app.request_context(environ): assert request.method == 'POST' The Request Object The request object is documented in the API section and we will not cover it here in detail (see :class: ~flask.Request ). Here is a broad overview of some of the most common operations. First of all you have to import it from the flask module:: from flask import request The current request method is available by using the :attr: ~flask.Request.method attribute. To access form data (data transmitted in a POST or PUT request) you can use the :attr: ~flask.Request.form attribute. Here is a full example of the two attributes mentioned above:: @app.route('/login', methods=['POST', 'GET']) def login(): error = None if request.method == 'POST': if valid_login(request.form['username'], request.form['password']): return log_the_user_in(request.form['username']) else: error = 'Invalid username/password' # the code below is executed if the request method # was GET or the credentials were invalid return render_template('login.html', error=error) What happens if the key does not exist in the form attribute? In that case a special :exc: KeyError is raised. You can catch it like a standard :exc: KeyError but if you don't do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don't have to deal with that problem. To access parameters submitted in the URL ( ?key=value ) you can use the :attr: ~flask.Request.args attribute:: searchword = request.args.get('key', '') We recommend accessing URL parameters with get or by catching the :exc: KeyError because users might change the URL and presenting them a 400 bad request page in that case is not user friendly. For a full list of methods and attributes of the request object, head over to the :class: ~flask.Request documentation. File Uploads You can handle uploaded files with Flask easily . Just make sure not to forget to set the `` enctype = \"multipart/form-data\" `` attribute on your HTML form , otherwise the browser will not transmit your files at all . Uploaded files are stored in memory or at a temporary location on the filesystem . You can access those files by looking at the : attr : `~flask.request.files` attribute on the request object . Each uploaded file is stored in that dictionary . It behaves just like a standard Python : class : `file` object , but it also has a : meth : `~werkzeug.datastructures.FileStorage.save` method that allows you to store that file on the filesystem of the server . Here is a simple example showing how that works :: from flask import request @app.route ( '/upload' , methods = [ 'GET' , 'POST' ]) def upload_file (): if request . method == 'POST' : f = request . files [ 'the_file' ] f . save ( '/var/www/uploads/uploaded_file.txt' ) ... If you want to know how the file was named on the client before it was uploaded to your application , you can access the : attr : `~werkzeug.datastructures.FileStorage.filename` attribute . However please keep in mind that this value can be forged so never ever trust that value . If you want to use the filename of the client to store the file on the server , pass it through the : func : `~werkzeug.utils.secure_filename` function that Werkzeug provides for you :: from flask import request from werkzeug.utils import secure_filename @app.route ( '/upload' , methods = [ 'GET' , 'POST' ]) def upload_file (): if request . method == 'POST' : f = request . files [ 'the_file' ] f . save ( '/var/www/uploads/' + secure_filename ( f . filename )) ... For some better examples , checkout the : ref : `uploading-files` pattern . Cookies `````` ` To access cookies you can use the : attr : `~flask.Request.cookies` attribute . To set cookies you can use the : attr : `~flask.Response.set_cookie` method of response objects . The : attr : `~flask.Request.cookies` attribute of request objects is a dictionary with all the cookies the client transmits . If you want to use sessions , do not use the cookies directly but instead use the : ref : `sessions` in Flask that add some security on top of cookies for you . Reading cookies :: from flask import request @app.route ( '/' ) def index (): username = request . cookies . get ( 'username' ) # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. Storing cookies :: from flask import make_response @app.route ( '/' ) def index (): resp = make_response ( render_template ( ... )) resp . set_cookie ( 'username' , 'the username' ) return resp Note that cookies are set on response objects . Since you normally just return strings from the view functions Flask will convert them into response objects for you . If you explicitly want to do that you can use the : meth : `~flask.make_response` function and then modify it . Sometimes you might want to set a cookie at a point where the response object does not exist yet . This is possible by utilizing the : ref : `deferred-callbacks` pattern . For this also see : ref : `about-responses` . Redirects and Errors -------------------- To redirect a user to another endpoint , use the : func : `~flask.redirect` function ; to abort a request early with an error code , use the : func : `~flask.abort` function :: from flask import abort , redirect , url_for @app.route ( '/' ) def index (): return redirect ( url_for ( 'login' )) @app.route ( '/login' ) def login (): abort ( 401 ) this_is_never_executed () This is a rather pointless example because a user will be redirected from the index to a page they cannot access ( 401 means access denied ) but it shows how that works . By default a black and white error page is shown for each error code . If you want to customize the error page , you can use the : meth : `~flask.Flask.errorhandler` decorator :: from flask import render_template @app.errorhandler ( 404 ) def page_not_found ( error ): return render_template ( 'page_not_found.html' ), 404 Note the `` 404 `` after the : func : `~flask.render_template` call . This tells Flask that the status code of that page should be 404 which means not found . By default 200 is assumed which translates to : all went well . See : ref : `error-handlers` for more details . .. _about - responses : About Responses --------------- The return value from a view function is automatically converted into a response object for you . If the return value is a string it 's converted into a response object with the string as response body , a `` 200 OK `` status code and a : mimetype : `text/html` mimetype . The logic that Flask applies to converting return values into response objects is as follows : 1. If a response object of the correct type is returned it 's directly returned from the view. 2. If it 's a string, a response object is created with that data and the default parameters . 3. If a tuple is returned the items in the tuple can provide extra information . Such tuples have to be in the form `` ( response , status , headers ) `` or `` ( response , headers ) `` where at least one item has to be in the tuple . The `` status `` value will override the status code and `` headers `` can be a list or dictionary of additional header values . 4. If none of that works , Flask will assume the return value is a valid WSGI application and convert that into a response object . If you want to get hold of the resulting response object inside the view you can use the : func : `~flask.make_response` function . Imagine you have a view like this :: @app.errorhandler ( 404 ) def not_found ( error ): return render_template ( 'error.html' ), 404 You just need to wrap the return expression with : func : `~flask.make_response` and get the response object to modify it , then return it :: @app.errorhandler ( 404 ) def not_found ( error ): resp = make_response ( render_template ( 'error.html' ), 404 ) resp . headers [ 'X-Something' ] = 'A value' return resp .. _sessions : Sessions -------- In addition to the request object there is also a second object called : class : `~flask.session` which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically . What this means is that the user could look at the contents of your cookie but not modify it , unless they know the secret key used for signing . In order to use sessions you have to set a secret key . Here is how sessions work :: from flask import Flask , session , redirect , url_for , escape , request app = Flask ( __name__ ) # Set the secret key to some random bytes. Keep this really secret! app . secret_key = b '_5#y2L\"F4Q8z \\n\\xec ]/' @app.route ( '/' ) def index (): if 'username' in session : return 'Logged in as %s ' % escape ( session [ 'username' ]) return 'You are not logged in' @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : session [ 'username' ] = request . form [ 'username' ] return redirect ( url_for ( 'index' )) return ''' <form method=\"post\"> <p><input type=text name=username> <p><input type=submit value=Login> </form> ''' @app.route ( '/logout' ) def logout (): # remove the username from the session if it's there session . pop ( 'username' , None ) return redirect ( url_for ( 'index' )) The : func : `~flask.escape` mentioned here does escaping for you if you are not using the template engine ( as in this example ) . .. admonition :: How to generate good secret keys A secret key should be as random as possible . Your operating system has ways to generate pretty random data based on a cryptographic random generator . Use the following command to quickly generate a value for : attr : `Flask.secret_key` ( or : data : `SECRET_KEY` ):: $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' A note on cookie - based sessions : Flask will take the values you put into the session object and serialize them into a cookie . If you are finding some values do not persist across requests , cookies are indeed enabled , and you are not getting a clear error message , check the size of the cookie in your page responses compared to the size supported by web browsers . Besides the default client - side based sessions , if you want to handle sessions on the server - side instead , there are several Flask extensions that support this . Message Flashing ---------------- Good applications and user interfaces are all about feedback . If the user does not get enough feedback they will probably end up hating the application . Flask provides a really simple way to give feedback to a user with the flashing system . The flashing system basically makes it possible to record a message at the end of a request and access it on the next ( and only the next ) request . This is usually combined with a layout template to expose the message . To flash a message use the : func : `~flask.flash` method , to get hold of the messages you can use : func : `~flask.get_flashed_messages` which is also available in the templates . Check out the : ref : `message-flashing-pattern` for a full example . Logging ------- .. versionadded :: 0.3 Sometimes you might be in a situation where you deal with data that should be correct , but actually is not . For example you may have some client - side code that sends an HTTP request to the server but it 's obviously malformed . This might be caused by a user tampering with the data , or the client code failing . Most of the time it 's okay to reply with ``400 Bad Request `` in that situation , but sometimes that won 't do and the code has to continue working . You may still want to log that something fishy happened . This is where loggers come in handy . As of Flask 0.3 a logger is preconfigured for you to use . Here are some example log calls :: app . logger . debug ( 'A value for debugging' ) app . logger . warning ( 'A warning occurred ( %d apples)' , 42 ) app . logger . error ( 'An error occurred' ) The attached : attr : `~flask.Flask.logger` is a standard logging : class : `~logging.Logger` , so head over to the official ` logging documentation < https : // docs . python . org / library / logging . html > ` _ for more information . Read more on : ref : `application-errors` . Hooking in WSGI Middlewares --------------------------- If you want to add a WSGI middleware to your application you can wrap the internal WSGI application . For example if you want to use one of the middlewares from the Werkzeug package to work around bugs in lighttpd , you can do it like this :: from werkzeug.contrib.fixers import LighttpdCGIRootFix app . wsgi_app = LighttpdCGIRootFix ( app . wsgi_app ) Using Flask Extensions ---------------------- Extensions are packages that help you accomplish common tasks . For example , Flask - SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask . For more on Flask extensions , have a look at : ref : `extensions` . Deploying to a Web Server ------------------------- Ready to deploy your new Flask app ? Go to : ref : `deployment` .","title":"Quickstart"},{"location":"13.quickstart/#quickstart","text":"Eager to get started? This page gives a good introduction to Flask. It assumes you already have Flask installed. If you do not, head over to the :ref: installation section.","title":"Quickstart"},{"location":"13.quickstart/#a-minimal-application","text":"A minimal Flask application looks something like this:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello_world (): return 'Hello, World!' So what did that code do? First we imported the :class: ~flask.Flask class. An instance of this class will be our WSGI application. Next we create an instance of this class. The first argument is the name of the application's module or package. If you are using a single module (as in this example), you should use __name__ because depending on if it's started as application or imported as module the name will be different ( '__main__' versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the :class: ~flask.Flask documentation. We then use the :meth: ~flask.Flask.route decorator to tell Flask what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user's browser. Just save it as :file: hello.py or something similar. Make sure to not call your application :file: flask.py because this would conflict with Flask itself. To run the application you can either use the :command: flask command or python's -m switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable:: $ export FLASK_APP = hello.py $ flask run * Running on http://127.0.0.1:5000/ If you are on Windows, the environment variable syntax depends on command line interpreter. On Command Prompt:: C : \\ path \\ to \\ app & gt ; set FLASK_APP = hello . py And on PowerShell:: PS C : \\ path \\ to \\ app & gt ; $ env : FLASK_APP = \"hello.py\" Alternatively you can use :command: python -m flask :: $ export FLASK_APP = hello.py $ python -m flask run * Running on http://127.0.0.1:5000/ This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see :ref: deployment . Now head over to http://127.0.0.1:5000/ <http://127.0.0.1:5000/> _, and you should see your hello world greeting. .. admonition:: Externally Visible Server If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line:: $ flask run --host=0.0.0.0 This tells your operating system to listen on all public IPs.","title":"A Minimal Application"},{"location":"13.quickstart/#what-to-do-if-the-server-does-not-start","text":"In case the :command: python -m flask fails or :command: flask does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message. Old Version of Flask Versions of Flask older than 0.11 use to have different ways to start the application . In short , the : command : `flask` command did not exist , and neither did : command : `python -m flask` . In that case you have two options : either upgrade to newer Flask versions or have a look at the : ref : `server` docs to see the alternative method for running a server . Invalid Import Name `````````````````` ` The `` FLASK_APP `` environment variable is the name of the module to import at : command : `flask run` . In case that module is incorrectly named you will get an import error upon start ( or if debug is enabled when you navigate to the application ) . It will tell you what it tried to import and why it failed. The most common reason is a typo or because you did not actually create an `` app `` object . .. _debug - mode : Debug Mode ---------- ( Want to just log errors and stack traces ? See : ref : `application-errors` ) The : command : `flask` script is nice to start a local development server , but you would have to restart it manually after each change to your code . That is not very nice and Flask can do better . If you enable debug support the server will reload itself on code changes , and it will also provide you with a helpful debugger if things go wrong . To enable all development features ( including debug mode ) you can export the `` FLASK_ENV `` environment variable and set it to `` development `` before running the server :: $ export FLASK_ENV = development $ flask run ( On Windows you need to use `` set `` instead of `` export `` . ) This does the following things : 1. it activates the debugger 2. it activates the automatic reloader 3. it enables the debug mode on the Flask application . You can also control debug mode separately from the environment by exporting `` FLASK_DEBUG = 1 `` . There are more parameters that are explained in the : ref : `server` docs . .. admonition :: Attention Even though the interactive debugger does not work in forking environments ( which makes it nearly impossible to use on production servers ), it still allows the execution of arbitrary code . This makes it a major security risk and therefore it ** must never be used on production machines **. Screenshot of the debugger in action : .. image :: _static / debugger . png : align : center : class : screenshot : alt : screenshot of debugger in action More information on using the debugger can be found in the ` Werkzeug documentation ` _ . .. _Werkzeug documentation : http : // werkzeug . pocoo . org / docs / debug / #using-the-debugger Have another debugger in mind ? See : ref : `working-with-debuggers` . Routing ------- Modern web applications use meaningful URLs to help users . Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page . Use the : meth : `~flask.Flask.route` decorator to bind a function to a URL . :: @app.route ( '/' ) def index (): return 'Index Page' @app.route ( '/hello' ) def hello (): return 'Hello, World' You can do more ! You can make parts of the URL dynamic and attach multiple rules to a function . Variable Rules `````````````` You can add variable sections to a URL by marking sections with `` < variable_name > `` . Your function then receives the `` < variable_name > `` as a keyword argument . Optionally , you can use a converter to specify the type of the argument like `` < converter : variable_name > `` . :: @app.route ( '/user/<username>' ) def show_user_profile ( username ): # show the user profile for that user return 'User %s ' % username @app.route ( '/post/<int:post_id>' ) def show_post ( post_id ): # show the post with the given id, the id is an integer return 'Post %d ' % post_id @app.route ( '/path/<path:subpath>' ) def show_subpath ( subpath ): # show the subpath after /path/ return 'Subpath %s ' % subpath Converter types : ========== ========================================== `` string `` ( default ) accepts any text without a slash `` int `` accepts positive integers `` float `` accepts positive floating point values `` path `` like `` string `` but also accepts slashes `` uuid `` accepts UUID strings ========== ========================================== Unique URLs / Redirection Behavior The following two rules differ in their use of a trailing slash. :: @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page' The canonical URL for the projects endpoint has a trailing slash. It's similar to a folder in a file system. If you access the URL without a trailing slash, Flask redirects you to the canonical URL with the trailing slash. The canonical URL for the about endpoint does not have a trailing slash. It's similar to the pathname of a file. Accessing the URL with a trailing slash produces a 404 \"Not Found\" error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. URL Building To build a URL to a specific function, use the :func:`~flask.url_for` function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters. Why would you want to build URLs using the URL reversing function :func:`~flask.url_for` instead of hard-coding them into your templates? 1. Reversing is often more descriptive than hard-coding the URLs. 2. You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs. 3. URL building handles escaping of special characters and Unicode data transparently. 4. The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers. 5. If your application is placed outside the URL root, for example, in ``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly handles that for you. For example, here we use the :meth:`~flask.Flask.test_request_context` method to try out :func:`~flask.url_for`. :meth:`~flask.Flask.test_request_context` tells Flask to behave as though it's handling a request even while we use a Python shell. See :ref:`context-locals`. .. code-block:: python from flask import Flask, url_for app = Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/login') def login(): return 'login' @app.route('/user/<username>') def profile(username): return '{}\\'s profile'.format(username) with app.test_request_context(): print(url_for('index')) print(url_for('login')) print(url_for('login', next='/')) print(url_for('profile', username='John Doe')) .. code-block:: text / /login /login?next=/ /user/John%20Doe HTTP Methods Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the :meth: ~flask.Flask.route decorator to handle different HTTP methods. :: from flask import request @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : return do_the_login () else : return show_the_login_form () If GET is present, Flask automatically adds support for the HEAD method and handles HEAD requests according to the HTTP RFC _. Likewise, OPTIONS is automatically implemented for you. .. _HTTP RFC: https://www.ietf.org/rfc/rfc2068.txt","title":"What to do if the Server does not Start"},{"location":"13.quickstart/#static-files","text":"Dynamic web applications also need static files. That's usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called :file: static in your package or next to your module and it will be available at /static on the application. To generate URLs for static files, use the special 'static' endpoint name:: url_for('static', filename='style.css') The file has to be stored on the filesystem as :file: static/style.css .","title":"Static Files"},{"location":"13.quickstart/#rendering-templates","text":"Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 <http://jinja.pocoo.org/> _ template engine for you automatically. To render a template you can use the :func: ~flask.render_template method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here's a simple example of how to render a template:: from flask import render_template @app.route ( '/hello/' ) @app.route ( '/hello/&lt;name&gt;' ) def hello ( name = None ): return render_template ( 'hello.html' , name = name ) Flask will look for templates in the :file: templates folder. So if your application is a module, this folder is next to that module, if it's a package it's actually inside your package: Case 1 : a module:: /application.py /templates /hello.html Case 2 : a package:: /application /__init__.py /templates /hello.html For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation <http://jinja.pocoo.org/docs/templates> _ for more information. Here is an example template: .. sourcecode:: html+jinja &lt;!doctype html&gt; &lt;title&gt;Hello from Flask&lt;/title&gt; {% if name %} &lt;h1&gt;Hello {{ name }} !&lt;/h1&gt; {% else %} &lt;h1&gt;Hello, World!&lt;/h1&gt; {% endif %} Inside templates you also have access to the :class: ~flask.request , :class: ~flask.session and :class: ~flask.g [#]_ objects as well as the :func: ~flask.get_flashed_messages function. Templates are especially useful if inheritance is used. If you want to know how that works, head over to the :ref: template-inheritance pattern documentation. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer). Automatic escaping is enabled, so if name contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the :class: ~jinja2.Markup class or by using the |safe filter in the template. Head over to the Jinja 2 documentation for more examples. Here is a basic introduction to how the :class: ~jinja2.Markup class works:: & gt ; & gt ; & gt ; from flask import Markup & gt ; & gt ; & gt ; Markup ( '&lt;strong&gt;Hello %s !&lt;/strong&gt;' ) % '&lt;blink&gt;hacker&lt;/blink&gt;' Markup ( u '&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;' ) & gt ; & gt ; & gt ; Markup . escape ( '&lt;blink&gt;hacker&lt;/blink&gt;' ) Markup ( u '&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;' ) & gt ; & gt ; & gt ; Markup ( '&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML' ) . striptags () u 'Marked up \\xbb HTML' .. versionchanged:: 0.5 Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: .html , .htm , .xml , .xhtml . Templates loaded from a string will have autoescaping disabled. .. [#] Unsure what that :class: ~flask.g object is? It's something in which you can store information for your own needs, check the documentation of that object (:class: ~flask.g ) and the :ref: sqlite3 for more information.","title":"Rendering Templates"},{"location":"13.quickstart/#accessing-request-data","text":"For web applications it's crucial to react to the data a client sends to the server. In Flask this information is provided by the global :class: ~flask.request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals: Context Locals .. admonition:: Insider Information If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it. Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand. Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking. So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the :meth:`~flask.Flask.test_request_context` context manager. In combination with the ``with`` statement it will bind a test request so that you can interact with it. Here is an example:: from flask import request with app.test_request_context('/hello', method='POST'): # now you can do something with the request until the # end of the with block, such as basic assertions: assert request.path == '/hello' assert request.method == 'POST' The other possibility is passing a whole WSGI environment to the :meth:`~flask.Flask.request_context` method:: from flask import request with app.request_context(environ): assert request.method == 'POST' The Request Object The request object is documented in the API section and we will not cover it here in detail (see :class: ~flask.Request ). Here is a broad overview of some of the most common operations. First of all you have to import it from the flask module:: from flask import request The current request method is available by using the :attr: ~flask.Request.method attribute. To access form data (data transmitted in a POST or PUT request) you can use the :attr: ~flask.Request.form attribute. Here is a full example of the two attributes mentioned above:: @app.route('/login', methods=['POST', 'GET']) def login(): error = None if request.method == 'POST': if valid_login(request.form['username'], request.form['password']): return log_the_user_in(request.form['username']) else: error = 'Invalid username/password' # the code below is executed if the request method # was GET or the credentials were invalid return render_template('login.html', error=error) What happens if the key does not exist in the form attribute? In that case a special :exc: KeyError is raised. You can catch it like a standard :exc: KeyError but if you don't do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don't have to deal with that problem. To access parameters submitted in the URL ( ?key=value ) you can use the :attr: ~flask.Request.args attribute:: searchword = request.args.get('key', '') We recommend accessing URL parameters with get or by catching the :exc: KeyError because users might change the URL and presenting them a 400 bad request page in that case is not user friendly. For a full list of methods and attributes of the request object, head over to the :class: ~flask.Request documentation. File Uploads You can handle uploaded files with Flask easily . Just make sure not to forget to set the `` enctype = \"multipart/form-data\" `` attribute on your HTML form , otherwise the browser will not transmit your files at all . Uploaded files are stored in memory or at a temporary location on the filesystem . You can access those files by looking at the : attr : `~flask.request.files` attribute on the request object . Each uploaded file is stored in that dictionary . It behaves just like a standard Python : class : `file` object , but it also has a : meth : `~werkzeug.datastructures.FileStorage.save` method that allows you to store that file on the filesystem of the server . Here is a simple example showing how that works :: from flask import request @app.route ( '/upload' , methods = [ 'GET' , 'POST' ]) def upload_file (): if request . method == 'POST' : f = request . files [ 'the_file' ] f . save ( '/var/www/uploads/uploaded_file.txt' ) ... If you want to know how the file was named on the client before it was uploaded to your application , you can access the : attr : `~werkzeug.datastructures.FileStorage.filename` attribute . However please keep in mind that this value can be forged so never ever trust that value . If you want to use the filename of the client to store the file on the server , pass it through the : func : `~werkzeug.utils.secure_filename` function that Werkzeug provides for you :: from flask import request from werkzeug.utils import secure_filename @app.route ( '/upload' , methods = [ 'GET' , 'POST' ]) def upload_file (): if request . method == 'POST' : f = request . files [ 'the_file' ] f . save ( '/var/www/uploads/' + secure_filename ( f . filename )) ... For some better examples , checkout the : ref : `uploading-files` pattern . Cookies `````` ` To access cookies you can use the : attr : `~flask.Request.cookies` attribute . To set cookies you can use the : attr : `~flask.Response.set_cookie` method of response objects . The : attr : `~flask.Request.cookies` attribute of request objects is a dictionary with all the cookies the client transmits . If you want to use sessions , do not use the cookies directly but instead use the : ref : `sessions` in Flask that add some security on top of cookies for you . Reading cookies :: from flask import request @app.route ( '/' ) def index (): username = request . cookies . get ( 'username' ) # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. Storing cookies :: from flask import make_response @app.route ( '/' ) def index (): resp = make_response ( render_template ( ... )) resp . set_cookie ( 'username' , 'the username' ) return resp Note that cookies are set on response objects . Since you normally just return strings from the view functions Flask will convert them into response objects for you . If you explicitly want to do that you can use the : meth : `~flask.make_response` function and then modify it . Sometimes you might want to set a cookie at a point where the response object does not exist yet . This is possible by utilizing the : ref : `deferred-callbacks` pattern . For this also see : ref : `about-responses` . Redirects and Errors -------------------- To redirect a user to another endpoint , use the : func : `~flask.redirect` function ; to abort a request early with an error code , use the : func : `~flask.abort` function :: from flask import abort , redirect , url_for @app.route ( '/' ) def index (): return redirect ( url_for ( 'login' )) @app.route ( '/login' ) def login (): abort ( 401 ) this_is_never_executed () This is a rather pointless example because a user will be redirected from the index to a page they cannot access ( 401 means access denied ) but it shows how that works . By default a black and white error page is shown for each error code . If you want to customize the error page , you can use the : meth : `~flask.Flask.errorhandler` decorator :: from flask import render_template @app.errorhandler ( 404 ) def page_not_found ( error ): return render_template ( 'page_not_found.html' ), 404 Note the `` 404 `` after the : func : `~flask.render_template` call . This tells Flask that the status code of that page should be 404 which means not found . By default 200 is assumed which translates to : all went well . See : ref : `error-handlers` for more details . .. _about - responses : About Responses --------------- The return value from a view function is automatically converted into a response object for you . If the return value is a string it 's converted into a response object with the string as response body , a `` 200 OK `` status code and a : mimetype : `text/html` mimetype . The logic that Flask applies to converting return values into response objects is as follows : 1. If a response object of the correct type is returned it 's directly returned from the view. 2. If it 's a string, a response object is created with that data and the default parameters . 3. If a tuple is returned the items in the tuple can provide extra information . Such tuples have to be in the form `` ( response , status , headers ) `` or `` ( response , headers ) `` where at least one item has to be in the tuple . The `` status `` value will override the status code and `` headers `` can be a list or dictionary of additional header values . 4. If none of that works , Flask will assume the return value is a valid WSGI application and convert that into a response object . If you want to get hold of the resulting response object inside the view you can use the : func : `~flask.make_response` function . Imagine you have a view like this :: @app.errorhandler ( 404 ) def not_found ( error ): return render_template ( 'error.html' ), 404 You just need to wrap the return expression with : func : `~flask.make_response` and get the response object to modify it , then return it :: @app.errorhandler ( 404 ) def not_found ( error ): resp = make_response ( render_template ( 'error.html' ), 404 ) resp . headers [ 'X-Something' ] = 'A value' return resp .. _sessions : Sessions -------- In addition to the request object there is also a second object called : class : `~flask.session` which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically . What this means is that the user could look at the contents of your cookie but not modify it , unless they know the secret key used for signing . In order to use sessions you have to set a secret key . Here is how sessions work :: from flask import Flask , session , redirect , url_for , escape , request app = Flask ( __name__ ) # Set the secret key to some random bytes. Keep this really secret! app . secret_key = b '_5#y2L\"F4Q8z \\n\\xec ]/' @app.route ( '/' ) def index (): if 'username' in session : return 'Logged in as %s ' % escape ( session [ 'username' ]) return 'You are not logged in' @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : session [ 'username' ] = request . form [ 'username' ] return redirect ( url_for ( 'index' )) return ''' <form method=\"post\"> <p><input type=text name=username> <p><input type=submit value=Login> </form> ''' @app.route ( '/logout' ) def logout (): # remove the username from the session if it's there session . pop ( 'username' , None ) return redirect ( url_for ( 'index' )) The : func : `~flask.escape` mentioned here does escaping for you if you are not using the template engine ( as in this example ) . .. admonition :: How to generate good secret keys A secret key should be as random as possible . Your operating system has ways to generate pretty random data based on a cryptographic random generator . Use the following command to quickly generate a value for : attr : `Flask.secret_key` ( or : data : `SECRET_KEY` ):: $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' A note on cookie - based sessions : Flask will take the values you put into the session object and serialize them into a cookie . If you are finding some values do not persist across requests , cookies are indeed enabled , and you are not getting a clear error message , check the size of the cookie in your page responses compared to the size supported by web browsers . Besides the default client - side based sessions , if you want to handle sessions on the server - side instead , there are several Flask extensions that support this . Message Flashing ---------------- Good applications and user interfaces are all about feedback . If the user does not get enough feedback they will probably end up hating the application . Flask provides a really simple way to give feedback to a user with the flashing system . The flashing system basically makes it possible to record a message at the end of a request and access it on the next ( and only the next ) request . This is usually combined with a layout template to expose the message . To flash a message use the : func : `~flask.flash` method , to get hold of the messages you can use : func : `~flask.get_flashed_messages` which is also available in the templates . Check out the : ref : `message-flashing-pattern` for a full example . Logging ------- .. versionadded :: 0.3 Sometimes you might be in a situation where you deal with data that should be correct , but actually is not . For example you may have some client - side code that sends an HTTP request to the server but it 's obviously malformed . This might be caused by a user tampering with the data , or the client code failing . Most of the time it 's okay to reply with ``400 Bad Request `` in that situation , but sometimes that won 't do and the code has to continue working . You may still want to log that something fishy happened . This is where loggers come in handy . As of Flask 0.3 a logger is preconfigured for you to use . Here are some example log calls :: app . logger . debug ( 'A value for debugging' ) app . logger . warning ( 'A warning occurred ( %d apples)' , 42 ) app . logger . error ( 'An error occurred' ) The attached : attr : `~flask.Flask.logger` is a standard logging : class : `~logging.Logger` , so head over to the official ` logging documentation < https : // docs . python . org / library / logging . html > ` _ for more information . Read more on : ref : `application-errors` . Hooking in WSGI Middlewares --------------------------- If you want to add a WSGI middleware to your application you can wrap the internal WSGI application . For example if you want to use one of the middlewares from the Werkzeug package to work around bugs in lighttpd , you can do it like this :: from werkzeug.contrib.fixers import LighttpdCGIRootFix app . wsgi_app = LighttpdCGIRootFix ( app . wsgi_app ) Using Flask Extensions ---------------------- Extensions are packages that help you accomplish common tasks . For example , Flask - SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask . For more on Flask extensions , have a look at : ref : `extensions` . Deploying to a Web Server ------------------------- Ready to deploy your new Flask app ? Go to : ref : `deployment` .","title":"Accessing Request Data"},{"location":"15.templating/","text":"Templates \u00b6 Flask leverages Jinja2 as template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present. This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine's syntax itself, head over to the official Jinja2 Template Documentation <http://jinja.pocoo.org/docs/templates> _ for more information. Jinja Setup \u00b6 Unless customized, Jinja2 is configured by Flask as follows: autoescaping is enabled for all templates ending in .html , .htm , .xml as well as .xhtml when using :func: ~flask.templating.render_template . autoescaping is enabled for all strings when using :func: ~flask.templating.render_template_string . a template has the ability to opt in/out autoescaping with the {% autoescape %} tag. Flask inserts a couple of global functions and helpers into the Jinja2 context, additionally to the values that are present by default. Standard Context \u00b6 The following global variables are available within Jinja2 templates by default: .. data:: config :noindex: The current configuration object (:data: flask.config ) .. versionadded:: 0.6 .. versionchanged:: 0.10 This is now always available, even in imported templates. .. data:: request :noindex: The current request object (:class: flask.request ). This variable is unavailable if the template was rendered without an active request context. .. data:: session :noindex: The current session object (:class: flask.session ). This variable is unavailable if the template was rendered without an active request context. .. data:: g :noindex: The request-bound object for global variables (:data: flask.g ). This variable is unavailable if the template was rendered without an active request context. .. function:: url_for :noindex: The :func: flask.url_for function. .. function:: get_flashed_messages :noindex: The :func: flask.get_flashed_messages function. .. admonition:: The Jinja Context Behavior These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit. What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities: you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in. you import the macro \"with context\". Importing with context looks like this: .. sourcecode:: jinja { % from '_helpers.html' import my_macro with context % } Standard Filters \u00b6 These filters are available in Jinja2 additionally to the filters provided by Jinja2 itself: .. function:: tojson :noindex: This function converts the given object into JSON representation. This is for example very helpful if you try to generate JavaScript on the fly. .. sourcecode:: html+jinja &lt;script type=text/javascript&gt; doSomethingWith( {{ user.username | tojson }} ); &lt;/script&gt; It is also safe to use the output of |tojson in a single-quoted HTML attribute: .. sourcecode:: html+jinja &lt;button onclick='doSomethingWith( {{ user.username | tojson }} )'&gt; Click me &lt;/button&gt; Note that in versions of Flask prior to 0.10, if using the output of |tojson inside script , make sure to disable escaping with |safe . In Flask 0.10 and above, this happens automatically. Controlling Autoescaping \u00b6 Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are & , > , < , \" as well as ' . Because these characters carry specific meanings in documents on their own you have to replace them by so called \"entities\" if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see :ref: xss ) Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter. There are three ways to accomplish that: In the Python code, wrap the HTML string in a :class: ~flask.Markup object before passing it to the template. This is in general the recommended way. Inside the template, use the |safe filter to explicitly mark a string as safe HTML ( {{ myvariable|safe }} ) Temporarily disable the autoescape system altogether. To disable the autoescape system in templates, you can use the {% autoescape %} block: .. sourcecode:: html+jinja {% autoescape false %} &lt;p&gt;autoescaping is disabled here &lt;p&gt; {{ will_not_be_escaped }} {% endautoescape %} Whenever you do this, please be very cautious about the variables you are using in this block. Registering Filters \u00b6 If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the :attr: ~flask.Flask.jinja_env of the application or use the :meth: ~flask.Flask.template_filter decorator. The two following examples work the same and both reverse an object:: @app . template_filter ( 'reverse' ) def reverse_filter ( s ) : return s [ ::- 1 ] def reverse_filter ( s ) : return s [ ::- 1 ] app . jinja_env . filters [ 'reverse' ] = reverse_filter In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2's builtin filters, for example if you have a Python list in context called mylist :: {% for x in mylist | reverse %} {% endfor %} Context Processors \u00b6 To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:: @app.context_processor def inject_user(): return dict(user=g.user) The context processor above makes a variable called user available in the template with the value of g.user . This example is not very interesting because g is available in templates anyways, but it gives an idea how this works. Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):: @app.context_processor def utility_processor(): def format_price(amount, currency=u'\u20ac'): return u'{0:.2f}{1}'.format(amount, currency) return dict(format_price=format_price) The context processor above makes the format_price function available to all templates:: {{ format_price ( 0.33 ) }} You could also build format_price as a template filter (see :ref: registering-filters ), but this demonstrates how to pass functions in a context processor.","title":"Templates"},{"location":"15.templating/#templates","text":"Flask leverages Jinja2 as template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present. This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine's syntax itself, head over to the official Jinja2 Template Documentation <http://jinja.pocoo.org/docs/templates> _ for more information.","title":"Templates"},{"location":"15.templating/#jinja-setup","text":"Unless customized, Jinja2 is configured by Flask as follows: autoescaping is enabled for all templates ending in .html , .htm , .xml as well as .xhtml when using :func: ~flask.templating.render_template . autoescaping is enabled for all strings when using :func: ~flask.templating.render_template_string . a template has the ability to opt in/out autoescaping with the {% autoescape %} tag. Flask inserts a couple of global functions and helpers into the Jinja2 context, additionally to the values that are present by default.","title":"Jinja Setup"},{"location":"15.templating/#standard-context","text":"The following global variables are available within Jinja2 templates by default: .. data:: config :noindex: The current configuration object (:data: flask.config ) .. versionadded:: 0.6 .. versionchanged:: 0.10 This is now always available, even in imported templates. .. data:: request :noindex: The current request object (:class: flask.request ). This variable is unavailable if the template was rendered without an active request context. .. data:: session :noindex: The current session object (:class: flask.session ). This variable is unavailable if the template was rendered without an active request context. .. data:: g :noindex: The request-bound object for global variables (:data: flask.g ). This variable is unavailable if the template was rendered without an active request context. .. function:: url_for :noindex: The :func: flask.url_for function. .. function:: get_flashed_messages :noindex: The :func: flask.get_flashed_messages function. .. admonition:: The Jinja Context Behavior These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit. What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities: you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in. you import the macro \"with context\". Importing with context looks like this: .. sourcecode:: jinja { % from '_helpers.html' import my_macro with context % }","title":"Standard Context"},{"location":"15.templating/#standard-filters","text":"These filters are available in Jinja2 additionally to the filters provided by Jinja2 itself: .. function:: tojson :noindex: This function converts the given object into JSON representation. This is for example very helpful if you try to generate JavaScript on the fly. .. sourcecode:: html+jinja &lt;script type=text/javascript&gt; doSomethingWith( {{ user.username | tojson }} ); &lt;/script&gt; It is also safe to use the output of |tojson in a single-quoted HTML attribute: .. sourcecode:: html+jinja &lt;button onclick='doSomethingWith( {{ user.username | tojson }} )'&gt; Click me &lt;/button&gt; Note that in versions of Flask prior to 0.10, if using the output of |tojson inside script , make sure to disable escaping with |safe . In Flask 0.10 and above, this happens automatically.","title":"Standard Filters"},{"location":"15.templating/#controlling-autoescaping","text":"Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are & , > , < , \" as well as ' . Because these characters carry specific meanings in documents on their own you have to replace them by so called \"entities\" if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see :ref: xss ) Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter. There are three ways to accomplish that: In the Python code, wrap the HTML string in a :class: ~flask.Markup object before passing it to the template. This is in general the recommended way. Inside the template, use the |safe filter to explicitly mark a string as safe HTML ( {{ myvariable|safe }} ) Temporarily disable the autoescape system altogether. To disable the autoescape system in templates, you can use the {% autoescape %} block: .. sourcecode:: html+jinja {% autoescape false %} &lt;p&gt;autoescaping is disabled here &lt;p&gt; {{ will_not_be_escaped }} {% endautoescape %} Whenever you do this, please be very cautious about the variables you are using in this block.","title":"Controlling Autoescaping"},{"location":"15.templating/#registering-filters","text":"If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the :attr: ~flask.Flask.jinja_env of the application or use the :meth: ~flask.Flask.template_filter decorator. The two following examples work the same and both reverse an object:: @app . template_filter ( 'reverse' ) def reverse_filter ( s ) : return s [ ::- 1 ] def reverse_filter ( s ) : return s [ ::- 1 ] app . jinja_env . filters [ 'reverse' ] = reverse_filter In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2's builtin filters, for example if you have a Python list in context called mylist :: {% for x in mylist | reverse %} {% endfor %}","title":"Registering Filters"},{"location":"15.templating/#context-processors","text":"To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:: @app.context_processor def inject_user(): return dict(user=g.user) The context processor above makes a variable called user available in the template with the value of g.user . This example is not very interesting because g is available in templates anyways, but it gives an idea how this works. Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):: @app.context_processor def utility_processor(): def format_price(amount, currency=u'\u20ac'): return u'{0:.2f}{1}'.format(amount, currency) return dict(format_price=format_price) The context processor above makes the format_price function available to all templates:: {{ format_price ( 0.33 ) }} You could also build format_price as a template filter (see :ref: registering-filters ), but this demonstrates how to pass functions in a context processor.","title":"Context Processors"},{"location":"api/","text":"API \u00b6 .. module:: flask This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation. Application Object \u00b6 .. autoclass:: Flask :members: :inherited-members: Blueprint Objects \u00b6 .. autoclass:: Blueprint :members: :inherited-members: Incoming Request Data \u00b6 .. autoclass:: Request :members: :inherited-members: .. attribute:: environ The underlying WSGI environment. .. attribute:: path .. attribute:: full_path .. attribute:: script_root .. attribute:: url .. attribute:: base_url .. attribute:: url_root Provides different ways to look at the current ` IRI & lt ; https :// tools . ietf . org / html / rfc3987 & gt ; ` _ . Imagine your application is listening on the following application root :: http :// www . example . com / myapplication And a user requests the following URI :: http :// www . example . com / myapplication /% CF % 80 / page . html ? x = y In this case the values of the above mentioned attributes would be the following : ============= ====================================================== ` path ` `` u '/\u03c0/page.html' `` ` full_path ` `` u '/\u03c0/page.html?x=y' `` ` script_root ` `` u '/myapplication' `` ` base_url ` `` u 'http://www.example.com/myapplication/\u03c0/page.html' `` ` url ` `` u 'http://www.example.com/myapplication/\u03c0/page.html?x=y' `` ` url_root ` `` u 'http://www.example.com/myapplication/' `` ============= ====================================================== .. attribute:: request To access incoming request data, you can use the global request object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment. This is a proxy. See :ref: notes-on-proxies for more information. The request object is an instance of a :class: ~werkzeug.wrappers.Request subclass and provides all of the attributes Werkzeug defines. This just shows a quick overview of the most important ones. Response Objects \u00b6 .. autoclass:: flask.Response :members: set_cookie, max_cookie_size, data, mimetype, is_json, get_json .. attribute:: headers A :class:`~werkzeug.datastructures.Headers` object representing the response headers. .. attribute:: status A string with a response status. .. attribute:: status_code The response status as integer. Sessions \u00b6 If you have set :attr: Flask.secret_key (or configured it from :data: SECRET_KEY ) you can use sessions in Flask applications. A session makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. The user can look at the session contents, but can't modify it unless they know the secret key, so make sure to set that to something complex and unguessable. To access the current session you can use the :class: session object: .. class:: session The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications. This is a proxy. See :ref: notes-on-proxies for more information. The following attributes are interesting: .. attribute:: new ``True`` if the session is new, ``False`` otherwise. .. attribute:: modified ``True`` if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to ``True`` yourself. Here an example:: # this change is not picked up because a mutable object (here # a list) is changed. session['objects'].append(42) # so mark it as modified yourself session.modified = True .. attribute:: permanent If set to ``True`` the session lives for :attr:`~flask.Flask.permanent_session_lifetime` seconds. The default is 31 days. If set to ``False`` (which is the default) the session will be deleted when the user closes the browser. Session Interface \u00b6 .. versionadded:: 0.8 The session interface provides a simple way to replace the session implementation that Flask is using. .. currentmodule:: flask.sessions .. autoclass:: SessionInterface :members: .. autoclass:: SecureCookieSessionInterface :members: .. autoclass:: SecureCookieSession :members: .. autoclass:: NullSession :members: .. autoclass:: SessionMixin :members: .. admonition:: Notice The PERMANENT_SESSION_LIFETIME config key can also be an integer starting with Flask 0.8. Either catch this down yourself or use the :attr: ~flask.Flask.permanent_session_lifetime attribute on the app which converts the result to an integer automatically. Test Client \u00b6 .. currentmodule:: flask.testing .. autoclass:: FlaskClient :members: Test CLI Runner \u00b6 .. currentmodule:: flask.testing .. autoclass:: FlaskCliRunner :members: Application Globals \u00b6 .. currentmodule:: flask To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for :class: request and :class: session . .. data:: g A namespace object that can store data during an : doc : ` application context & lt ;/ appcontext & gt ; ` . This is an instance of : attr : ` Flask . app_ctx_globals_class ` , which defaults to : class : ` ctx . _AppCtxGlobals ` . This is a good place to store resources during a request . During testing , you can use the : ref : ` faking-resources ` pattern to pre-configure such resources . This is a proxy . See : ref : ` notes-on-proxies ` for more information . .. versionchanged :: 0 . 10 Bound to the application context instead of the request context . .. autoclass:: flask.ctx._AppCtxGlobals :members: Useful Functions and Classes \u00b6 .. data:: current_app A proxy to the application handling the current request . This is useful to access the application without needing to import it , or if it can 't be imported, such as when using the application factory pattern or in blueprints and extensions . This is only available when an : doc : `application context &lt;/appcontext&gt;` is pushed . This happens automatically during requests and CLI commands . It can be controlled manually with : meth : `~flask.Flask.app_context` . This is a proxy . See : ref : `notes-on-proxies` for more information . .. autofunction:: has_request_context .. autofunction:: copy_current_request_context .. autofunction:: has_app_context .. autofunction:: url_for .. autofunction:: abort .. autofunction:: redirect .. autofunction:: make_response .. autofunction:: after_this_request .. autofunction:: send_file .. autofunction:: send_from_directory .. autofunction:: safe_join .. autofunction:: escape .. autoclass:: Markup :members: escape, unescape, striptags Message Flashing \u00b6 .. autofunction:: flash .. autofunction:: get_flashed_messages JSON Support \u00b6 .. module:: flask.json Flask uses simplejson for the JSON implementation. Since simplejson is provided by both the standard library as well as extension, Flask will try simplejson first and then fall back to the stdlib json module. On top of that it will delegate access to the current application's JSON encoders and decoders for easier customization. So for starters instead of doing:: try : import simplejson as json except ImportError : import json You can instead just do this:: from flask import json For usage examples, read the :mod: json documentation in the standard library. The following extensions are by default applied to the stdlib's JSON module: datetime objects are serialized as :rfc: 822 strings. Any object with an __html__ method (like :class: ~flask.Markup ) will have that method called and then the return value is serialized as string. The :func: ~htmlsafe_dumps function of this json module is also available as a filter called |tojson in Jinja2. Note that in versions of Flask prior to Flask 0.10, you must disable escaping with |safe if you intend to use |tojson output inside script tags. In Flask 0.10 and above, this happens automatically (but it's harmless to include |safe anyway). .. sourcecode:: html+jinja &lt;script type=text/javascript&gt; doSomethingWith( {{ user.username | tojson | safe }} ); &lt;/script&gt; .. admonition:: Auto-Sort JSON Keys The configuration variable ``JSON_SORT_KEYS`` (:ref:`config`) can be set to false to stop Flask from auto-sorting keys. By default sorting is enabled and outside of the app context sorting is turned on. Notice that disabling key sorting can cause issues when using content based HTTP caches and Python's hash randomization feature. .. autofunction:: jsonify .. autofunction:: dumps .. autofunction:: dump .. autofunction:: loads .. autofunction:: load .. autoclass:: JSONEncoder :members: .. autoclass:: JSONDecoder :members: .. automodule:: flask.json.tag Template Rendering \u00b6 .. currentmodule:: flask .. autofunction:: render_template .. autofunction:: render_template_string .. autofunction:: get_template_attribute Configuration \u00b6 .. autoclass:: Config :members: Stream Helpers \u00b6 .. autofunction:: stream_with_context Useful Internals \u00b6 .. autoclass:: flask.ctx.RequestContext :members: .. data:: _request_ctx_stack The internal : class : `~werkzeug.local.LocalStack` that holds : class : `~flask.ctx.RequestContext` instances . Typically , the : data : `request` and : data : `session` proxies should be accessed instead of the stack . It may be useful to access the stack in extension code . The following attributes are always present on each layer of the stack : `app` the active Flask application . `url_adapter` the URL adapter that was used to match the request . `request` the current request object . `session` the active session object . `g` an object with all the attributes of the : data : `flask.g` object . `flashes` an internal cache for the flashed messages . Example usage :: from flask import _request_ctx_stack def get_session (): ctx = _request_ctx_stack . top if ctx is not None : return ctx . session .. autoclass:: flask.ctx.AppContext :members: .. data:: _app_ctx_stack The internal :class:`~werkzeug.local.LocalStack` that holds :class:`~flask.ctx.AppContext` instances. Typically, the :data:`current_app` and :data:`g` proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data. .. versionadded:: 0.9 .. autoclass:: flask.blueprints.BlueprintSetupState :members: Signals \u00b6 .. versionadded:: 0.6 .. data:: signals.signals_available True if the signaling system is available. This is the case when blinker _ is installed. The following signals exist in Flask: .. data:: template_rendered This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as template and the context as dictionary (named context ). Example subscriber:: def log_template_renders ( sender , template , context , ** extra ): sender . logger . debug ( 'Rendering template \" %s \" with context %s ' , template . name or 'string template' , context ) from flask import template_rendered template_rendered . connect ( log_template_renders , app ) .. data:: flask.before_render_template :noindex: This signal is sent before template rendering process. The signal is invoked with the instance of the template as template and the context as dictionary (named context ). Example subscriber:: def log_template_renders ( sender , template , context , ** extra ): sender . logger . debug ( 'Rendering template \" %s \" with context %s ' , template . name or 'string template' , context ) from flask import before_render_template before_render_template . connect ( log_template_renders , app ) .. data:: request_started This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as :class: ~flask.request . Example subscriber:: def log_request ( sender , ** extra ): sender . logger . debug ( 'Request context is set up' ) from flask import request_started request_started . connect ( log_request , app ) .. data:: request_finished This signal is sent right before the response is sent to the client. It is passed the response to be sent named response . Example subscriber:: def log_response ( sender , response , ** extra ): sender . logger . debug ( 'Request context is about to close down. ' 'Response: %s ' , response ) from flask import request_finished request_finished . connect ( log_response , app ) .. data:: got_request_exception This signal is sent when an exception happens during request processing. It is sent before the standard exception handling kicks in and even in debug mode, where no exception handling happens. The exception itself is passed to the subscriber as exception . Example subscriber:: def log_exception ( sender , exception , ** extra ): sender . logger . debug ( 'Got exception during processing: %s ' , exception ) from flask import got_request_exception got_request_exception . connect ( log_exception , app ) .. data:: request_tearing_down This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber:: def close_db_connection ( sender , ** extra ): session . close () from flask import request_tearing_down request_tearing_down . connect ( close_db_connection , app ) As of Flask 0.9, this will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. .. data:: appcontext_tearing_down This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber:: def close_db_connection ( sender , ** extra ): session . close () from flask import appcontext_tearing_down appcontext_tearing_down . connect ( close_db_connection , app ) This will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. .. data:: appcontext_pushed This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the g object. Example usage:: from contextlib import contextmanager from flask import appcontext_pushed @contextmanager def user_set ( app , user ): def handler ( sender , ** kwargs ): g . user = user with appcontext_pushed . connected_to ( handler , app ): yield And in the testcode:: def test_user_me(self): with user_set(app, 'john'): c = app.test_client() resp = c.get('/users/me') assert resp.data == 'username=john' .. versionadded:: 0.10 .. data:: appcontext_popped This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the :data: appcontext_tearing_down signal. .. versionadded:: 0.10 .. data:: message_flashed This signal is sent when the application is flashing a message. The messages is sent as message keyword argument and the category as category . Example subscriber:: recorded = [] def record ( sender , message , category , ** extra ): recorded . append (( message , category )) from flask import message_flashed message_flashed . connect ( record , app ) .. versionadded:: 0.10 .. class:: signals.Namespace An alias for :class: blinker.base.Namespace if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself. .. method:: signal(name, doc=None) Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a :exc:`RuntimeError` for all other operations, including connecting. .. _blinker: https://pypi.org/project/blinker/ Class-Based Views \u00b6 .. versionadded:: 0.7 .. currentmodule:: None .. autoclass:: flask.views.View :members: .. autoclass:: flask.views.MethodView :members: URL Route Registrations \u00b6 Generally there are three ways to define rules for the routing system: You can use the :meth: flask.Flask.route decorator. You can use the :meth: flask.Flask.add_url_rule function. You can directly access the underlying Werkzeug routing system which is exposed as :attr: flask.Flask.url_map . Variable parts in the route can be specified with angular brackets ( /user/<username> ). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using <converter:name> . Variable parts are passed to the view function as keyword arguments. The following converters are available: =========== =============================================== string accepts any text without a slash (the default) int accepts integers float like int but for floating point values path like the default but also accepts slashes any matches one of the items provided uuid accepts UUID strings =========== =============================================== Custom converters can be defined using :attr: flask.Flask.url_map . Here are some examples:: @ app . route ( '/' ) def index (): pass @ app . route ( '/&lt;username&gt;' ) def show_user ( username ): pass @ app . route ( '/post/&lt;int:post_id&gt;' ) def show_post ( post_id ): pass An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply: If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached. If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised. This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely. You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:: @ app . route ( '/users/' , defaults = { 'page' : 1 } ) @ app . route ( '/users/page/&lt;int:page&gt;' ) def show_users ( page ): pass This specifies that /users/ will be the URL for page one and /users/page/N will be the URL for page N . If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, /users/page/1 will be redirected to /users/ . If your route handles GET and POST requests, make sure the default route only handles GET , as redirects can't preserve form data. :: @app.route('/region/', defaults={'id': 1}) @app.route('/region/ ', methods=['GET', 'POST']) def region(id): pass Here are the parameters that :meth: ~flask.Flask.route and :meth: ~flask.Flask.add_url_rule accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the view_func parameter. =============== ========================================================== rule the URL rule as string endpoint the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated. view_func the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the :attr: ~flask.Flask.view_functions dictionary with the endpoint as key. defaults A dictionary with defaults for this rule. See the example above for how defaults work. subdomain specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed. **options the options to be forwarded to the underlying :class: ~werkzeug.routing.Rule object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to ( GET , POST etc.). By default a rule just listens for GET (and implicitly HEAD ). Starting with Flask 0.6, OPTIONS is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments. =============== ========================================================== View Function Options \u00b6 For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to :meth: ~flask.Flask.add_url_rule or general behavior: __name__ : The name of a function is by default used as endpoint. If endpoint is provided explicitly this value is used. Additionally this will be prefixed with the name of the blueprint by default which cannot be customized from the function itself. methods : If methods are not provided when the URL rule is added, Flask will look on the view function object itself if a methods attribute exists. If it does, it will pull the information for the methods from there. provide_automatic_options : if this attribute is set Flask will either force enable or disable the automatic implementation of the HTTP OPTIONS response. This can be useful when working with decorators that want to customize the OPTIONS response on a per-view basis. required_methods : if this attribute is set, Flask will always add these methods when registering a URL rule even if the methods were explicitly overridden in the route() call. Full example:: def index(): if request.method == 'OPTIONS': # custom options handling here ... return 'Hello World!' index.provide_automatic_options = False index.methods = ['GET', 'OPTIONS'] app.add_url_rule('/', index) .. versionadded:: 0.8 The provide_automatic_options functionality was added. Command Line Interface \u00b6 .. currentmodule:: flask.cli .. autoclass:: FlaskGroup :members: .. autoclass:: AppGroup :members: .. autoclass:: ScriptInfo :members: .. autofunction:: load_dotenv .. autofunction:: with_appcontext .. autofunction:: pass_script_info Marks a function so that an instance of :class: ScriptInfo is passed as first argument to the click callback. .. autodata:: run_command .. autodata:: shell_command","title":"API"},{"location":"api/#api","text":".. module:: flask This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.","title":"API"},{"location":"api/#application-object","text":".. autoclass:: Flask :members: :inherited-members:","title":"Application Object"},{"location":"api/#blueprint-objects","text":".. autoclass:: Blueprint :members: :inherited-members:","title":"Blueprint Objects"},{"location":"api/#incoming-request-data","text":".. autoclass:: Request :members: :inherited-members: .. attribute:: environ The underlying WSGI environment. .. attribute:: path .. attribute:: full_path .. attribute:: script_root .. attribute:: url .. attribute:: base_url .. attribute:: url_root Provides different ways to look at the current ` IRI & lt ; https :// tools . ietf . org / html / rfc3987 & gt ; ` _ . Imagine your application is listening on the following application root :: http :// www . example . com / myapplication And a user requests the following URI :: http :// www . example . com / myapplication /% CF % 80 / page . html ? x = y In this case the values of the above mentioned attributes would be the following : ============= ====================================================== ` path ` `` u '/\u03c0/page.html' `` ` full_path ` `` u '/\u03c0/page.html?x=y' `` ` script_root ` `` u '/myapplication' `` ` base_url ` `` u 'http://www.example.com/myapplication/\u03c0/page.html' `` ` url ` `` u 'http://www.example.com/myapplication/\u03c0/page.html?x=y' `` ` url_root ` `` u 'http://www.example.com/myapplication/' `` ============= ====================================================== .. attribute:: request To access incoming request data, you can use the global request object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment. This is a proxy. See :ref: notes-on-proxies for more information. The request object is an instance of a :class: ~werkzeug.wrappers.Request subclass and provides all of the attributes Werkzeug defines. This just shows a quick overview of the most important ones.","title":"Incoming Request Data"},{"location":"api/#response-objects","text":".. autoclass:: flask.Response :members: set_cookie, max_cookie_size, data, mimetype, is_json, get_json .. attribute:: headers A :class:`~werkzeug.datastructures.Headers` object representing the response headers. .. attribute:: status A string with a response status. .. attribute:: status_code The response status as integer.","title":"Response Objects"},{"location":"api/#sessions","text":"If you have set :attr: Flask.secret_key (or configured it from :data: SECRET_KEY ) you can use sessions in Flask applications. A session makes it possible to remember information from one request to another. The way Flask does this is by using a signed cookie. The user can look at the session contents, but can't modify it unless they know the secret key, so make sure to set that to something complex and unguessable. To access the current session you can use the :class: session object: .. class:: session The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications. This is a proxy. See :ref: notes-on-proxies for more information. The following attributes are interesting: .. attribute:: new ``True`` if the session is new, ``False`` otherwise. .. attribute:: modified ``True`` if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to ``True`` yourself. Here an example:: # this change is not picked up because a mutable object (here # a list) is changed. session['objects'].append(42) # so mark it as modified yourself session.modified = True .. attribute:: permanent If set to ``True`` the session lives for :attr:`~flask.Flask.permanent_session_lifetime` seconds. The default is 31 days. If set to ``False`` (which is the default) the session will be deleted when the user closes the browser.","title":"Sessions"},{"location":"api/#session-interface","text":".. versionadded:: 0.8 The session interface provides a simple way to replace the session implementation that Flask is using. .. currentmodule:: flask.sessions .. autoclass:: SessionInterface :members: .. autoclass:: SecureCookieSessionInterface :members: .. autoclass:: SecureCookieSession :members: .. autoclass:: NullSession :members: .. autoclass:: SessionMixin :members: .. admonition:: Notice The PERMANENT_SESSION_LIFETIME config key can also be an integer starting with Flask 0.8. Either catch this down yourself or use the :attr: ~flask.Flask.permanent_session_lifetime attribute on the app which converts the result to an integer automatically.","title":"Session Interface"},{"location":"api/#test-client","text":".. currentmodule:: flask.testing .. autoclass:: FlaskClient :members:","title":"Test Client"},{"location":"api/#test-cli-runner","text":".. currentmodule:: flask.testing .. autoclass:: FlaskCliRunner :members:","title":"Test CLI Runner"},{"location":"api/#application-globals","text":".. currentmodule:: flask To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for :class: request and :class: session . .. data:: g A namespace object that can store data during an : doc : ` application context & lt ;/ appcontext & gt ; ` . This is an instance of : attr : ` Flask . app_ctx_globals_class ` , which defaults to : class : ` ctx . _AppCtxGlobals ` . This is a good place to store resources during a request . During testing , you can use the : ref : ` faking-resources ` pattern to pre-configure such resources . This is a proxy . See : ref : ` notes-on-proxies ` for more information . .. versionchanged :: 0 . 10 Bound to the application context instead of the request context . .. autoclass:: flask.ctx._AppCtxGlobals :members:","title":"Application Globals"},{"location":"api/#useful-functions-and-classes","text":".. data:: current_app A proxy to the application handling the current request . This is useful to access the application without needing to import it , or if it can 't be imported, such as when using the application factory pattern or in blueprints and extensions . This is only available when an : doc : `application context &lt;/appcontext&gt;` is pushed . This happens automatically during requests and CLI commands . It can be controlled manually with : meth : `~flask.Flask.app_context` . This is a proxy . See : ref : `notes-on-proxies` for more information . .. autofunction:: has_request_context .. autofunction:: copy_current_request_context .. autofunction:: has_app_context .. autofunction:: url_for .. autofunction:: abort .. autofunction:: redirect .. autofunction:: make_response .. autofunction:: after_this_request .. autofunction:: send_file .. autofunction:: send_from_directory .. autofunction:: safe_join .. autofunction:: escape .. autoclass:: Markup :members: escape, unescape, striptags","title":"Useful Functions and Classes"},{"location":"api/#message-flashing","text":".. autofunction:: flash .. autofunction:: get_flashed_messages","title":"Message Flashing"},{"location":"api/#json-support","text":".. module:: flask.json Flask uses simplejson for the JSON implementation. Since simplejson is provided by both the standard library as well as extension, Flask will try simplejson first and then fall back to the stdlib json module. On top of that it will delegate access to the current application's JSON encoders and decoders for easier customization. So for starters instead of doing:: try : import simplejson as json except ImportError : import json You can instead just do this:: from flask import json For usage examples, read the :mod: json documentation in the standard library. The following extensions are by default applied to the stdlib's JSON module: datetime objects are serialized as :rfc: 822 strings. Any object with an __html__ method (like :class: ~flask.Markup ) will have that method called and then the return value is serialized as string. The :func: ~htmlsafe_dumps function of this json module is also available as a filter called |tojson in Jinja2. Note that in versions of Flask prior to Flask 0.10, you must disable escaping with |safe if you intend to use |tojson output inside script tags. In Flask 0.10 and above, this happens automatically (but it's harmless to include |safe anyway). .. sourcecode:: html+jinja &lt;script type=text/javascript&gt; doSomethingWith( {{ user.username | tojson | safe }} ); &lt;/script&gt; .. admonition:: Auto-Sort JSON Keys The configuration variable ``JSON_SORT_KEYS`` (:ref:`config`) can be set to false to stop Flask from auto-sorting keys. By default sorting is enabled and outside of the app context sorting is turned on. Notice that disabling key sorting can cause issues when using content based HTTP caches and Python's hash randomization feature. .. autofunction:: jsonify .. autofunction:: dumps .. autofunction:: dump .. autofunction:: loads .. autofunction:: load .. autoclass:: JSONEncoder :members: .. autoclass:: JSONDecoder :members: .. automodule:: flask.json.tag","title":"JSON Support"},{"location":"api/#template-rendering","text":".. currentmodule:: flask .. autofunction:: render_template .. autofunction:: render_template_string .. autofunction:: get_template_attribute","title":"Template Rendering"},{"location":"api/#configuration","text":".. autoclass:: Config :members:","title":"Configuration"},{"location":"api/#stream-helpers","text":".. autofunction:: stream_with_context","title":"Stream Helpers"},{"location":"api/#useful-internals","text":".. autoclass:: flask.ctx.RequestContext :members: .. data:: _request_ctx_stack The internal : class : `~werkzeug.local.LocalStack` that holds : class : `~flask.ctx.RequestContext` instances . Typically , the : data : `request` and : data : `session` proxies should be accessed instead of the stack . It may be useful to access the stack in extension code . The following attributes are always present on each layer of the stack : `app` the active Flask application . `url_adapter` the URL adapter that was used to match the request . `request` the current request object . `session` the active session object . `g` an object with all the attributes of the : data : `flask.g` object . `flashes` an internal cache for the flashed messages . Example usage :: from flask import _request_ctx_stack def get_session (): ctx = _request_ctx_stack . top if ctx is not None : return ctx . session .. autoclass:: flask.ctx.AppContext :members: .. data:: _app_ctx_stack The internal :class:`~werkzeug.local.LocalStack` that holds :class:`~flask.ctx.AppContext` instances. Typically, the :data:`current_app` and :data:`g` proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data. .. versionadded:: 0.9 .. autoclass:: flask.blueprints.BlueprintSetupState :members:","title":"Useful Internals"},{"location":"api/#signals","text":".. versionadded:: 0.6 .. data:: signals.signals_available True if the signaling system is available. This is the case when blinker _ is installed. The following signals exist in Flask: .. data:: template_rendered This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as template and the context as dictionary (named context ). Example subscriber:: def log_template_renders ( sender , template , context , ** extra ): sender . logger . debug ( 'Rendering template \" %s \" with context %s ' , template . name or 'string template' , context ) from flask import template_rendered template_rendered . connect ( log_template_renders , app ) .. data:: flask.before_render_template :noindex: This signal is sent before template rendering process. The signal is invoked with the instance of the template as template and the context as dictionary (named context ). Example subscriber:: def log_template_renders ( sender , template , context , ** extra ): sender . logger . debug ( 'Rendering template \" %s \" with context %s ' , template . name or 'string template' , context ) from flask import before_render_template before_render_template . connect ( log_template_renders , app ) .. data:: request_started This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as :class: ~flask.request . Example subscriber:: def log_request ( sender , ** extra ): sender . logger . debug ( 'Request context is set up' ) from flask import request_started request_started . connect ( log_request , app ) .. data:: request_finished This signal is sent right before the response is sent to the client. It is passed the response to be sent named response . Example subscriber:: def log_response ( sender , response , ** extra ): sender . logger . debug ( 'Request context is about to close down. ' 'Response: %s ' , response ) from flask import request_finished request_finished . connect ( log_response , app ) .. data:: got_request_exception This signal is sent when an exception happens during request processing. It is sent before the standard exception handling kicks in and even in debug mode, where no exception handling happens. The exception itself is passed to the subscriber as exception . Example subscriber:: def log_exception ( sender , exception , ** extra ): sender . logger . debug ( 'Got exception during processing: %s ' , exception ) from flask import got_request_exception got_request_exception . connect ( log_exception , app ) .. data:: request_tearing_down This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber:: def close_db_connection ( sender , ** extra ): session . close () from flask import request_tearing_down request_tearing_down . connect ( close_db_connection , app ) As of Flask 0.9, this will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. .. data:: appcontext_tearing_down This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber:: def close_db_connection ( sender , ** extra ): session . close () from flask import appcontext_tearing_down appcontext_tearing_down . connect ( close_db_connection , app ) This will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. .. data:: appcontext_pushed This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the g object. Example usage:: from contextlib import contextmanager from flask import appcontext_pushed @contextmanager def user_set ( app , user ): def handler ( sender , ** kwargs ): g . user = user with appcontext_pushed . connected_to ( handler , app ): yield And in the testcode:: def test_user_me(self): with user_set(app, 'john'): c = app.test_client() resp = c.get('/users/me') assert resp.data == 'username=john' .. versionadded:: 0.10 .. data:: appcontext_popped This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the :data: appcontext_tearing_down signal. .. versionadded:: 0.10 .. data:: message_flashed This signal is sent when the application is flashing a message. The messages is sent as message keyword argument and the category as category . Example subscriber:: recorded = [] def record ( sender , message , category , ** extra ): recorded . append (( message , category )) from flask import message_flashed message_flashed . connect ( record , app ) .. versionadded:: 0.10 .. class:: signals.Namespace An alias for :class: blinker.base.Namespace if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself. .. method:: signal(name, doc=None) Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a :exc:`RuntimeError` for all other operations, including connecting. .. _blinker: https://pypi.org/project/blinker/","title":"Signals"},{"location":"api/#class-based-views","text":".. versionadded:: 0.7 .. currentmodule:: None .. autoclass:: flask.views.View :members: .. autoclass:: flask.views.MethodView :members:","title":"Class-Based Views"},{"location":"api/#url-route-registrations","text":"Generally there are three ways to define rules for the routing system: You can use the :meth: flask.Flask.route decorator. You can use the :meth: flask.Flask.add_url_rule function. You can directly access the underlying Werkzeug routing system which is exposed as :attr: flask.Flask.url_map . Variable parts in the route can be specified with angular brackets ( /user/<username> ). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using <converter:name> . Variable parts are passed to the view function as keyword arguments. The following converters are available: =========== =============================================== string accepts any text without a slash (the default) int accepts integers float like int but for floating point values path like the default but also accepts slashes any matches one of the items provided uuid accepts UUID strings =========== =============================================== Custom converters can be defined using :attr: flask.Flask.url_map . Here are some examples:: @ app . route ( '/' ) def index (): pass @ app . route ( '/&lt;username&gt;' ) def show_user ( username ): pass @ app . route ( '/post/&lt;int:post_id&gt;' ) def show_post ( post_id ): pass An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply: If a rule ends with a slash and is requested without a slash by the user, the user is automatically redirected to the same page with a trailing slash attached. If a rule does not end with a trailing slash and the user requests the page with a trailing slash, a 404 not found is raised. This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely. You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:: @ app . route ( '/users/' , defaults = { 'page' : 1 } ) @ app . route ( '/users/page/&lt;int:page&gt;' ) def show_users ( page ): pass This specifies that /users/ will be the URL for page one and /users/page/N will be the URL for page N . If a URL contains a default value, it will be redirected to its simpler form with a 301 redirect. In the above example, /users/page/1 will be redirected to /users/ . If your route handles GET and POST requests, make sure the default route only handles GET , as redirects can't preserve form data. :: @app.route('/region/', defaults={'id': 1}) @app.route('/region/ ', methods=['GET', 'POST']) def region(id): pass Here are the parameters that :meth: ~flask.Flask.route and :meth: ~flask.Flask.add_url_rule accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the view_func parameter. =============== ========================================================== rule the URL rule as string endpoint the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated. view_func the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the :attr: ~flask.Flask.view_functions dictionary with the endpoint as key. defaults A dictionary with defaults for this rule. See the example above for how defaults work. subdomain specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed. **options the options to be forwarded to the underlying :class: ~werkzeug.routing.Rule object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to ( GET , POST etc.). By default a rule just listens for GET (and implicitly HEAD ). Starting with Flask 0.6, OPTIONS is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments. =============== ==========================================================","title":"URL Route Registrations"},{"location":"api/#view-function-options","text":"For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to :meth: ~flask.Flask.add_url_rule or general behavior: __name__ : The name of a function is by default used as endpoint. If endpoint is provided explicitly this value is used. Additionally this will be prefixed with the name of the blueprint by default which cannot be customized from the function itself. methods : If methods are not provided when the URL rule is added, Flask will look on the view function object itself if a methods attribute exists. If it does, it will pull the information for the methods from there. provide_automatic_options : if this attribute is set Flask will either force enable or disable the automatic implementation of the HTTP OPTIONS response. This can be useful when working with decorators that want to customize the OPTIONS response on a per-view basis. required_methods : if this attribute is set, Flask will always add these methods when registering a URL rule even if the methods were explicitly overridden in the route() call. Full example:: def index(): if request.method == 'OPTIONS': # custom options handling here ... return 'Hello World!' index.provide_automatic_options = False index.methods = ['GET', 'OPTIONS'] app.add_url_rule('/', index) .. versionadded:: 0.8 The provide_automatic_options functionality was added.","title":"View Function Options"},{"location":"api/#command-line-interface","text":".. currentmodule:: flask.cli .. autoclass:: FlaskGroup :members: .. autoclass:: AppGroup :members: .. autoclass:: ScriptInfo :members: .. autofunction:: load_dotenv .. autofunction:: with_appcontext .. autofunction:: pass_script_info Marks a function so that an instance of :class: ScriptInfo is passed as first argument to the click callback. .. autodata:: run_command .. autodata:: shell_command","title":"Command Line Interface"},{"location":"appcontext/","text":".. currentmodule:: flask The Application Context \u00b6 The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the :data: current_app and :data: g proxies are accessed instead. This is similar to the :doc: /reqcontext , which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed. Purpose of the Context \u00b6 The :class: Flask application object has attributes, such as :attr: ~Flask.config , that are useful to access within views and :doc: CLI commands </cli> . However, importing the app instance within the modules in your project is prone to circular import issues. When using the :doc: app factory pattern </patterns/appfactories> or writing reusable :doc: blueprints </blueprints> or :doc: extensions </extensions> there won't be an app instance to import at all. Flask solves this issue with the application context . Rather than referring to an app directly, you use the :data: current_app proxy, which points to the application handling the current activity. Flask automatically pushes an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to :data: current_app . Flask will also automatically push an app context when running CLI commands registered with :attr: Flask.cli using @app.cli.command() . Lifetime of the Context \u00b6 The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a :doc: request context </reqcontext> . When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request. See :doc: /reqcontext for more information about how the contexts work and the full lifecycle of a request. Manually Push a Context \u00b6 If you try to access :data: current_app , or anything that uses it, outside an application context, you'll get this error message: .. code-block:: pytb RuntimeError : Working outside of application context . This typically means that you attempted to use functionality that needed to interface with the current application object in some way . To solve this , set up an application context with app . app_context (). If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the app . Use :meth: ~Flask.app_context in a with block, and everything that runs in the block will have access to :data: current_app . :: def create_app(): app = Flask(__name__) with app.app_context(): init_db() return app If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command. Storing Data \u00b6 The application context is a good place to store common data during a request or CLI command. Flask provides the :data: g object <g> for this purpose. It is a simple namespace object that has the same lifetime as an application context. .. note:: The g name stands for \"global\", but that is referring to the data being global within a context . The data on g is lost after the context ends, and it is not an appropriate place to store data between requests. Use the :data: session or a database to store data across requests. A common use for :data: g is to manage resources during a request. get_X() creates resource X if it does not exist, caching it as g.X . teardown_X() closes or otherwise deallocates the resource if it exists. It is registered as a :meth: ~Flask.teardown_appcontext handler. For example, you can manage a database connection using this pattern:: from flask import g def get_db (): if 'db' not in g : g . db = connect_to_database () return g . db @app.teardown_appcontext def teardown_db (): db = g . pop ( 'db' , None ) if db is not None : db . close () During a request, every call to get_db() will return the same connection, and it will be closed automatically at the end of the request. You can use :class: ~werkzeug.local.LocalProxy to make a new context local from get_db() :: from werkzeug.local import LocalProxy db = LocalProxy ( get_db ) Accessing db will call get_db internally, in the same way that :data: current_app works. If you're writing an extension, :data: g should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with :data: _app_ctx_stack.top <_app_ctx_stack> . For more information see :doc: extensiondev . Events and Signals \u00b6 The application will call functions registered with :meth: ~Flask.teardown_appcontext when the application context is popped. If :data: ~signals.signals_available is true, the following signals are sent: :data: appcontext_pushed , :data: appcontext_tearing_down , and :data: appcontext_popped .","title":"Appcontext"},{"location":"appcontext/#the-application-context","text":"The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the :data: current_app and :data: g proxies are accessed instead. This is similar to the :doc: /reqcontext , which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.","title":"The Application Context"},{"location":"appcontext/#purpose-of-the-context","text":"The :class: Flask application object has attributes, such as :attr: ~Flask.config , that are useful to access within views and :doc: CLI commands </cli> . However, importing the app instance within the modules in your project is prone to circular import issues. When using the :doc: app factory pattern </patterns/appfactories> or writing reusable :doc: blueprints </blueprints> or :doc: extensions </extensions> there won't be an app instance to import at all. Flask solves this issue with the application context . Rather than referring to an app directly, you use the :data: current_app proxy, which points to the application handling the current activity. Flask automatically pushes an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to :data: current_app . Flask will also automatically push an app context when running CLI commands registered with :attr: Flask.cli using @app.cli.command() .","title":"Purpose of the Context"},{"location":"appcontext/#lifetime-of-the-context","text":"The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a :doc: request context </reqcontext> . When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request. See :doc: /reqcontext for more information about how the contexts work and the full lifecycle of a request.","title":"Lifetime of the Context"},{"location":"appcontext/#manually-push-a-context","text":"If you try to access :data: current_app , or anything that uses it, outside an application context, you'll get this error message: .. code-block:: pytb RuntimeError : Working outside of application context . This typically means that you attempted to use functionality that needed to interface with the current application object in some way . To solve this , set up an application context with app . app_context (). If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the app . Use :meth: ~Flask.app_context in a with block, and everything that runs in the block will have access to :data: current_app . :: def create_app(): app = Flask(__name__) with app.app_context(): init_db() return app If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command.","title":"Manually Push a Context"},{"location":"appcontext/#storing-data","text":"The application context is a good place to store common data during a request or CLI command. Flask provides the :data: g object <g> for this purpose. It is a simple namespace object that has the same lifetime as an application context. .. note:: The g name stands for \"global\", but that is referring to the data being global within a context . The data on g is lost after the context ends, and it is not an appropriate place to store data between requests. Use the :data: session or a database to store data across requests. A common use for :data: g is to manage resources during a request. get_X() creates resource X if it does not exist, caching it as g.X . teardown_X() closes or otherwise deallocates the resource if it exists. It is registered as a :meth: ~Flask.teardown_appcontext handler. For example, you can manage a database connection using this pattern:: from flask import g def get_db (): if 'db' not in g : g . db = connect_to_database () return g . db @app.teardown_appcontext def teardown_db (): db = g . pop ( 'db' , None ) if db is not None : db . close () During a request, every call to get_db() will return the same connection, and it will be closed automatically at the end of the request. You can use :class: ~werkzeug.local.LocalProxy to make a new context local from get_db() :: from werkzeug.local import LocalProxy db = LocalProxy ( get_db ) Accessing db will call get_db internally, in the same way that :data: current_app works. If you're writing an extension, :data: g should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with :data: _app_ctx_stack.top <_app_ctx_stack> . For more information see :doc: extensiondev .","title":"Storing Data"},{"location":"appcontext/#events-and-signals","text":"The application will call functions registered with :meth: ~Flask.teardown_appcontext when the application context is popped. If :data: ~signals.signals_available is true, the following signals are sent: :data: appcontext_pushed , :data: appcontext_tearing_down , and :data: appcontext_popped .","title":"Events and Signals"},{"location":"becomingbig/","text":"Becoming Big \u00b6 Here are your options when growing your codebase or scaling your application. Read the Source. \u00b6 Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don't just use Flask -- understand it. Read the source. Flask's code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project. Hook. Extend. \u00b6 The :ref: api docs are full of available overrides, hook points, and :ref: signals . You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many extensions <http://flask.pocoo.org/extensions/> _ in the community, and look for patterns to build your own extensions if you do not find the tools you need. Subclass. \u00b6 The :class: ~flask.Flask class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing :class: ~flask.Flask (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with :ref: app-factories . See :doc: /patterns/subclassing for an example. Wrap with middleware. \u00b6 The :ref: app-dispatch chapter shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several middlewares <http://werkzeug.pocoo.org/docs/middlewares/> _. Fork. \u00b6 If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration. This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don't have to contribute any changes back if you decide to modify the framework. The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort. Scale like a pro. \u00b6 For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on. Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won't perform any better or would not even support a second server. There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library. Discuss with the community. \u00b6 The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don't hesitate to contact the developers on the mailinglist or IRC channel. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.","title":"Becoming Big"},{"location":"becomingbig/#becoming-big","text":"Here are your options when growing your codebase or scaling your application.","title":"Becoming Big"},{"location":"becomingbig/#read-the-source","text":"Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don't just use Flask -- understand it. Read the source. Flask's code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project.","title":"Read the Source."},{"location":"becomingbig/#hook-extend","text":"The :ref: api docs are full of available overrides, hook points, and :ref: signals . You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many extensions <http://flask.pocoo.org/extensions/> _ in the community, and look for patterns to build your own extensions if you do not find the tools you need.","title":"Hook. Extend."},{"location":"becomingbig/#subclass","text":"The :class: ~flask.Flask class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing :class: ~flask.Flask (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with :ref: app-factories . See :doc: /patterns/subclassing for an example.","title":"Subclass."},{"location":"becomingbig/#wrap-with-middleware","text":"The :ref: app-dispatch chapter shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several middlewares <http://werkzeug.pocoo.org/docs/middlewares/> _.","title":"Wrap with middleware."},{"location":"becomingbig/#fork","text":"If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration. This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don't have to contribute any changes back if you decide to modify the framework. The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort.","title":"Fork."},{"location":"becomingbig/#scale-like-a-pro","text":"For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on. Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won't perform any better or would not even support a second server. There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library.","title":"Scale like a pro."},{"location":"becomingbig/#discuss-with-the-community","text":"The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don't hesitate to contact the developers on the mailinglist or IRC channel. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.","title":"Discuss with the community."},{"location":"blueprints/","text":"Modular Applications with Blueprints \u00b6 .. currentmodule:: flask .. versionadded:: 0.7 Flask uses a concept of blueprints for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A :class: Blueprint object works similarly to a :class: Flask application object, but it is not actually an application. Rather it is a blueprint of how to construct or extend an application. Why Blueprints? \u00b6 Blueprints in Flask are intended for these cases: Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints. Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint. Register a blueprint multiple times on an application with different URL rules. Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions. Register a blueprint on an application for any of these cases when initializing a Flask extension. A blueprint in Flask is not a pluggable app because it is not actually an application -- it's a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see :ref: app-dispatch ), but your applications will have separate configs and will be managed at the WSGI layer. Blueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object. The Concept of Blueprints \u00b6 The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another. My First Blueprint \u00b6 This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:: from flask import Blueprint , render_template , abort from jinja2 import TemplateNotFound simple_page = Blueprint ( 'simple_page' , __name__ , template_folder = 'templates' ) @simple_page.route ( '/' , defaults = { 'page' : 'index' }) @simple_page.route ( '/&lt;page&gt;' ) def show ( page ): try : return render_template ( 'pages/ %s .html' % page ) except TemplateNotFound : abort ( 404 ) When you bind a function with the help of the @simple_page.route decorator, the blueprint will record the intention of registering the function show on the application when it's later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the :class: Blueprint constructor (in this case also simple_page ). The blueprint's name does not modify the URL, only the endpoint. Registering Blueprints \u00b6 So how do you register that blueprint? Like this:: from flask import Flask from yourapplication.simple_page import simple_page app = Flask ( __name__ ) app . register_blueprint ( simple_page ) If you check the rules registered on the application, you will find these:: &gt;&gt;&gt; app.url_map Map([&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;, &lt;Rule '/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;, &lt;Rule '/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]) The first one is obviously from the application itself for the static files. The other two are for the show function of the simple_page blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot ( . ). Blueprints however can also be mounted at different locations:: app.register_blueprint(simple_page, url_prefix='/pages') And sure enough, these are the generated rules:: &gt;&gt;&gt; app.url_map Map([&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;, &lt;Rule '/pages/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;, &lt;Rule '/pages/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]) On top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once. Blueprint Resources \u00b6 Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides. Blueprint Resource Folder Like for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it's usually not recommended. The folder is inferred from the second argument to :class:`Blueprint` which is usually `__name__`. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it's a module, the package the module is contained in will be the resource folder. You can access the :attr:`Blueprint.root_path` property to see what the resource folder is:: >>> simple_page.root_path '/Users/username/TestProject/yourapplication' To quickly open sources from this folder you can use the :meth:`~Blueprint.open_resource` function:: with simple_page.open_resource('static/style.css') as f: code = f.read() Static Files ```````````` A blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the ``static_folder`` argument. It is either an absolute path or relative to the blueprint's location:: admin = Blueprint('admin', __name__, static_folder='static') By default the rightmost part of the path is where it is exposed on the web. This can be changed with the ``static_url_path`` argument. Because the folder is called ``static`` here it will be available at the ``url_prefix`` of the blueprint + ``/static``. If the blueprint has the prefix ``/admin``, the static URL will be ``/admin/static``. The endpoint is named ``blueprint_name.static``. You can generate URLs to it with :func:`url_for` like you would with the static folder of the application:: url_for('admin.static', filename='style.css') However, if the blueprint does not have a ``url_prefix``, it is not possible to access the blueprint's static folder. This is because the URL would be ``/static`` in this case, and the application's ``/static`` route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder. Templates ````````` If you want the blueprint to expose templates you can do that by providing the `template_folder` parameter to the :class:`Blueprint` constructor:: admin = Blueprint('admin', __name__, template_folder='templates') For static files, the path can be absolute or relative to the blueprint resource folder. The template folder is added to the search path of templates but with a lower priority than the actual application's template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don't want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others. So if you have a blueprint in the folder ``yourapplication/admin`` and you want to render the template ``'admin/index.html'`` and you have provided ``templates`` as a `template_folder` you will have to create a file like this: :file:`yourapplication/admin/templates/admin/index.html`. The reason for the extra ``admin`` folder is to avoid getting our template overridden by a template named ``index.html`` in the actual application template folder. To further reiterate this: if you have a blueprint named ``admin`` and you want to render a template called :file:`index.html` which is specific to this blueprint, the best idea is to lay out your templates like this:: yourpackage/ blueprints/ admin/ templates/ admin/ index.html __init__.py And then when you want to render the template, use :file:`admin/index.html` as the name to look up the template by. If you encounter problems loading the correct templates enable the ``EXPLAIN_TEMPLATE_LOADING`` config variable which will instruct Flask to print out the steps it goes through to locate templates on every ``render_template`` call. Building URLs ------------- If you want to link from one page to another you can use the :func:`url_for` function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (``.``):: url_for('admin.index') Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only:: url_for('.index') This will link to ``admin.index`` for instance in case the current request was dispatched to any other admin blueprint endpoint. Error Handlers -------------- Blueprints support the errorhandler decorator just like the :class:`Flask` application object, so it is easy to make Blueprint-specific custom error pages. Here is an example for a \"404 Page Not Found\" exception:: @simple_page.errorhandler(404) def page_not_found(e): return render_template('pages/404.html') Most errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate ``raise`` statement or a call to ``abort`` in another of the blueprint's view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not \"own\" a certain URL space, so the application instance has no way of knowing which blueprint errorhandler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the ``request`` proxy object:: @app.errorhandler(404) @app.errorhandler(405) def _handle_api_error(ex): if request.path.startswith('/api/'): return jsonify_error(ex) else: return ex More information on error handling see :ref:`errorpages`.","title":"Modular Applications with Blueprints"},{"location":"blueprints/#modular-applications-with-blueprints","text":".. currentmodule:: flask .. versionadded:: 0.7 Flask uses a concept of blueprints for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A :class: Blueprint object works similarly to a :class: Flask application object, but it is not actually an application. Rather it is a blueprint of how to construct or extend an application.","title":"Modular Applications with Blueprints"},{"location":"blueprints/#why-blueprints","text":"Blueprints in Flask are intended for these cases: Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints. Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint. Register a blueprint multiple times on an application with different URL rules. Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions. Register a blueprint on an application for any of these cases when initializing a Flask extension. A blueprint in Flask is not a pluggable app because it is not actually an application -- it's a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see :ref: app-dispatch ), but your applications will have separate configs and will be managed at the WSGI layer. Blueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object.","title":"Why Blueprints?"},{"location":"blueprints/#the-concept-of-blueprints","text":"The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.","title":"The Concept of Blueprints"},{"location":"blueprints/#my-first-blueprint","text":"This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:: from flask import Blueprint , render_template , abort from jinja2 import TemplateNotFound simple_page = Blueprint ( 'simple_page' , __name__ , template_folder = 'templates' ) @simple_page.route ( '/' , defaults = { 'page' : 'index' }) @simple_page.route ( '/&lt;page&gt;' ) def show ( page ): try : return render_template ( 'pages/ %s .html' % page ) except TemplateNotFound : abort ( 404 ) When you bind a function with the help of the @simple_page.route decorator, the blueprint will record the intention of registering the function show on the application when it's later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the :class: Blueprint constructor (in this case also simple_page ). The blueprint's name does not modify the URL, only the endpoint.","title":"My First Blueprint"},{"location":"blueprints/#registering-blueprints","text":"So how do you register that blueprint? Like this:: from flask import Flask from yourapplication.simple_page import simple_page app = Flask ( __name__ ) app . register_blueprint ( simple_page ) If you check the rules registered on the application, you will find these:: &gt;&gt;&gt; app.url_map Map([&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;, &lt;Rule '/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;, &lt;Rule '/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]) The first one is obviously from the application itself for the static files. The other two are for the show function of the simple_page blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot ( . ). Blueprints however can also be mounted at different locations:: app.register_blueprint(simple_page, url_prefix='/pages') And sure enough, these are the generated rules:: &gt;&gt;&gt; app.url_map Map([&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;, &lt;Rule '/pages/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;, &lt;Rule '/pages/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]) On top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once.","title":"Registering Blueprints"},{"location":"blueprints/#blueprint-resources","text":"Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides. Blueprint Resource Folder Like for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it's usually not recommended. The folder is inferred from the second argument to :class:`Blueprint` which is usually `__name__`. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it's a module, the package the module is contained in will be the resource folder. You can access the :attr:`Blueprint.root_path` property to see what the resource folder is:: >>> simple_page.root_path '/Users/username/TestProject/yourapplication' To quickly open sources from this folder you can use the :meth:`~Blueprint.open_resource` function:: with simple_page.open_resource('static/style.css') as f: code = f.read() Static Files ```````````` A blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the ``static_folder`` argument. It is either an absolute path or relative to the blueprint's location:: admin = Blueprint('admin', __name__, static_folder='static') By default the rightmost part of the path is where it is exposed on the web. This can be changed with the ``static_url_path`` argument. Because the folder is called ``static`` here it will be available at the ``url_prefix`` of the blueprint + ``/static``. If the blueprint has the prefix ``/admin``, the static URL will be ``/admin/static``. The endpoint is named ``blueprint_name.static``. You can generate URLs to it with :func:`url_for` like you would with the static folder of the application:: url_for('admin.static', filename='style.css') However, if the blueprint does not have a ``url_prefix``, it is not possible to access the blueprint's static folder. This is because the URL would be ``/static`` in this case, and the application's ``/static`` route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder. Templates ````````` If you want the blueprint to expose templates you can do that by providing the `template_folder` parameter to the :class:`Blueprint` constructor:: admin = Blueprint('admin', __name__, template_folder='templates') For static files, the path can be absolute or relative to the blueprint resource folder. The template folder is added to the search path of templates but with a lower priority than the actual application's template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don't want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others. So if you have a blueprint in the folder ``yourapplication/admin`` and you want to render the template ``'admin/index.html'`` and you have provided ``templates`` as a `template_folder` you will have to create a file like this: :file:`yourapplication/admin/templates/admin/index.html`. The reason for the extra ``admin`` folder is to avoid getting our template overridden by a template named ``index.html`` in the actual application template folder. To further reiterate this: if you have a blueprint named ``admin`` and you want to render a template called :file:`index.html` which is specific to this blueprint, the best idea is to lay out your templates like this:: yourpackage/ blueprints/ admin/ templates/ admin/ index.html __init__.py And then when you want to render the template, use :file:`admin/index.html` as the name to look up the template by. If you encounter problems loading the correct templates enable the ``EXPLAIN_TEMPLATE_LOADING`` config variable which will instruct Flask to print out the steps it goes through to locate templates on every ``render_template`` call. Building URLs ------------- If you want to link from one page to another you can use the :func:`url_for` function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (``.``):: url_for('admin.index') Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only:: url_for('.index') This will link to ``admin.index`` for instance in case the current request was dispatched to any other admin blueprint endpoint. Error Handlers -------------- Blueprints support the errorhandler decorator just like the :class:`Flask` application object, so it is easy to make Blueprint-specific custom error pages. Here is an example for a \"404 Page Not Found\" exception:: @simple_page.errorhandler(404) def page_not_found(e): return render_template('pages/404.html') Most errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate ``raise`` statement or a call to ``abort`` in another of the blueprint's view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not \"own\" a certain URL space, so the application instance has no way of knowing which blueprint errorhandler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the ``request`` proxy object:: @app.errorhandler(404) @app.errorhandler(405) def _handle_api_error(ex): if request.path.startswith('/api/'): return jsonify_error(ex) else: return ex More information on error handling see :ref:`errorpages`.","title":"Blueprint Resources"},{"location":"changelog/","text":".. include:: ../CHANGES.rst","title":"Changelog"},{"location":"cli/","text":".. currentmodule:: flask Command Line Interface \u00b6 Installing Flask installs the flask script, a Click _ command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The --help option will give more information about any commands and options. .. _Click: http://click.pocoo.org/ Application Discovery \u00b6 The flask command is installed by Flask, not your application; it must be told where to find your application in order to use it. The FLASK_APP environment variable is used to specify how to load the application. Unix Bash (Linux, Mac, etc.):: $ export FLASK_APP = hello $ flask run Windows CMD:: &gt; set FLASK_APP=hello &gt; flask run Windows PowerShell:: &gt; $env:FLASK_APP = \"hello\" &gt; flask run While FLASK_APP supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values: (nothing) The file :file: wsgi.py is imported, automatically detecting an app ( app ). This provides an easy way to create an app from a factory with extra arguments. FLASK_APP=hello The name is imported, automatically detecting an app ( app ) or factory ( create_app ). FLASK_APP has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts: FLASK_APP=src/hello Sets the current working directory to src then imports hello . FLASK_APP=hello.web Imports the path hello.web . FLASK_APP=hello:app2 Uses the app2 Flask instance in hello . FLASK_APP=\"hello:create_app('dev')\" The create_app factory in hello is called with the string 'dev' as the argument. If FLASK_APP is not set, the command will look for a file called :file: wsgi.py or :file: app.py and try to detect an application instance or factory. Within the given import, the command looks for an application instance named app or application , then any application instance. If no instance is found, the command looks for a factory function named create_app or make_app that returns an instance. When calling an application factory, if the factory takes an argument named script_info , then the :class: ~cli.ScriptInfo instance is passed as a keyword argument. If the application factory takes only one argument and no parentheses follow the factory name, the :class: ~cli.ScriptInfo instance is passed as a positional argument. If parentheses follow the factory name, their contents are parsed as Python literals and passes as arguments to the function. This means that strings must still be in quotes. Run the Development Server \u00b6 The :func: run <cli.run_command> command will start the development server. It replaces the :meth: Flask.run method in most cases. :: $ flask run * Serving Flask app \"hello\" * Running on http://127.0.0.1:5000/ ( Press CTRL+C to quit ) .. warning:: Do not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See :ref: deployment for how to run in production. Open a Shell \u00b6 To explore the data in your application, you can start an interactive Python shell with the :func: shell <cli.shell_command> command. An application context will be active, and the app instance will be imported. :: $ flask shell Python 3 .6.2 ( default, Jul 20 2017 , 03 :52:27 ) [ GCC 7 .1.1 20170630 ] on linux App: example Instance: /home/user/Projects/hello/instance & gt ;& gt ;& gt ; Use :meth: ~Flask.shell_context_processor to add other automatic imports. Environments \u00b6 .. versionadded:: 1.0 The environment in which the Flask app runs is set by the :envvar: FLASK_ENV environment variable. If not set it defaults to production . The other recognized environment is development . Flask and extensions may choose to enable behaviors based on the environment. If the env is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader. :: $ FLASK_ENV = development flask run * Serving Flask app \"hello\" * Environment: development * Debug mode: on * Running on http://127.0.0.1:5000/ ( Press CTRL+C to quit ) * Restarting with inotify reloader * Debugger is active! * Debugger PIN: 223 -456-919 Debug Mode \u00b6 Debug mode will be enabled when :envvar: FLASK_ENV is development , as described above. If you want to control debug mode separately, use :envvar: FLASK_DEBUG . The value 1 enables it, 0 disables it. Environment Variables From dotenv \u00b6 Rather than setting FLASK_APP each time you open a new terminal, you can use Flask's dotenv support to set environment variables automatically. If python-dotenv _ is installed, running the flask command will set environment variables defined in the files :file: .env and :file: .flaskenv . This can be used to avoid having to set FLASK_APP manually every time you open a new terminal, and to set configuration using environment variables similar to how some deployment services work. Variables set on the command line are used over those set in :file: .env , which are used over those set in :file: .flaskenv . :file: .flaskenv should be used for public variables, such as FLASK_APP , while :file: .env should not be committed to your repository so that it can set private variables. Directories are scanned upwards from the directory you call flask from to locate the files. The current working directory will be set to the location of the file, with the assumption that that is the top level project directory. The files are only loaded by the flask command or calling :meth: ~Flask.run . If you would like to load these files when running in production, you should call :func: ~cli.load_dotenv manually. .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme Setting Command Options Click is configured to load default values for command options from environment variables. The variables use the pattern ``FLASK_COMMAND_OPTION``. For example, to set the port for the run command, instead of ``flask run --port 8000``: .. code-block:: none $ export FLASK_RUN_PORT=8000 $ flask run * Running on http://127.0.0.1:8000/ These can be added to the ``.flaskenv`` file just like ``FLASK_APP`` to control default command options. Disable dotenv ~~~~~~~~~~~~~~ The ``flask`` command will show a message if it detects dotenv files but python-dotenv is not installed. .. code-block:: none $ flask run * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them. You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the ``FLASK_SKIP_DOTENV`` environment variable. This can be useful if you want to load them manually, or if you're using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won't configure as expected. .. code-block:: none $ export FLASK_SKIP_DOTENV=1 $ flask run Environment Variables From virtualenv ------------------------------------- If you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv's :file:`activate` script. Activating the virtualenv will set the variables. Unix Bash, :file:`venv/bin/activate`:: $ export FLASK_APP=hello Windows CMD, :file:`venv\\\\Scripts\\\\activate.bat`:: > set FLASK_APP=hello It is preferred to use dotenv support over this, since :file:`.flaskenv` can be committed to the repository so that it works automatically wherever the project is checked out. Custom Commands --------------- The ``flask`` command is implemented using `Click`_. See that project's documentation for full information about writing commands. This example adds the command ``create_user`` that takes the argument ``name``. :: import click from flask import Flask app = Flask(__name__) @app.cli.command() @click.argument('name') def create_user(name): ... :: $ flask create_user admin This example adds the same command, but as ``user create``, a command in a group. This is useful if you want to organize multiple related commands. :: import click from flask import Flask from flask.cli import AppGroup app = Flask(__name__) user_cli = AppGroup('user') @user_cli.command('create') @click.argument('name') def create_user(name): ... app.cli.add_command(user_cli) :: $ flask user create demo See :ref:`testing-cli` for an overview of how to test your custom commands. Application Context ~~~~~~~~~~~~~~~~~~~ Commands added using the Flask app's :attr:`~Flask.cli` :meth:`~cli.AppGroup.command` decorator will be executed with an application context pushed, so your command and extensions have access to the app and its configuration. If you create a command using the Click :func:`~click.command` decorator instead of the Flask decorator, you can use :func:`~cli.with_appcontext` to get the same behavior. :: import click from flask.cli import with_appcontext @click.command() @with_appcontext def do_work(): ... app.cli.add_command(do_work) If you're sure a command doesn't need the context, you can disable it:: @app.cli.command(with_appcontext=False) def do_work(): ... Plugins ------- Flask will automatically load commands specified in the ``flask.commands`` `entry point`_. This is useful for extensions that want to add commands when they are installed. Entry points are specified in :file:`setup.py` :: from setuptools import setup setup( name='flask-my-extension', ..., entry_points={ 'flask.commands': [ 'my-command=flask_my_extension.commands:cli' ], }, ) .. _entry point: https://packaging.python.org/tutorials/distributing-packages/#entry-points Inside :file:`flask_my_extension/commands.py` you can then export a Click object:: import click @click.command() def cli(): ... Once that package is installed in the same virtualenv as your Flask project, you can run ``flask my-command`` to invoke the command. .. _custom-scripts: Custom Scripts -------------- When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using ``FLASK_APP`` and letting Flask load your application, you can create your own Click object and export it as a `console script`_ entry point. Create an instance of :class:`~cli.FlaskGroup` and pass it the factory:: import click from flask import Flask from flask.cli import FlaskGroup def create_app(): app = Flask('wiki') # other setup return app @click.group(cls=FlaskGroup, create_app=create_app) def cli(): \"\"\"Management script for the Wiki application.\"\"\" Define the entry point in :file:`setup.py`:: from setuptools import setup setup( name='flask-my-extension', ..., entry_points={ 'console_scripts': [ 'wiki=wiki:cli' ], }, ) Install the application in the virtualenv in editable mode and the custom script is available. Note that you don't need to set ``FLASK_APP``. :: $ pip install -e . $ wiki run .. admonition:: Errors in Custom Scripts When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point. The ``flask`` command, being separate from your code, does not have this issue and is recommended in most cases. .. _console script: https://packaging.python.org/tutorials/distributing-packages/#console-scripts PyCharm Integration ------------------- Prior to PyCharm 2018.1, the Flask CLI features weren't yet fully integrated into PyCharm. We have to do a few tweaks to get them working smoothly. These instructions should be similar for any other IDE you might want to use. In PyCharm, with your project open, click on *Run* from the menu bar and go to *Edit Configurations*. You'll be greeted by a screen similar to this: .. image:: _static/pycharm-runconfig.png :align: center :class: screenshot :alt: screenshot of pycharm's run configuration settings There's quite a few options to change, but once we've done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself. Click the + (*Add New Configuration*) button and select *Python*. Give the configuration a good descriptive name such as \"Run Flask Server\". For the ``flask run`` command, check \"Single instance only\" since you can't run the server more than once at the same time. Select *Module name* from the dropdown (**A**) then input ``flask``. The *Parameters* field (**B**) is set to the CLI command to execute (with any arguments). In this example we use ``run``, which will run the development server. You can skip this next step if you're using :ref:`dotenv`. We need to add an environment variable (**C**) to identify our application. Click on the browse button and add an entry with ``FLASK_APP`` on the left and the Python import or file on the right (``hello`` for example). Next we need to set the working directory (**D**) to be the folder where our application resides. If you have installed your project as a package in your virtualenv, you may untick the *PYTHONPATH* options (**E**). This will more accurately match how you deploy the app later. Click *Apply* to save the configuration, or *OK* to save and close the window. Select the configuration in the main PyCharm window and click the play button next to it to run the server. Now that we have a configuration which runs ``flask run`` from within PyCharm, we can copy that configuration and alter the *Script* argument to run a different CLI command, e.g. ``flask shell``.","title":"Cli"},{"location":"cli/#command-line-interface","text":"Installing Flask installs the flask script, a Click _ command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The --help option will give more information about any commands and options. .. _Click: http://click.pocoo.org/","title":"Command Line Interface"},{"location":"cli/#application-discovery","text":"The flask command is installed by Flask, not your application; it must be told where to find your application in order to use it. The FLASK_APP environment variable is used to specify how to load the application. Unix Bash (Linux, Mac, etc.):: $ export FLASK_APP = hello $ flask run Windows CMD:: &gt; set FLASK_APP=hello &gt; flask run Windows PowerShell:: &gt; $env:FLASK_APP = \"hello\" &gt; flask run While FLASK_APP supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values: (nothing) The file :file: wsgi.py is imported, automatically detecting an app ( app ). This provides an easy way to create an app from a factory with extra arguments. FLASK_APP=hello The name is imported, automatically detecting an app ( app ) or factory ( create_app ). FLASK_APP has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts: FLASK_APP=src/hello Sets the current working directory to src then imports hello . FLASK_APP=hello.web Imports the path hello.web . FLASK_APP=hello:app2 Uses the app2 Flask instance in hello . FLASK_APP=\"hello:create_app('dev')\" The create_app factory in hello is called with the string 'dev' as the argument. If FLASK_APP is not set, the command will look for a file called :file: wsgi.py or :file: app.py and try to detect an application instance or factory. Within the given import, the command looks for an application instance named app or application , then any application instance. If no instance is found, the command looks for a factory function named create_app or make_app that returns an instance. When calling an application factory, if the factory takes an argument named script_info , then the :class: ~cli.ScriptInfo instance is passed as a keyword argument. If the application factory takes only one argument and no parentheses follow the factory name, the :class: ~cli.ScriptInfo instance is passed as a positional argument. If parentheses follow the factory name, their contents are parsed as Python literals and passes as arguments to the function. This means that strings must still be in quotes.","title":"Application Discovery"},{"location":"cli/#run-the-development-server","text":"The :func: run <cli.run_command> command will start the development server. It replaces the :meth: Flask.run method in most cases. :: $ flask run * Serving Flask app \"hello\" * Running on http://127.0.0.1:5000/ ( Press CTRL+C to quit ) .. warning:: Do not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See :ref: deployment for how to run in production.","title":"Run the Development Server"},{"location":"cli/#open-a-shell","text":"To explore the data in your application, you can start an interactive Python shell with the :func: shell <cli.shell_command> command. An application context will be active, and the app instance will be imported. :: $ flask shell Python 3 .6.2 ( default, Jul 20 2017 , 03 :52:27 ) [ GCC 7 .1.1 20170630 ] on linux App: example Instance: /home/user/Projects/hello/instance & gt ;& gt ;& gt ; Use :meth: ~Flask.shell_context_processor to add other automatic imports.","title":"Open a Shell"},{"location":"cli/#environments","text":".. versionadded:: 1.0 The environment in which the Flask app runs is set by the :envvar: FLASK_ENV environment variable. If not set it defaults to production . The other recognized environment is development . Flask and extensions may choose to enable behaviors based on the environment. If the env is set to development , the flask command will enable debug mode and flask run will enable the interactive debugger and reloader. :: $ FLASK_ENV = development flask run * Serving Flask app \"hello\" * Environment: development * Debug mode: on * Running on http://127.0.0.1:5000/ ( Press CTRL+C to quit ) * Restarting with inotify reloader * Debugger is active! * Debugger PIN: 223 -456-919","title":"Environments"},{"location":"cli/#debug-mode","text":"Debug mode will be enabled when :envvar: FLASK_ENV is development , as described above. If you want to control debug mode separately, use :envvar: FLASK_DEBUG . The value 1 enables it, 0 disables it.","title":"Debug Mode"},{"location":"cli/#environment-variables-from-dotenv","text":"Rather than setting FLASK_APP each time you open a new terminal, you can use Flask's dotenv support to set environment variables automatically. If python-dotenv _ is installed, running the flask command will set environment variables defined in the files :file: .env and :file: .flaskenv . This can be used to avoid having to set FLASK_APP manually every time you open a new terminal, and to set configuration using environment variables similar to how some deployment services work. Variables set on the command line are used over those set in :file: .env , which are used over those set in :file: .flaskenv . :file: .flaskenv should be used for public variables, such as FLASK_APP , while :file: .env should not be committed to your repository so that it can set private variables. Directories are scanned upwards from the directory you call flask from to locate the files. The current working directory will be set to the location of the file, with the assumption that that is the top level project directory. The files are only loaded by the flask command or calling :meth: ~Flask.run . If you would like to load these files when running in production, you should call :func: ~cli.load_dotenv manually. .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme Setting Command Options Click is configured to load default values for command options from environment variables. The variables use the pattern ``FLASK_COMMAND_OPTION``. For example, to set the port for the run command, instead of ``flask run --port 8000``: .. code-block:: none $ export FLASK_RUN_PORT=8000 $ flask run * Running on http://127.0.0.1:8000/ These can be added to the ``.flaskenv`` file just like ``FLASK_APP`` to control default command options. Disable dotenv ~~~~~~~~~~~~~~ The ``flask`` command will show a message if it detects dotenv files but python-dotenv is not installed. .. code-block:: none $ flask run * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them. You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the ``FLASK_SKIP_DOTENV`` environment variable. This can be useful if you want to load them manually, or if you're using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won't configure as expected. .. code-block:: none $ export FLASK_SKIP_DOTENV=1 $ flask run Environment Variables From virtualenv ------------------------------------- If you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv's :file:`activate` script. Activating the virtualenv will set the variables. Unix Bash, :file:`venv/bin/activate`:: $ export FLASK_APP=hello Windows CMD, :file:`venv\\\\Scripts\\\\activate.bat`:: > set FLASK_APP=hello It is preferred to use dotenv support over this, since :file:`.flaskenv` can be committed to the repository so that it works automatically wherever the project is checked out. Custom Commands --------------- The ``flask`` command is implemented using `Click`_. See that project's documentation for full information about writing commands. This example adds the command ``create_user`` that takes the argument ``name``. :: import click from flask import Flask app = Flask(__name__) @app.cli.command() @click.argument('name') def create_user(name): ... :: $ flask create_user admin This example adds the same command, but as ``user create``, a command in a group. This is useful if you want to organize multiple related commands. :: import click from flask import Flask from flask.cli import AppGroup app = Flask(__name__) user_cli = AppGroup('user') @user_cli.command('create') @click.argument('name') def create_user(name): ... app.cli.add_command(user_cli) :: $ flask user create demo See :ref:`testing-cli` for an overview of how to test your custom commands. Application Context ~~~~~~~~~~~~~~~~~~~ Commands added using the Flask app's :attr:`~Flask.cli` :meth:`~cli.AppGroup.command` decorator will be executed with an application context pushed, so your command and extensions have access to the app and its configuration. If you create a command using the Click :func:`~click.command` decorator instead of the Flask decorator, you can use :func:`~cli.with_appcontext` to get the same behavior. :: import click from flask.cli import with_appcontext @click.command() @with_appcontext def do_work(): ... app.cli.add_command(do_work) If you're sure a command doesn't need the context, you can disable it:: @app.cli.command(with_appcontext=False) def do_work(): ... Plugins ------- Flask will automatically load commands specified in the ``flask.commands`` `entry point`_. This is useful for extensions that want to add commands when they are installed. Entry points are specified in :file:`setup.py` :: from setuptools import setup setup( name='flask-my-extension', ..., entry_points={ 'flask.commands': [ 'my-command=flask_my_extension.commands:cli' ], }, ) .. _entry point: https://packaging.python.org/tutorials/distributing-packages/#entry-points Inside :file:`flask_my_extension/commands.py` you can then export a Click object:: import click @click.command() def cli(): ... Once that package is installed in the same virtualenv as your Flask project, you can run ``flask my-command`` to invoke the command. .. _custom-scripts: Custom Scripts -------------- When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using ``FLASK_APP`` and letting Flask load your application, you can create your own Click object and export it as a `console script`_ entry point. Create an instance of :class:`~cli.FlaskGroup` and pass it the factory:: import click from flask import Flask from flask.cli import FlaskGroup def create_app(): app = Flask('wiki') # other setup return app @click.group(cls=FlaskGroup, create_app=create_app) def cli(): \"\"\"Management script for the Wiki application.\"\"\" Define the entry point in :file:`setup.py`:: from setuptools import setup setup( name='flask-my-extension', ..., entry_points={ 'console_scripts': [ 'wiki=wiki:cli' ], }, ) Install the application in the virtualenv in editable mode and the custom script is available. Note that you don't need to set ``FLASK_APP``. :: $ pip install -e . $ wiki run .. admonition:: Errors in Custom Scripts When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point. The ``flask`` command, being separate from your code, does not have this issue and is recommended in most cases. .. _console script: https://packaging.python.org/tutorials/distributing-packages/#console-scripts PyCharm Integration ------------------- Prior to PyCharm 2018.1, the Flask CLI features weren't yet fully integrated into PyCharm. We have to do a few tweaks to get them working smoothly. These instructions should be similar for any other IDE you might want to use. In PyCharm, with your project open, click on *Run* from the menu bar and go to *Edit Configurations*. You'll be greeted by a screen similar to this: .. image:: _static/pycharm-runconfig.png :align: center :class: screenshot :alt: screenshot of pycharm's run configuration settings There's quite a few options to change, but once we've done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself. Click the + (*Add New Configuration*) button and select *Python*. Give the configuration a good descriptive name such as \"Run Flask Server\". For the ``flask run`` command, check \"Single instance only\" since you can't run the server more than once at the same time. Select *Module name* from the dropdown (**A**) then input ``flask``. The *Parameters* field (**B**) is set to the CLI command to execute (with any arguments). In this example we use ``run``, which will run the development server. You can skip this next step if you're using :ref:`dotenv`. We need to add an environment variable (**C**) to identify our application. Click on the browse button and add an entry with ``FLASK_APP`` on the left and the Python import or file on the right (``hello`` for example). Next we need to set the working directory (**D**) to be the folder where our application resides. If you have installed your project as a package in your virtualenv, you may untick the *PYTHONPATH* options (**E**). This will more accurately match how you deploy the app later. Click *Apply* to save the configuration, or *OK* to save and close the window. Select the configuration in the main PyCharm window and click the play button next to it to run the server. Now that we have a configuration which runs ``flask run`` from within PyCharm, we can copy that configuration and alter the *Script* argument to run a different CLI command, e.g. ``flask shell``.","title":"Environment Variables From dotenv"},{"location":"config/","text":"Configuration Handling \u00b6 Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things. The way Flask is designed usually requires the configuration to be available when the application starts up. You can hardcode the configuration in the code, which for many small applications is not actually that bad, but there are better ways. Independent of how you load your config, there is a config object available which holds the loaded configuration values: The :attr: ~flask.Flask.config attribute of the :class: ~flask.Flask object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration. Configuration Basics \u00b6 The :attr: ~flask.Flask.config is actually a subclass of a dictionary and can be modified just like any dictionary:: app = Flask(__name__) app.config['TESTING'] = True Certain configuration values are also forwarded to the :attr: ~flask.Flask object so you can read and write them from there:: app.testing = True To update multiple keys at once you can use the :meth: dict.update method:: app.config.update( TESTING=True, SECRET_KEY=b'_5#y2L\"F4Q8z\\n\\xec]/' ) Environment and Debug Features \u00b6 The :data: ENV and :data: DEBUG config values are special because they may behave inconsistently if changed after the app has begun setting up. In order to set the environment and debug mode reliably, Flask uses environment variables. The environment is used to indicate to Flask, extensions, and other programs, like Sentry, what context Flask is running in. It is controlled with the :envvar: FLASK_ENV environment variable and defaults to production . Setting :envvar: FLASK_ENV to development will enable debug mode. flask run will use the interactive debugger and reloader by default in debug mode. To control this separately from the environment, use the :envvar: FLASK_DEBUG flag. .. versionchanged:: 1.0 Added :envvar: FLASK_ENV to control the environment separately from debug mode. The development environment enables debug mode. To switch Flask to the development environment and enable debug mode, set :envvar: FLASK_ENV :: $ export FLASK_ENV = development $ flask run (On Windows, use set instead of export .) Using the environment variables as described above is recommended. While it is possible to set :data: ENV and :data: DEBUG in your config or code, this is strongly discouraged. They can't be read early by the flask command, and some systems or extensions may have already configured themselves based on a previous value. Builtin Configuration Values \u00b6 The following configuration values are used internally by Flask: .. py:data:: ENV What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The :attr:`~flask.Flask.env` attribute maps to this config key. This is set by the :envvar:`FLASK_ENV` environment variable and may not behave as expected if set in code. **Do not enable development when deploying in production.** Default: ``'production'`` .. versionadded:: 1.0 .. py:data:: DEBUG Whether debug mode is enabled. When using ``flask run`` to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The :attr:`~flask.Flask.debug` attribute maps to this config key. This is enabled when :data:`ENV` is ``'development'`` and is overridden by the ``FLASK_DEBUG`` environment variable. It may not behave as expected if set in code. **Do not enable debug mode when deploying in production.** Default: ``True`` if :data:`ENV` is ``'development'``, or ``False`` otherwise. .. py:data:: TESTING Enable testing mode. Exceptions are propagated rather than handled by the the app's error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests. Default: ``False`` .. py:data:: PROPAGATE_EXCEPTIONS Exceptions are re-raised rather than being handled by the app's error handlers. If not set, this is implicitly true if ``TESTING`` or ``DEBUG`` is enabled. Default: ``None`` .. py:data:: PRESERVE_CONTEXT_ON_EXCEPTION Don't pop the request context when an exception occurs. If not set, this is true if ``DEBUG`` is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly. Default: ``None`` .. py:data:: TRAP_HTTP_EXCEPTIONS If there is no handler for an ``HTTPException``-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response. Default: ``False`` .. py:data:: TRAP_BAD_REQUEST_ERRORS Trying to access a key that doesn't exist from request dicts like ``args`` and ``form`` will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of ``TRAP_HTTP_EXCEPTIONS``. If unset, it is enabled in debug mode. Default: ``None`` .. py:data:: SECRET_KEY A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application . It should be a long random string of bytes , although unicode is accepted too . For example , copy the output of this to your config :: $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' ** Do not reveal the secret key when posting questions or committing code .** Default : `` None `` .. py:data:: SESSION_COOKIE_NAME The name of the session cookie. Can be changed in case you already have a cookie with the same name. Default: ``'session'`` .. py:data:: SESSION_COOKIE_DOMAIN The domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of :data:`SERVER_NAME`. If ``False``, the cookie's domain will not be set. Default: ``None`` .. py:data:: SESSION_COOKIE_PATH The path that the session cookie will be valid for. If not set, the cookie will be valid underneath ``APPLICATION_ROOT`` or ``/`` if that is not set. Default: ``None`` .. py:data:: SESSION_COOKIE_HTTPONLY Browsers will not allow JavaScript access to cookies marked as \"HTTP only\" for security. Default: ``True`` .. py:data:: SESSION_COOKIE_SECURE Browsers will only send cookies with requests over HTTPS if the cookie is marked \"secure\". The application must be served over HTTPS for this to make sense. Default: ``False`` .. py:data:: SESSION_COOKIE_SAMESITE Restrict how cookies are sent with requests from external sites. Can be set to ``'Lax'`` (recommended) or ``'Strict'``. See :ref:`security-cookie`. Default: ``None`` .. versionadded:: 1.0 .. py:data:: PERMANENT_SESSION_LIFETIME If ``session.permanent`` is true, the cookie's expiration will be set this number of seconds in the future. Can either be a :class:`datetime.timedelta` or an ``int``. Flask's default cookie implementation validates that the cryptographic signature is not older than this value. Default: ``timedelta(days=31)`` (``2678400`` seconds) .. py:data:: SESSION_REFRESH_EACH_REQUEST Control whether the cookie is sent with every response when ``session.permanent`` is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected. Default: ``True`` .. py:data:: USE_X_SENDFILE When serving files, set the ``X-Sendfile`` header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server. Default: ``False`` .. py:data:: SEND_FILE_MAX_AGE_DEFAULT When serving files, set the cache control max age to this number of seconds. Can either be a :class:`datetime.timedelta` or an ``int``. Override this value on a per-file basis using :meth:`~flask.Flask.get_send_file_max_age` on the application or blueprint. Default: ``timedelta(hours=12)`` (``43200`` seconds) .. py:data:: SERVER_NAME Inform the application what host and port it is bound to. Required for subdomain route matching support. If set, will be used for the session cookie domain if :data:`SESSION_COOKIE_DOMAIN` is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your ``hosts`` file. :: 127.0.0.1 localhost.dev If set, ``url_for`` can generate external URLs with only an application context instead of a request context. Default: ``None`` .. py:data:: APPLICATION_ROOT Inform the application what path it is mounted under by the application / web server. Will be used for the session cookie path if ``SESSION_COOKIE_PATH`` is not set. Default: ``'/'`` .. py:data:: PREFERRED_URL_SCHEME Use this scheme for generating external URLs when not in a request context. Default: ``'http'`` .. py:data:: MAX_CONTENT_LENGTH Don't read more than this many bytes from the incoming request data. If not set and the request does not specify a ``CONTENT_LENGTH``, no data will be read for security. Default: ``None`` .. py:data:: JSON_AS_ASCII Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON will be returned as a Unicode string, or encoded as ``UTF-8`` by ``jsonify``. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled. Default: ``True`` .. py:data:: JSON_SORT_KEYS Sort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python's hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching. Default: ``True`` .. py:data:: JSONIFY_PRETTYPRINT_REGULAR ``jsonify`` responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode. Default: ``False`` .. py:data:: JSONIFY_MIMETYPE The mimetype of ``jsonify`` responses. Default: ``'application/json'`` .. py:data:: TEMPLATES_AUTO_RELOAD Reload templates when they are changed. If not set, it will be enabled in debug mode. Default: ``None`` .. py:data:: EXPLAIN_TEMPLATE_LOADING Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded. Default: ``False`` .. py:data:: MAX_COOKIE_SIZE Warn if cookie headers are larger than this many bytes. Defaults to ``4093``. Larger cookies may be silently ignored by browsers. Set to ``0`` to disable the warning. .. versionadded:: 0.4 LOGGER_NAME .. versionadded:: 0.5 SERVER_NAME .. versionadded:: 0.6 MAX_CONTENT_LENGTH .. versionadded:: 0.7 PROPAGATE_EXCEPTIONS , PRESERVE_CONTEXT_ON_EXCEPTION .. versionadded:: 0.8 TRAP_BAD_REQUEST_ERRORS , TRAP_HTTP_EXCEPTIONS , APPLICATION_ROOT , SESSION_COOKIE_DOMAIN , SESSION_COOKIE_PATH , SESSION_COOKIE_HTTPONLY , SESSION_COOKIE_SECURE .. versionadded:: 0.9 PREFERRED_URL_SCHEME .. versionadded:: 0.10 JSON_AS_ASCII , JSON_SORT_KEYS , JSONIFY_PRETTYPRINT_REGULAR .. versionadded:: 0.11 SESSION_REFRESH_EACH_REQUEST , TEMPLATES_AUTO_RELOAD , LOGGER_HANDLER_POLICY , EXPLAIN_TEMPLATE_LOADING .. versionchanged:: 1.0 LOGGER_NAME and LOGGER_HANDLER_POLICY were removed. See :ref: logging for information about configuration. Added : data : ` ENV ` to reflect the : envvar : ` FLASK_ENV ` environment variable . Added : data : ` SESSION_COOKIE_SAMESITE ` to control the session cookie ' s `` SameSite `` option . Added : data : ` MAX_COOKIE_SIZE ` to control a warning from Werkzeug . Configuring from Files \u00b6 Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (:ref: distribute-deployment ) and finally modifying the configuration file afterwards. So a common pattern is this:: app = Flask(__name__) app.config.from_object('yourapplication.default_settings') app.config.from_envvar('YOURAPPLICATION_SETTINGS') This first loads the configuration from the yourapplication.default_settings module and then overrides the values with the contents of the file the :envvar: YOURAPPLICATION_SETTINGS environment variable points to. This environment variable can be set on Linux or OS X with the export command in the shell before starting the server:: $ export YOURAPPLICATION_SETTINGS = /path/to/settings.cfg $ python run-app.py * Running on http://127.0.0.1:5000/ * Restarting with reloader... On Windows systems use the set builtin instead:: &gt; set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys. Here is an example of a configuration file:: # Example configuration DEBUG = False SECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/' Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the :class: ~flask.Config object's documentation. Configuring from Environment Variables \u00b6 In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Environment variables can be set on Linux or OS X with the export command in the shell before starting the server:: $ export SECRET_KEY = '5f352379324c22463451387a0aec5d2f' $ export DEBUG = False $ python run-app.py * Running on http://127.0.0.1:5000/ * Restarting with reloader... On Windows systems use the set builtin instead:: &gt; set SECRET_KEY='5f352379324c22463451387a0aec5d2f' &gt; set DEBUG=False While this approach is straightforward to use, it is important to remember that environment variables are strings -- they are not automatically deserialized into Python types. Here is an example of a configuration file that uses environment variables:: # Example configuration import os ENVIRONMENT_DEBUG = os . environ . get ( \"DEBUG\" , default = False ) if ENVIRONMENT_DEBUG . lower () in ( \"f\" , \"false\" ): ENVIRONMENT_DEBUG = False DEBUG = ENVIRONMENT_DEBUG SECRET_KEY = os . environ . get ( \"SECRET_KEY\" , default = None ) if not SECRET_KEY : raise ValueError ( \"No secret key set for Flask application\" ) Notice that any value besides an empty string will be interpreted as a boolean True value in Python, which requires care if an environment explicitly sets values intended to be False . Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the :class: ~flask.Config class documentation. Configuration Best Practices \u00b6 The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience: Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unittesting a lot easier. You can use this to pass in configuration as needed. Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed. Development / Production \u00b6 Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:: app = Flask(__name__) app.config.from_object('yourapplication.default_settings') app.config.from_envvar('YOURAPPLICATION_SETTINGS') Then you just have to add a separate :file: config.py file and export YOURAPPLICATION_SETTINGS=/path/to/config.py and you are done. However there are alternative ways as well. For example you could use imports or subclassing. What is very popular in the Django world is to make the import explicit in the config file by adding from yourapplication.default_settings import * to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like YOURAPPLICATION_MODE and set that to production , development etc and import different hardcoded files based on that. An interesting pattern is also to use classes and inheritance for configuration:: class Config ( object ) : DEBUG = False TESTING = False DATABASE_URI = 'sqlite:///:memory:' class ProductionConfig ( Config ) : DATABASE_URI = 'mysql://user@localhost/foo' class DevelopmentConfig ( Config ) : DEBUG = True class TestingConfig ( Config ) : TESTING = True To enable such a config you just have to call into :meth: ~flask.Config.from_object :: app.config.from_object('configmodule.ProductionConfig') Note that :meth: ~flask.Config.from_object does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling :meth: ~flask.Config.from_object :: from configmodule import ProductionConfig app . config . from_object ( ProductionConfig ()) # Alternatively, import via string: from werkzeug.utils import import_string cfg = import_string ( 'configmodule.ProductionConfig' )() app . config . from_object ( cfg ) Instantiating the configuration object allows you to use @property in your configuration classes:: class Config ( object ) : \"\"\"Base config, uses staging database server.\"\"\" DEBUG = False TESTING = False DB_SERVER = '192.168.1.56' @property def DATABASE_URI ( self ) : # Note : all caps return 'mysql://user@{}/foo' . format ( self . DB_SERVER ) class ProductionConfig ( Config ) : \"\"\"Uses production database server.\"\"\" DB_SERVER = '192.168.19.32' class DevelopmentConfig ( Config ) : DB_SERVER = 'localhost' DEBUG = True class TestingConfig ( Config ) : DB_SERVER = 'localhost' DEBUG = True DATABASE_URI = 'sqlite:///:memory:' There are many different ways and it's up to you how you want to manage your configuration files. However here a list of good recommendations: Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values. Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you. Use a tool like fabric _ in production to push code and configurations separately to the production server(s). For some details about how to do that, head over to the :ref: fabric-deployment pattern. .. _fabric: https://www.fabfile.org/ Instance Folders \u00b6 .. versionadded:: 0.8 Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application's folder directly (via :attr: Flask.root_path ). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package. With Flask 0.8 a new attribute was introduced: :attr: Flask.instance_path . It refers to a new concept called the \u201cinstance folder\u201d. The instance folder is designed to not be under version control and be deployment specific. It's the perfect place to drop things that either change at runtime or configuration files. You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the instance_path parameter:: app = Flask(__name__, instance_path='/path/to/instance/folder') Please keep in mind that this path must be absolute when provided. If the instance_path parameter is not provided the following default locations are used: Uninstalled module:: /myapp.py /instance Uninstalled package:: /myapp / init .py /instance Installed module or package:: $PREFIX/lib/python2.X/site-packages/myapp $PREFIX/var/myapp-instance $PREFIX is the prefix of your Python installation. This can be /usr or the path to your virtualenv. You can print the value of sys.prefix to see what the prefix is set to. Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between \u201crelative to the application root\u201d (the default) to \u201crelative to instance folder\u201d via the instance_relative_config switch to the application constructor:: app = Flask(__name__, instance_relative_config=True) Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:: app = Flask(__name__, instance_relative_config=True) app.config.from_object('yourapplication.default_settings') app.config.from_pyfile('application.cfg', silent=True) The path to the instance folder can be found via the :attr: Flask.instance_path . Flask also provides a shortcut to open a file from the instance folder with :meth: Flask.open_instance_resource . Example usage for both:: filename = os.path.join(app.instance_path, 'application.cfg') with open(filename) as f: config = f.read() # or via open_instance_resource: with app.open_instance_resource('application.cfg') as f: config = f.read()","title":"Configuration Handling"},{"location":"config/#configuration-handling","text":"Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things. The way Flask is designed usually requires the configuration to be available when the application starts up. You can hardcode the configuration in the code, which for many small applications is not actually that bad, but there are better ways. Independent of how you load your config, there is a config object available which holds the loaded configuration values: The :attr: ~flask.Flask.config attribute of the :class: ~flask.Flask object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration.","title":"Configuration Handling"},{"location":"config/#configuration-basics","text":"The :attr: ~flask.Flask.config is actually a subclass of a dictionary and can be modified just like any dictionary:: app = Flask(__name__) app.config['TESTING'] = True Certain configuration values are also forwarded to the :attr: ~flask.Flask object so you can read and write them from there:: app.testing = True To update multiple keys at once you can use the :meth: dict.update method:: app.config.update( TESTING=True, SECRET_KEY=b'_5#y2L\"F4Q8z\\n\\xec]/' )","title":"Configuration Basics"},{"location":"config/#environment-and-debug-features","text":"The :data: ENV and :data: DEBUG config values are special because they may behave inconsistently if changed after the app has begun setting up. In order to set the environment and debug mode reliably, Flask uses environment variables. The environment is used to indicate to Flask, extensions, and other programs, like Sentry, what context Flask is running in. It is controlled with the :envvar: FLASK_ENV environment variable and defaults to production . Setting :envvar: FLASK_ENV to development will enable debug mode. flask run will use the interactive debugger and reloader by default in debug mode. To control this separately from the environment, use the :envvar: FLASK_DEBUG flag. .. versionchanged:: 1.0 Added :envvar: FLASK_ENV to control the environment separately from debug mode. The development environment enables debug mode. To switch Flask to the development environment and enable debug mode, set :envvar: FLASK_ENV :: $ export FLASK_ENV = development $ flask run (On Windows, use set instead of export .) Using the environment variables as described above is recommended. While it is possible to set :data: ENV and :data: DEBUG in your config or code, this is strongly discouraged. They can't be read early by the flask command, and some systems or extensions may have already configured themselves based on a previous value.","title":"Environment and Debug Features"},{"location":"config/#builtin-configuration-values","text":"The following configuration values are used internally by Flask: .. py:data:: ENV What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The :attr:`~flask.Flask.env` attribute maps to this config key. This is set by the :envvar:`FLASK_ENV` environment variable and may not behave as expected if set in code. **Do not enable development when deploying in production.** Default: ``'production'`` .. versionadded:: 1.0 .. py:data:: DEBUG Whether debug mode is enabled. When using ``flask run`` to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The :attr:`~flask.Flask.debug` attribute maps to this config key. This is enabled when :data:`ENV` is ``'development'`` and is overridden by the ``FLASK_DEBUG`` environment variable. It may not behave as expected if set in code. **Do not enable debug mode when deploying in production.** Default: ``True`` if :data:`ENV` is ``'development'``, or ``False`` otherwise. .. py:data:: TESTING Enable testing mode. Exceptions are propagated rather than handled by the the app's error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests. Default: ``False`` .. py:data:: PROPAGATE_EXCEPTIONS Exceptions are re-raised rather than being handled by the app's error handlers. If not set, this is implicitly true if ``TESTING`` or ``DEBUG`` is enabled. Default: ``None`` .. py:data:: PRESERVE_CONTEXT_ON_EXCEPTION Don't pop the request context when an exception occurs. If not set, this is true if ``DEBUG`` is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly. Default: ``None`` .. py:data:: TRAP_HTTP_EXCEPTIONS If there is no handler for an ``HTTPException``-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response. Default: ``False`` .. py:data:: TRAP_BAD_REQUEST_ERRORS Trying to access a key that doesn't exist from request dicts like ``args`` and ``form`` will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of ``TRAP_HTTP_EXCEPTIONS``. If unset, it is enabled in debug mode. Default: ``None`` .. py:data:: SECRET_KEY A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application . It should be a long random string of bytes , although unicode is accepted too . For example , copy the output of this to your config :: $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' ** Do not reveal the secret key when posting questions or committing code .** Default : `` None `` .. py:data:: SESSION_COOKIE_NAME The name of the session cookie. Can be changed in case you already have a cookie with the same name. Default: ``'session'`` .. py:data:: SESSION_COOKIE_DOMAIN The domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of :data:`SERVER_NAME`. If ``False``, the cookie's domain will not be set. Default: ``None`` .. py:data:: SESSION_COOKIE_PATH The path that the session cookie will be valid for. If not set, the cookie will be valid underneath ``APPLICATION_ROOT`` or ``/`` if that is not set. Default: ``None`` .. py:data:: SESSION_COOKIE_HTTPONLY Browsers will not allow JavaScript access to cookies marked as \"HTTP only\" for security. Default: ``True`` .. py:data:: SESSION_COOKIE_SECURE Browsers will only send cookies with requests over HTTPS if the cookie is marked \"secure\". The application must be served over HTTPS for this to make sense. Default: ``False`` .. py:data:: SESSION_COOKIE_SAMESITE Restrict how cookies are sent with requests from external sites. Can be set to ``'Lax'`` (recommended) or ``'Strict'``. See :ref:`security-cookie`. Default: ``None`` .. versionadded:: 1.0 .. py:data:: PERMANENT_SESSION_LIFETIME If ``session.permanent`` is true, the cookie's expiration will be set this number of seconds in the future. Can either be a :class:`datetime.timedelta` or an ``int``. Flask's default cookie implementation validates that the cryptographic signature is not older than this value. Default: ``timedelta(days=31)`` (``2678400`` seconds) .. py:data:: SESSION_REFRESH_EACH_REQUEST Control whether the cookie is sent with every response when ``session.permanent`` is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected. Default: ``True`` .. py:data:: USE_X_SENDFILE When serving files, set the ``X-Sendfile`` header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server. Default: ``False`` .. py:data:: SEND_FILE_MAX_AGE_DEFAULT When serving files, set the cache control max age to this number of seconds. Can either be a :class:`datetime.timedelta` or an ``int``. Override this value on a per-file basis using :meth:`~flask.Flask.get_send_file_max_age` on the application or blueprint. Default: ``timedelta(hours=12)`` (``43200`` seconds) .. py:data:: SERVER_NAME Inform the application what host and port it is bound to. Required for subdomain route matching support. If set, will be used for the session cookie domain if :data:`SESSION_COOKIE_DOMAIN` is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your ``hosts`` file. :: 127.0.0.1 localhost.dev If set, ``url_for`` can generate external URLs with only an application context instead of a request context. Default: ``None`` .. py:data:: APPLICATION_ROOT Inform the application what path it is mounted under by the application / web server. Will be used for the session cookie path if ``SESSION_COOKIE_PATH`` is not set. Default: ``'/'`` .. py:data:: PREFERRED_URL_SCHEME Use this scheme for generating external URLs when not in a request context. Default: ``'http'`` .. py:data:: MAX_CONTENT_LENGTH Don't read more than this many bytes from the incoming request data. If not set and the request does not specify a ``CONTENT_LENGTH``, no data will be read for security. Default: ``None`` .. py:data:: JSON_AS_ASCII Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON will be returned as a Unicode string, or encoded as ``UTF-8`` by ``jsonify``. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled. Default: ``True`` .. py:data:: JSON_SORT_KEYS Sort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python's hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching. Default: ``True`` .. py:data:: JSONIFY_PRETTYPRINT_REGULAR ``jsonify`` responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode. Default: ``False`` .. py:data:: JSONIFY_MIMETYPE The mimetype of ``jsonify`` responses. Default: ``'application/json'`` .. py:data:: TEMPLATES_AUTO_RELOAD Reload templates when they are changed. If not set, it will be enabled in debug mode. Default: ``None`` .. py:data:: EXPLAIN_TEMPLATE_LOADING Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded. Default: ``False`` .. py:data:: MAX_COOKIE_SIZE Warn if cookie headers are larger than this many bytes. Defaults to ``4093``. Larger cookies may be silently ignored by browsers. Set to ``0`` to disable the warning. .. versionadded:: 0.4 LOGGER_NAME .. versionadded:: 0.5 SERVER_NAME .. versionadded:: 0.6 MAX_CONTENT_LENGTH .. versionadded:: 0.7 PROPAGATE_EXCEPTIONS , PRESERVE_CONTEXT_ON_EXCEPTION .. versionadded:: 0.8 TRAP_BAD_REQUEST_ERRORS , TRAP_HTTP_EXCEPTIONS , APPLICATION_ROOT , SESSION_COOKIE_DOMAIN , SESSION_COOKIE_PATH , SESSION_COOKIE_HTTPONLY , SESSION_COOKIE_SECURE .. versionadded:: 0.9 PREFERRED_URL_SCHEME .. versionadded:: 0.10 JSON_AS_ASCII , JSON_SORT_KEYS , JSONIFY_PRETTYPRINT_REGULAR .. versionadded:: 0.11 SESSION_REFRESH_EACH_REQUEST , TEMPLATES_AUTO_RELOAD , LOGGER_HANDLER_POLICY , EXPLAIN_TEMPLATE_LOADING .. versionchanged:: 1.0 LOGGER_NAME and LOGGER_HANDLER_POLICY were removed. See :ref: logging for information about configuration. Added : data : ` ENV ` to reflect the : envvar : ` FLASK_ENV ` environment variable . Added : data : ` SESSION_COOKIE_SAMESITE ` to control the session cookie ' s `` SameSite `` option . Added : data : ` MAX_COOKIE_SIZE ` to control a warning from Werkzeug .","title":"Builtin Configuration Values"},{"location":"config/#configuring-from-files","text":"Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (:ref: distribute-deployment ) and finally modifying the configuration file afterwards. So a common pattern is this:: app = Flask(__name__) app.config.from_object('yourapplication.default_settings') app.config.from_envvar('YOURAPPLICATION_SETTINGS') This first loads the configuration from the yourapplication.default_settings module and then overrides the values with the contents of the file the :envvar: YOURAPPLICATION_SETTINGS environment variable points to. This environment variable can be set on Linux or OS X with the export command in the shell before starting the server:: $ export YOURAPPLICATION_SETTINGS = /path/to/settings.cfg $ python run-app.py * Running on http://127.0.0.1:5000/ * Restarting with reloader... On Windows systems use the set builtin instead:: &gt; set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys. Here is an example of a configuration file:: # Example configuration DEBUG = False SECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/' Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the :class: ~flask.Config object's documentation.","title":"Configuring from Files"},{"location":"config/#configuring-from-environment-variables","text":"In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Environment variables can be set on Linux or OS X with the export command in the shell before starting the server:: $ export SECRET_KEY = '5f352379324c22463451387a0aec5d2f' $ export DEBUG = False $ python run-app.py * Running on http://127.0.0.1:5000/ * Restarting with reloader... On Windows systems use the set builtin instead:: &gt; set SECRET_KEY='5f352379324c22463451387a0aec5d2f' &gt; set DEBUG=False While this approach is straightforward to use, it is important to remember that environment variables are strings -- they are not automatically deserialized into Python types. Here is an example of a configuration file that uses environment variables:: # Example configuration import os ENVIRONMENT_DEBUG = os . environ . get ( \"DEBUG\" , default = False ) if ENVIRONMENT_DEBUG . lower () in ( \"f\" , \"false\" ): ENVIRONMENT_DEBUG = False DEBUG = ENVIRONMENT_DEBUG SECRET_KEY = os . environ . get ( \"SECRET_KEY\" , default = None ) if not SECRET_KEY : raise ValueError ( \"No secret key set for Flask application\" ) Notice that any value besides an empty string will be interpreted as a boolean True value in Python, which requires care if an environment explicitly sets values intended to be False . Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the :class: ~flask.Config class documentation.","title":"Configuring from Environment Variables"},{"location":"config/#configuration-best-practices","text":"The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience: Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unittesting a lot easier. You can use this to pass in configuration as needed. Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.","title":"Configuration Best Practices"},{"location":"config/#development-production","text":"Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:: app = Flask(__name__) app.config.from_object('yourapplication.default_settings') app.config.from_envvar('YOURAPPLICATION_SETTINGS') Then you just have to add a separate :file: config.py file and export YOURAPPLICATION_SETTINGS=/path/to/config.py and you are done. However there are alternative ways as well. For example you could use imports or subclassing. What is very popular in the Django world is to make the import explicit in the config file by adding from yourapplication.default_settings import * to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like YOURAPPLICATION_MODE and set that to production , development etc and import different hardcoded files based on that. An interesting pattern is also to use classes and inheritance for configuration:: class Config ( object ) : DEBUG = False TESTING = False DATABASE_URI = 'sqlite:///:memory:' class ProductionConfig ( Config ) : DATABASE_URI = 'mysql://user@localhost/foo' class DevelopmentConfig ( Config ) : DEBUG = True class TestingConfig ( Config ) : TESTING = True To enable such a config you just have to call into :meth: ~flask.Config.from_object :: app.config.from_object('configmodule.ProductionConfig') Note that :meth: ~flask.Config.from_object does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling :meth: ~flask.Config.from_object :: from configmodule import ProductionConfig app . config . from_object ( ProductionConfig ()) # Alternatively, import via string: from werkzeug.utils import import_string cfg = import_string ( 'configmodule.ProductionConfig' )() app . config . from_object ( cfg ) Instantiating the configuration object allows you to use @property in your configuration classes:: class Config ( object ) : \"\"\"Base config, uses staging database server.\"\"\" DEBUG = False TESTING = False DB_SERVER = '192.168.1.56' @property def DATABASE_URI ( self ) : # Note : all caps return 'mysql://user@{}/foo' . format ( self . DB_SERVER ) class ProductionConfig ( Config ) : \"\"\"Uses production database server.\"\"\" DB_SERVER = '192.168.19.32' class DevelopmentConfig ( Config ) : DB_SERVER = 'localhost' DEBUG = True class TestingConfig ( Config ) : DB_SERVER = 'localhost' DEBUG = True DATABASE_URI = 'sqlite:///:memory:' There are many different ways and it's up to you how you want to manage your configuration files. However here a list of good recommendations: Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values. Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you. Use a tool like fabric _ in production to push code and configurations separately to the production server(s). For some details about how to do that, head over to the :ref: fabric-deployment pattern. .. _fabric: https://www.fabfile.org/","title":"Development / Production"},{"location":"config/#instance-folders","text":".. versionadded:: 0.8 Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application's folder directly (via :attr: Flask.root_path ). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package. With Flask 0.8 a new attribute was introduced: :attr: Flask.instance_path . It refers to a new concept called the \u201cinstance folder\u201d. The instance folder is designed to not be under version control and be deployment specific. It's the perfect place to drop things that either change at runtime or configuration files. You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the instance_path parameter:: app = Flask(__name__, instance_path='/path/to/instance/folder') Please keep in mind that this path must be absolute when provided. If the instance_path parameter is not provided the following default locations are used: Uninstalled module:: /myapp.py /instance Uninstalled package:: /myapp / init .py /instance Installed module or package:: $PREFIX/lib/python2.X/site-packages/myapp $PREFIX/var/myapp-instance $PREFIX is the prefix of your Python installation. This can be /usr or the path to your virtualenv. You can print the value of sys.prefix to see what the prefix is set to. Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between \u201crelative to the application root\u201d (the default) to \u201crelative to instance folder\u201d via the instance_relative_config switch to the application constructor:: app = Flask(__name__, instance_relative_config=True) Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:: app = Flask(__name__, instance_relative_config=True) app.config.from_object('yourapplication.default_settings') app.config.from_pyfile('application.cfg', silent=True) The path to the instance folder can be found via the :attr: Flask.instance_path . Flask also provides a shortcut to open a file from the instance folder with :meth: Flask.open_instance_resource . Example usage for both:: filename = os.path.join(app.instance_path, 'application.cfg') with open(filename) as f: config = f.read() # or via open_instance_resource: with app.open_instance_resource('application.cfg') as f: config = f.read()","title":"Instance Folders"},{"location":"contributing/","text":".. include:: ../CONTRIBUTING.rst","title":"Contributing"},{"location":"design/","text":"Design Decisions in Flask \u00b6 If you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks. The Explicit Application Object \u00b6 A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the :class: ~flask.Flask class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can't Flask do that itself? Without such an explicit application object the following code:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def index (): return 'Hello World!' Would look like this instead:: from hypothetical_flask import route @route ( '/' ) def index (): return 'Hello World!' There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won't outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unittesting. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again. Another thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class (:class: ~flask.Flask ) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you. But there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it __name__ as package name. Flask depends on that information to properly load resources relative to your module. With Python's outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see :meth: ~flask.Flask.open_resource ). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder. The third reason is \"explicit is better than implicit\". That object is your WSGI application, you don't have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you're done (though there are better ways to do that so that you do not lose the reference to the application object :meth: ~flask.Flask.wsgi_app ). Furthermore this design makes it possible to use a factory function to create the application which is very helpful for unittesting and similar things (:ref: app-factories ). The Routing System \u00b6 Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules. Another design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous. One Template Engine \u00b6 Flask decides on one template engine: Jinja2. Why doesn't Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is always configured will probably go away, the decision to bundle one template engine and use that will not. Template engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string. But that's about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, uses Unicode for all operations, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules. When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2's extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates. A template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask. Furthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself. Micro with Dependencies \u00b6 Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn't it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it's called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it's sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage. Flask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others. Thread Locals \u00b6 Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (:data: ~flask.g ). Why is that and isn't that a bad idea? Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application. Also see the :ref: becomingbig section of the documentation for some inspiration for larger applications based on Flask. What Flask is, What Flask is Not \u00b6 Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions. Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database. The idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions.","title":"Design Decisions in Flask"},{"location":"design/#design-decisions-in-flask","text":"If you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks.","title":"Design Decisions in Flask"},{"location":"design/#the-explicit-application-object","text":"A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the :class: ~flask.Flask class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can't Flask do that itself? Without such an explicit application object the following code:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def index (): return 'Hello World!' Would look like this instead:: from hypothetical_flask import route @route ( '/' ) def index (): return 'Hello World!' There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won't outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unittesting. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again. Another thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class (:class: ~flask.Flask ) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you. But there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it __name__ as package name. Flask depends on that information to properly load resources relative to your module. With Python's outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see :meth: ~flask.Flask.open_resource ). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder. The third reason is \"explicit is better than implicit\". That object is your WSGI application, you don't have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you're done (though there are better ways to do that so that you do not lose the reference to the application object :meth: ~flask.Flask.wsgi_app ). Furthermore this design makes it possible to use a factory function to create the application which is very helpful for unittesting and similar things (:ref: app-factories ).","title":"The Explicit Application Object"},{"location":"design/#the-routing-system","text":"Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules. Another design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous.","title":"The Routing System"},{"location":"design/#one-template-engine","text":"Flask decides on one template engine: Jinja2. Why doesn't Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is always configured will probably go away, the decision to bundle one template engine and use that will not. Template engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string. But that's about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, uses Unicode for all operations, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules. When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2's extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates. A template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask. Furthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself.","title":"One Template Engine"},{"location":"design/#micro-with-dependencies","text":"Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn't it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it's called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it's sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage. Flask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others.","title":"Micro with Dependencies"},{"location":"design/#thread-locals","text":"Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (:data: ~flask.g ). Why is that and isn't that a bad idea? Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application. Also see the :ref: becomingbig section of the documentation for some inspiration for larger applications based on Flask.","title":"Thread Locals"},{"location":"design/#what-flask-is-what-flask-is-not","text":"Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions. Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database. The idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions.","title":"What Flask is, What Flask is Not"},{"location":"errorhandling/","text":"Application Errors \u00b6 .. versionadded:: 0.3 Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors: the client terminated the request early and the application was still reading from the incoming data the database server was overloaded and could not handle the query a filesystem is full a harddrive crashed a backend server overloaded a programming error in a library you are using network connection of the server to another system failed And that's just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, Flask will display a very simple page for you and log the exception to the :attr: ~flask.Flask.logger . But there is more you can do, and we will cover some better setups to deal with errors. Error Logging Tools \u00b6 Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using Sentry <https://sentry.io/> for dealing with application errors. It's available as an Open Source project on GitHub <https://github.com/getsentry/sentry> and is also available as a hosted version <https://sentry.io/signup/> _ which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds. To use Sentry you need to install the sentry-sdk client with extra flask dependencies:: $ pip install sentry-sdk [ flask ] And then add this to your Flask app:: import sentry_sdk from sentry_sdk.integrations.flask import FlaskIntegration sentry_sdk . init ( 'YOUR_DSN_HERE' , integrations = [ FlaskIntegration ()]) The YOUR_DSN_HERE value needs to be replaced with the DSN value you get from your Sentry installation. After installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications. Follow-up reads: Sentry also supports catching errors from your worker queue (RQ, Celery) in a similar fashion. See the Python SDK docs <https://docs.sentry.io/platforms/python/> _ for more information. Getting started with Sentry <https://docs.sentry.io/quickstart/?platform=python> _ Flask-specific documentation <https://docs.sentry.io/platforms/python/flask/> _. Error handlers \u00b6 You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. An error handler is a normal view function that returns a response, but instead of being registered for a route, it is registered for an exception or HTTP status code that would be raised while trying to handle a request. Registering Register handlers by decorating a function with :meth:`~flask.Flask.errorhandler`. Or use :meth:`~flask.Flask.register_error_handler` to register the function later. Remember to set the error code when returning the response. :: @app.errorhandler(werkzeug.exceptions.BadRequest) def handle_bad_request(e): return 'bad request!', 400 # or, without the decorator app.register_error_handler(400, handle_bad_request) :exc:`werkzeug.exceptions.HTTPException` subclasses like :exc:`~werkzeug.exceptions.BadRequest` and their HTTP codes are interchangeable when registering handlers. (``BadRequest.code == 400``) Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of :class:`~werkzeug.exceptions.HTTPException` with the appropriate code and register and raise that exception class. :: class InsufficientStorage(werkzeug.exceptions.HTTPException): code = 507 description = 'Not enough storage space.' app.register_error_handler(InsufficientStorage, handle_507) raise InsufficientStorage() Handlers can be registered for any exception class, not just :exc:`~werkzeug.exceptions.HTTPException` subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class. Handling ```````` When an exception is caught by Flask while handling a request, it is first looked up by code. If no handler is registered for the code, it is looked up by its class hierarchy; the most specific handler is chosen. If no handler is registered, :class:`~werkzeug.exceptions.HTTPException` subclasses show a generic message about their code, while other exceptions are converted to a generic 500 Internal Server Error. For example, if an instance of :exc:`ConnectionRefusedError` is raised, and a handler is registered for :exc:`ConnectionError` and :exc:`ConnectionRefusedError`, the more specific :exc:`ConnectionRefusedError` handler is called with the exception instance to generate the response. Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined. .. versionchanged:: 0.11 Handlers are prioritized by specificity of the exception classes they are registered for instead of the order they are registered in. Logging ------- See :ref:`logging` for information on how to log exceptions, such as by emailing them to admins. Debugging Application Errors ============================ For production applications, configure your application with logging and notifications as described in :ref:`application-errors`. This section provides pointers when debugging deployment configuration and digging deeper with a full-featured Python debugger. When in Doubt, Run Manually --------------------------- Having problems getting your application configured for production? If you have shell access to your host, verify that you can run your application manually from the shell in the deployment environment. Be sure to run under the same user account as the configured deployment to troubleshoot permission issues. You can use Flask's builtin development server with `debug=True` on your production host, which is helpful in catching configuration issues, but **be sure to do this temporarily in a controlled environment.** Do not run in production with `debug=True`. .. _working-with-debuggers: Working with Debuggers ---------------------- To dig deeper, possibly to trace code execution, Flask provides a debugger out of the box (see :ref:`debug-mode`). If you would like to use another Python debugger, note that debuggers interfere with each other. You have to set some options in order to use your favorite debugger: * ``debug`` - whether to enable debug mode and catch exceptions * ``use_debugger`` - whether to use the internal Flask debugger * ``use_reloader`` - whether to reload and fork the process if modules were changed ``debug`` must be True (i.e., exceptions must be caught) in order for the other two options to have any value. If you're using Aptana/Eclipse for debugging you'll need to set both ``use_debugger`` and ``use_reloader`` to False. A possible useful pattern for configuration is to set the following in your config.yaml (change the block as appropriate for your application, of course):: FLASK: DEBUG: True DEBUG_WITH_APTANA: True Then in your application's entry-point (main.py), you could have something like:: if __name__ == \"__main__\": # To allow aptana to receive errors, set use_debugger=False app = create_app(config=\"config.yaml\") use_debugger = app.debug and not(app.config.get('DEBUG_WITH_APTANA')) app.run(use_debugger=use_debugger, debug=app.debug, use_reloader=use_debugger, host='0.0.0.0')","title":"Application Errors"},{"location":"errorhandling/#application-errors","text":".. versionadded:: 0.3 Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors: the client terminated the request early and the application was still reading from the incoming data the database server was overloaded and could not handle the query a filesystem is full a harddrive crashed a backend server overloaded a programming error in a library you are using network connection of the server to another system failed And that's just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, Flask will display a very simple page for you and log the exception to the :attr: ~flask.Flask.logger . But there is more you can do, and we will cover some better setups to deal with errors.","title":"Application Errors"},{"location":"errorhandling/#error-logging-tools","text":"Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using Sentry <https://sentry.io/> for dealing with application errors. It's available as an Open Source project on GitHub <https://github.com/getsentry/sentry> and is also available as a hosted version <https://sentry.io/signup/> _ which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds. To use Sentry you need to install the sentry-sdk client with extra flask dependencies:: $ pip install sentry-sdk [ flask ] And then add this to your Flask app:: import sentry_sdk from sentry_sdk.integrations.flask import FlaskIntegration sentry_sdk . init ( 'YOUR_DSN_HERE' , integrations = [ FlaskIntegration ()]) The YOUR_DSN_HERE value needs to be replaced with the DSN value you get from your Sentry installation. After installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications. Follow-up reads: Sentry also supports catching errors from your worker queue (RQ, Celery) in a similar fashion. See the Python SDK docs <https://docs.sentry.io/platforms/python/> _ for more information. Getting started with Sentry <https://docs.sentry.io/quickstart/?platform=python> _ Flask-specific documentation <https://docs.sentry.io/platforms/python/flask/> _.","title":"Error Logging Tools"},{"location":"errorhandling/#error-handlers","text":"You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. An error handler is a normal view function that returns a response, but instead of being registered for a route, it is registered for an exception or HTTP status code that would be raised while trying to handle a request. Registering Register handlers by decorating a function with :meth:`~flask.Flask.errorhandler`. Or use :meth:`~flask.Flask.register_error_handler` to register the function later. Remember to set the error code when returning the response. :: @app.errorhandler(werkzeug.exceptions.BadRequest) def handle_bad_request(e): return 'bad request!', 400 # or, without the decorator app.register_error_handler(400, handle_bad_request) :exc:`werkzeug.exceptions.HTTPException` subclasses like :exc:`~werkzeug.exceptions.BadRequest` and their HTTP codes are interchangeable when registering handlers. (``BadRequest.code == 400``) Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of :class:`~werkzeug.exceptions.HTTPException` with the appropriate code and register and raise that exception class. :: class InsufficientStorage(werkzeug.exceptions.HTTPException): code = 507 description = 'Not enough storage space.' app.register_error_handler(InsufficientStorage, handle_507) raise InsufficientStorage() Handlers can be registered for any exception class, not just :exc:`~werkzeug.exceptions.HTTPException` subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class. Handling ```````` When an exception is caught by Flask while handling a request, it is first looked up by code. If no handler is registered for the code, it is looked up by its class hierarchy; the most specific handler is chosen. If no handler is registered, :class:`~werkzeug.exceptions.HTTPException` subclasses show a generic message about their code, while other exceptions are converted to a generic 500 Internal Server Error. For example, if an instance of :exc:`ConnectionRefusedError` is raised, and a handler is registered for :exc:`ConnectionError` and :exc:`ConnectionRefusedError`, the more specific :exc:`ConnectionRefusedError` handler is called with the exception instance to generate the response. Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined. .. versionchanged:: 0.11 Handlers are prioritized by specificity of the exception classes they are registered for instead of the order they are registered in. Logging ------- See :ref:`logging` for information on how to log exceptions, such as by emailing them to admins. Debugging Application Errors ============================ For production applications, configure your application with logging and notifications as described in :ref:`application-errors`. This section provides pointers when debugging deployment configuration and digging deeper with a full-featured Python debugger. When in Doubt, Run Manually --------------------------- Having problems getting your application configured for production? If you have shell access to your host, verify that you can run your application manually from the shell in the deployment environment. Be sure to run under the same user account as the configured deployment to troubleshoot permission issues. You can use Flask's builtin development server with `debug=True` on your production host, which is helpful in catching configuration issues, but **be sure to do this temporarily in a controlled environment.** Do not run in production with `debug=True`. .. _working-with-debuggers: Working with Debuggers ---------------------- To dig deeper, possibly to trace code execution, Flask provides a debugger out of the box (see :ref:`debug-mode`). If you would like to use another Python debugger, note that debuggers interfere with each other. You have to set some options in order to use your favorite debugger: * ``debug`` - whether to enable debug mode and catch exceptions * ``use_debugger`` - whether to use the internal Flask debugger * ``use_reloader`` - whether to reload and fork the process if modules were changed ``debug`` must be True (i.e., exceptions must be caught) in order for the other two options to have any value. If you're using Aptana/Eclipse for debugging you'll need to set both ``use_debugger`` and ``use_reloader`` to False. A possible useful pattern for configuration is to set the following in your config.yaml (change the block as appropriate for your application, of course):: FLASK: DEBUG: True DEBUG_WITH_APTANA: True Then in your application's entry-point (main.py), you could have something like:: if __name__ == \"__main__\": # To allow aptana to receive errors, set use_debugger=False app = create_app(config=\"config.yaml\") use_debugger = app.debug and not(app.config.get('DEBUG_WITH_APTANA')) app.run(use_debugger=use_debugger, debug=app.debug, use_reloader=use_debugger, host='0.0.0.0')","title":"Error handlers"},{"location":"extensiondev/","text":"Flask Extension Development \u00b6 Flask, being a microframework, often requires some repetitive steps to get a third party library working. Because very often these steps could be abstracted to support multiple projects the Flask Extension Registry _ was created. If you want to create your own Flask extension for something that does not exist yet, this guide to extension development will help you get your extension running in no time and to feel like users would expect your extension to behave. .. _Flask Extension Registry: http://flask.pocoo.org/extensions/ Anatomy of an Extension \u00b6 Extensions are all located in a package called flask_something where \"something\" is the name of the library you want to bridge. So for example if you plan to add support for a library named simplexml to Flask, you would name your extension's package flask_simplexml . The name of the actual extension (the human readable name) however would be something like \"Flask-SimpleXML\". Make sure to include the name \"Flask\" somewhere in that name and that you check the capitalization. This is how users can then register dependencies to your extension in their :file: setup.py files. But what do extensions look like themselves? An extension has to ensure that it works with multiple Flask application instances at once. This is a requirement because many people will use patterns like the :ref: app-factories pattern to create their application as needed to aid unittests and to support multiple configurations. Because of that it is crucial that your application supports that kind of behavior. Most importantly the extension must be shipped with a :file: setup.py file and registered on PyPI. Also the development checkout link should work so that people can easily install the development version into their virtualenv without having to download the library by hand. Flask extensions must be licensed under a BSD, MIT or more liberal license in order to be listed in the Flask Extension Registry. Keep in mind that the Flask Extension Registry is a moderated place and libraries will be reviewed upfront if they behave as required. \"Hello Flaskext!\" \u00b6 So let's get started with creating such a Flask extension. The extension we want to create here will provide very basic support for SQLite3. First we create the following folder structure:: flask-sqlite3/ flask_sqlite3.py LICENSE README Here's the contents of the most important files: setup.py The next file that is absolutely required is the : file : `setup.py` file which is used to install your Flask extension . The following contents are something you can work with :: \"\"\" Flask-SQLite3 ------------- This is the description for that library \"\"\" from setuptools import setup setup ( name = 'Flask-SQLite3' , version = '1.0' , url = 'http://example.com/flask-sqlite3/' , license = 'BSD' , author = 'Your Name' , author_email = 'your-email@example.com' , description = 'Very short description' , long_description = __doc__ , py_modules = [ 'flask_sqlite3' ], # if you would be using a package instead use packages instead # of py_modules: # packages=['flask_sqlite3'], zip_safe = False , include_package_data = True , platforms = 'any' , install_requires = [ 'Flask' ], classifiers = [ 'Environment :: Web Environment' , 'Intended Audience :: Developers' , 'License :: OSI Approved :: BSD License' , 'Operating System :: OS Independent' , 'Programming Language :: Python' , 'Topic :: Internet :: WWW/HTTP :: Dynamic Content' , 'Topic :: Software Development :: Libraries :: Python Modules' ] ) That 's a lot of code but you can really just copy/paste that from existing extensions and adapt . flask_sqlite3 . py Now this is where your extension code goes. But how exactly should such an extension look like? What are the best practices? Continue reading for some insight. Initializing Extensions \u00b6 Many extensions will need some kind of initialization step. For example, consider an application that's currently connecting to SQLite like the documentation suggests (:ref: sqlite3 ). So how does the extension know the name of the application object? Quite simple: you pass it to it. There are two recommended ways for an extension to initialize: initialization functions: If your extension is called `helloworld` you might have a function called ``init_helloworld(app[, extra_args])`` that initializes the extension for that application. It could attach before / after handlers etc. classes: Classes work mostly like initialization functions but can later be used to further change the behavior. For an example look at how the `OAuth extension`_ works: there is an `OAuth` object that provides some helper functions like `OAuth.remote_app` to create a reference to a remote application that uses OAuth. What to use depends on what you have in mind. For the SQLite 3 extension we will use the class-based approach because it will provide users with an object that handles opening and closing database connections. When designing your classes, it's important to make them easily reusable at the module level. This means the object itself must not under any circumstances store any application specific state and must be shareable between different applications. The Extension Code \u00b6 Here's the contents of the flask_sqlite3.py for copy/paste:: import sqlite3 from flask import current_app , _app_ctx_stack class SQLite3 ( object ): def __init__ ( self , app = None ): self . app = app if app is not None : self . init_app ( app ) def init_app ( self , app ): app . config . setdefault ( 'SQLITE3_DATABASE' , ':memory:' ) app . teardown_appcontext ( self . teardown ) def connect ( self ): return sqlite3 . connect ( current_app . config [ 'SQLITE3_DATABASE' ]) def teardown ( self , exception ): ctx = _app_ctx_stack . top if hasattr ( ctx , 'sqlite3_db' ): ctx . sqlite3_db . close () @property def connection ( self ): ctx = _app_ctx_stack . top if ctx is not None : if not hasattr ( ctx , 'sqlite3_db' ): ctx . sqlite3_db = self . connect () return ctx . sqlite3_db So here's what these lines of code do: The __init__ method takes an optional app object and, if supplied, will call init_app . The init_app method exists so that the SQLite3 object can be instantiated without requiring an app object. This method supports the factory pattern for creating applications. The init_app will set the configuration for the database, defaulting to an in memory database if no configuration is supplied. In addition, the init_app method attaches the teardown handler. Next, we define a connect method that opens a database connection. Finally, we add a connection property that on first access opens the database connection and stores it on the context. This is also the recommended way to handling resources: fetch resources lazily the first time they are used. Note here that we're attaching our database connection to the top application context via _app_ctx_stack.top . Extensions should use the top context for storing their own information with a sufficiently complex name. So why did we decide on a class-based approach here? Because using our extension looks something like this:: from flask import Flask from flask_sqlite3 import SQLite3 app = Flask ( __name__ ) app . config . from_pyfile ( 'the-config.cfg' ) db = SQLite3 ( app ) You can then use the database from views like this:: @app.route('/') def show_all(): cur = db.connection.cursor() cur.execute(...) Likewise if you are outside of a request you can use the database by pushing an app context:: with app.app_context(): cur = db.connection.cursor() cur.execute(...) At the end of the with block the teardown handles will be executed automatically. Additionally, the init_app method is used to support the factory pattern for creating apps:: db = SQLite3() # Then later on. app = create_app('the-config.cfg') db.init_app(app) Keep in mind that supporting this factory pattern for creating apps is required for approved flask extensions (described below). .. admonition:: Note on init_app As you noticed, init_app does not assign app to self . This is intentional! Class based Flask extensions must only store the application on the object when the application was passed to the constructor. This tells the extension: I am not interested in using multiple applications. When the extension needs to find the current application and it does not have a reference to it, it must either use the :data: ~flask.current_app context local or change the API in a way that you can pass the application explicitly. Using _app_ctx_stack \u00b6 In the example above, before every request, a sqlite3_db variable is assigned to _app_ctx_stack.top . In a view function, this variable is accessible using the connection property of SQLite3 . During the teardown of a request, the sqlite3_db connection is closed. By using this pattern, the same connection to the sqlite3 database is accessible to anything that needs it for the duration of the request. Learn from Others \u00b6 This documentation only touches the bare minimum for extension development. If you want to learn more, it's a very good idea to check out existing extensions on the Flask Extension Registry . If you feel lost there is still the mailinglist and the IRC channel _ to get some ideas for nice looking APIs. Especially if you do something nobody before you did, it might be a very good idea to get some more input. This not only generates useful feedback on what people might want from an extension, but also avoids having multiple developers working in isolation on pretty much the same problem. Remember: good API design is hard, so introduce your project on the mailinglist, and let other developers give you a helping hand with designing the API. The best Flask extensions are extensions that share common idioms for the API. And this can only work if collaboration happens early. Approved Extensions \u00b6 Flask also has the concept of approved extensions. Approved extensions are tested as part of Flask itself to ensure extensions do not break on new releases. These approved extensions are listed on the Flask Extension Registry _ and marked appropriately. If you want your own extension to be approved you have to follow these guidelines: An approved Flask extension requires a maintainer. In the event an extension author would like to move beyond the project, the project should find a new maintainer including full source hosting transition and PyPI access. If no maintainer is available, give access to the Flask core team. An approved Flask extension must provide exactly one package or module named flask_extensionname . It must ship a testing suite that can either be invoked with make test or python setup.py test . For test suites invoked with make test the extension has to ensure that all dependencies for the test are installed automatically. If tests are invoked with python setup.py test , test dependencies can be specified in the :file: setup.py file. The test suite also has to be part of the distribution. APIs of approved extensions will be checked for the following characteristics: an approved extension has to support multiple applications running in the same Python process. it must be possible to use the factory pattern for creating applications. The license must be BSD/MIT/WTFPL licensed. The naming scheme for official extensions is Flask-ExtensionName or ExtensionName-Flask . Approved extensions must define all their dependencies in the :file: setup.py file unless a dependency cannot be met because it is not available on PyPI. The documentation must use the flask theme from the Official Pallets Themes _. The setup.py description (and thus the PyPI description) has to link to the documentation, website (if there is one) and there must be a link to automatically install the development version ( PackageName==dev ). The zip_safe flag in the setup script must be set to False , even if the extension would be safe for zipping. An extension currently has to support Python 3.4 and newer and 2.7. .. _OAuth extension: https://pythonhosted.org/Flask-OAuth/ .. _mailinglist: http://flask.pocoo.org/mailinglist/ .. _IRC channel: http://flask.pocoo.org/community/irc/ .. _Official Pallets Themes: https://pypi.org/project/pallets-sphinx-themes/","title":"Flask Extension Development"},{"location":"extensiondev/#flask-extension-development","text":"Flask, being a microframework, often requires some repetitive steps to get a third party library working. Because very often these steps could be abstracted to support multiple projects the Flask Extension Registry _ was created. If you want to create your own Flask extension for something that does not exist yet, this guide to extension development will help you get your extension running in no time and to feel like users would expect your extension to behave. .. _Flask Extension Registry: http://flask.pocoo.org/extensions/","title":"Flask Extension Development"},{"location":"extensiondev/#anatomy-of-an-extension","text":"Extensions are all located in a package called flask_something where \"something\" is the name of the library you want to bridge. So for example if you plan to add support for a library named simplexml to Flask, you would name your extension's package flask_simplexml . The name of the actual extension (the human readable name) however would be something like \"Flask-SimpleXML\". Make sure to include the name \"Flask\" somewhere in that name and that you check the capitalization. This is how users can then register dependencies to your extension in their :file: setup.py files. But what do extensions look like themselves? An extension has to ensure that it works with multiple Flask application instances at once. This is a requirement because many people will use patterns like the :ref: app-factories pattern to create their application as needed to aid unittests and to support multiple configurations. Because of that it is crucial that your application supports that kind of behavior. Most importantly the extension must be shipped with a :file: setup.py file and registered on PyPI. Also the development checkout link should work so that people can easily install the development version into their virtualenv without having to download the library by hand. Flask extensions must be licensed under a BSD, MIT or more liberal license in order to be listed in the Flask Extension Registry. Keep in mind that the Flask Extension Registry is a moderated place and libraries will be reviewed upfront if they behave as required.","title":"Anatomy of an Extension"},{"location":"extensiondev/#hello-flaskext","text":"So let's get started with creating such a Flask extension. The extension we want to create here will provide very basic support for SQLite3. First we create the following folder structure:: flask-sqlite3/ flask_sqlite3.py LICENSE README Here's the contents of the most important files: setup.py The next file that is absolutely required is the : file : `setup.py` file which is used to install your Flask extension . The following contents are something you can work with :: \"\"\" Flask-SQLite3 ------------- This is the description for that library \"\"\" from setuptools import setup setup ( name = 'Flask-SQLite3' , version = '1.0' , url = 'http://example.com/flask-sqlite3/' , license = 'BSD' , author = 'Your Name' , author_email = 'your-email@example.com' , description = 'Very short description' , long_description = __doc__ , py_modules = [ 'flask_sqlite3' ], # if you would be using a package instead use packages instead # of py_modules: # packages=['flask_sqlite3'], zip_safe = False , include_package_data = True , platforms = 'any' , install_requires = [ 'Flask' ], classifiers = [ 'Environment :: Web Environment' , 'Intended Audience :: Developers' , 'License :: OSI Approved :: BSD License' , 'Operating System :: OS Independent' , 'Programming Language :: Python' , 'Topic :: Internet :: WWW/HTTP :: Dynamic Content' , 'Topic :: Software Development :: Libraries :: Python Modules' ] ) That 's a lot of code but you can really just copy/paste that from existing extensions and adapt . flask_sqlite3 . py Now this is where your extension code goes. But how exactly should such an extension look like? What are the best practices? Continue reading for some insight.","title":"\"Hello Flaskext!\""},{"location":"extensiondev/#initializing-extensions","text":"Many extensions will need some kind of initialization step. For example, consider an application that's currently connecting to SQLite like the documentation suggests (:ref: sqlite3 ). So how does the extension know the name of the application object? Quite simple: you pass it to it. There are two recommended ways for an extension to initialize: initialization functions: If your extension is called `helloworld` you might have a function called ``init_helloworld(app[, extra_args])`` that initializes the extension for that application. It could attach before / after handlers etc. classes: Classes work mostly like initialization functions but can later be used to further change the behavior. For an example look at how the `OAuth extension`_ works: there is an `OAuth` object that provides some helper functions like `OAuth.remote_app` to create a reference to a remote application that uses OAuth. What to use depends on what you have in mind. For the SQLite 3 extension we will use the class-based approach because it will provide users with an object that handles opening and closing database connections. When designing your classes, it's important to make them easily reusable at the module level. This means the object itself must not under any circumstances store any application specific state and must be shareable between different applications.","title":"Initializing Extensions"},{"location":"extensiondev/#the-extension-code","text":"Here's the contents of the flask_sqlite3.py for copy/paste:: import sqlite3 from flask import current_app , _app_ctx_stack class SQLite3 ( object ): def __init__ ( self , app = None ): self . app = app if app is not None : self . init_app ( app ) def init_app ( self , app ): app . config . setdefault ( 'SQLITE3_DATABASE' , ':memory:' ) app . teardown_appcontext ( self . teardown ) def connect ( self ): return sqlite3 . connect ( current_app . config [ 'SQLITE3_DATABASE' ]) def teardown ( self , exception ): ctx = _app_ctx_stack . top if hasattr ( ctx , 'sqlite3_db' ): ctx . sqlite3_db . close () @property def connection ( self ): ctx = _app_ctx_stack . top if ctx is not None : if not hasattr ( ctx , 'sqlite3_db' ): ctx . sqlite3_db = self . connect () return ctx . sqlite3_db So here's what these lines of code do: The __init__ method takes an optional app object and, if supplied, will call init_app . The init_app method exists so that the SQLite3 object can be instantiated without requiring an app object. This method supports the factory pattern for creating applications. The init_app will set the configuration for the database, defaulting to an in memory database if no configuration is supplied. In addition, the init_app method attaches the teardown handler. Next, we define a connect method that opens a database connection. Finally, we add a connection property that on first access opens the database connection and stores it on the context. This is also the recommended way to handling resources: fetch resources lazily the first time they are used. Note here that we're attaching our database connection to the top application context via _app_ctx_stack.top . Extensions should use the top context for storing their own information with a sufficiently complex name. So why did we decide on a class-based approach here? Because using our extension looks something like this:: from flask import Flask from flask_sqlite3 import SQLite3 app = Flask ( __name__ ) app . config . from_pyfile ( 'the-config.cfg' ) db = SQLite3 ( app ) You can then use the database from views like this:: @app.route('/') def show_all(): cur = db.connection.cursor() cur.execute(...) Likewise if you are outside of a request you can use the database by pushing an app context:: with app.app_context(): cur = db.connection.cursor() cur.execute(...) At the end of the with block the teardown handles will be executed automatically. Additionally, the init_app method is used to support the factory pattern for creating apps:: db = SQLite3() # Then later on. app = create_app('the-config.cfg') db.init_app(app) Keep in mind that supporting this factory pattern for creating apps is required for approved flask extensions (described below). .. admonition:: Note on init_app As you noticed, init_app does not assign app to self . This is intentional! Class based Flask extensions must only store the application on the object when the application was passed to the constructor. This tells the extension: I am not interested in using multiple applications. When the extension needs to find the current application and it does not have a reference to it, it must either use the :data: ~flask.current_app context local or change the API in a way that you can pass the application explicitly.","title":"The Extension Code"},{"location":"extensiondev/#using-95app_ctx_stack","text":"In the example above, before every request, a sqlite3_db variable is assigned to _app_ctx_stack.top . In a view function, this variable is accessible using the connection property of SQLite3 . During the teardown of a request, the sqlite3_db connection is closed. By using this pattern, the same connection to the sqlite3 database is accessible to anything that needs it for the duration of the request.","title":"Using _app_ctx_stack"},{"location":"extensiondev/#learn-from-others","text":"This documentation only touches the bare minimum for extension development. If you want to learn more, it's a very good idea to check out existing extensions on the Flask Extension Registry . If you feel lost there is still the mailinglist and the IRC channel _ to get some ideas for nice looking APIs. Especially if you do something nobody before you did, it might be a very good idea to get some more input. This not only generates useful feedback on what people might want from an extension, but also avoids having multiple developers working in isolation on pretty much the same problem. Remember: good API design is hard, so introduce your project on the mailinglist, and let other developers give you a helping hand with designing the API. The best Flask extensions are extensions that share common idioms for the API. And this can only work if collaboration happens early.","title":"Learn from Others"},{"location":"extensiondev/#approved-extensions","text":"Flask also has the concept of approved extensions. Approved extensions are tested as part of Flask itself to ensure extensions do not break on new releases. These approved extensions are listed on the Flask Extension Registry _ and marked appropriately. If you want your own extension to be approved you have to follow these guidelines: An approved Flask extension requires a maintainer. In the event an extension author would like to move beyond the project, the project should find a new maintainer including full source hosting transition and PyPI access. If no maintainer is available, give access to the Flask core team. An approved Flask extension must provide exactly one package or module named flask_extensionname . It must ship a testing suite that can either be invoked with make test or python setup.py test . For test suites invoked with make test the extension has to ensure that all dependencies for the test are installed automatically. If tests are invoked with python setup.py test , test dependencies can be specified in the :file: setup.py file. The test suite also has to be part of the distribution. APIs of approved extensions will be checked for the following characteristics: an approved extension has to support multiple applications running in the same Python process. it must be possible to use the factory pattern for creating applications. The license must be BSD/MIT/WTFPL licensed. The naming scheme for official extensions is Flask-ExtensionName or ExtensionName-Flask . Approved extensions must define all their dependencies in the :file: setup.py file unless a dependency cannot be met because it is not available on PyPI. The documentation must use the flask theme from the Official Pallets Themes _. The setup.py description (and thus the PyPI description) has to link to the documentation, website (if there is one) and there must be a link to automatically install the development version ( PackageName==dev ). The zip_safe flag in the setup script must be set to False , even if the extension would be safe for zipping. An extension currently has to support Python 3.4 and newer and 2.7. .. _OAuth extension: https://pythonhosted.org/Flask-OAuth/ .. _mailinglist: http://flask.pocoo.org/mailinglist/ .. _IRC channel: http://flask.pocoo.org/community/irc/ .. _Official Pallets Themes: https://pypi.org/project/pallets-sphinx-themes/","title":"Approved Extensions"},{"location":"extensions/","text":"Extensions \u00b6 Extensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a ReST API. Finding Extensions \u00b6 Flask extensions are usually named \"Flask-Foo\" or \"Foo-Flask\". Many extensions are listed in the Extension Registry _, which can be updated by extension developers. You can also search PyPI for packages tagged with Framework :: Flask <pypi_> _. Using Extensions \u00b6 Consult each extension's documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from :attr: app.config <flask.Flask.config> and are passed an application instance during initialization. For example, an extension called \"Flask-Foo\" might be used like this:: from flask_foo import Foo foo = Foo () app = Flask ( __name__ ) app . config . update ( FOO_BAR = 'baz' , FOO_SPAM = 'eggs' , ) foo . init_app ( app ) Building Extensions \u00b6 While the Extension Registry _ contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read :ref: extension-dev to develop your own Flask extension. .. _Extension Registry: http://flask.pocoo.org/extensions/ .. _pypi: https://pypi.org/search/?c=Framework+%3A%3A+Flask","title":"Extensions"},{"location":"extensions/#extensions","text":"Extensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a ReST API.","title":"Extensions"},{"location":"extensions/#finding-extensions","text":"Flask extensions are usually named \"Flask-Foo\" or \"Foo-Flask\". Many extensions are listed in the Extension Registry _, which can be updated by extension developers. You can also search PyPI for packages tagged with Framework :: Flask <pypi_> _.","title":"Finding Extensions"},{"location":"extensions/#using-extensions","text":"Consult each extension's documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from :attr: app.config <flask.Flask.config> and are passed an application instance during initialization. For example, an extension called \"Flask-Foo\" might be used like this:: from flask_foo import Foo foo = Foo () app = Flask ( __name__ ) app . config . update ( FOO_BAR = 'baz' , FOO_SPAM = 'eggs' , ) foo . init_app ( app )","title":"Using Extensions"},{"location":"extensions/#building-extensions","text":"While the Extension Registry _ contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read :ref: extension-dev to develop your own Flask extension. .. _Extension Registry: http://flask.pocoo.org/extensions/ .. _pypi: https://pypi.org/search/?c=Framework+%3A%3A+Flask","title":"Building Extensions"},{"location":"htmlfaq/","text":"HTML/XHTML FAQ \u00b6 The Flask documentation and example applications are using HTML5. You may notice that in many situations, when end tags are optional they are not used, so that the HTML is cleaner and faster to load. Because there is much confusion about HTML and XHTML among developers, this document tries to answer some of the major questions. History of XHTML \u00b6 For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer's lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type :mimetype: application/xhtml+xml , but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful. One of the most important causes of pain is XML's draconian (strict and ruthless) error handling. When an XML parsing error is encountered, the browser is supposed to show the user an ugly error message, instead of attempting to recover from the error and display what it can. Most of the (X)HTML generation on the web is based on non-XML template engines (such as Jinja, the one used in Flask) which do not protect you from accidentally creating invalid XHTML. There are XML based template engines, such as Kid and the popular Genshi, but they often come with a larger runtime overhead and are not as straightforward to use because they have to obey XML rules. The majority of users, however, assumed they were properly using XHTML. They wrote an XHTML doctype at the top of the document and self-closed all the necessary tags ( <br> becomes <br/> or <br></br> in XHTML). However, even if the document properly validates as XHTML, what really determines XHTML/HTML processing in browsers is the MIME type, which as said before is often not set properly. So the valid XHTML was being treated as invalid HTML. XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements. History of HTML5 \u00b6 Development of the HTML5 specification was started in 2004 under the name \"Web Applications 1.0\" by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications. For example, in HTML4 <title/Hello/ theoretically parses exactly the same as <title>Hello</title> . However, since people were using XHTML-like tags along the lines of <link /> , browser vendors implemented the XHTML syntax over the syntax defined by the specification. In 2007, the specification was adopted as the basis of a new HTML specification under the umbrella of the W3C, known as HTML5. Currently, it appears that XHTML is losing traction, as the XHTML 2 working group has been disbanded and HTML5 is being implemented by all major browser vendors. HTML versus XHTML \u00b6 The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.) .. tabularcolumns:: |p{9cm}|p{2cm}|p{2cm}|p{2cm}| +-----------------------------------------+----------+----------+----------+ | | HTML4.01 | XHTML1.1 | HTML5 | +=========================================+==========+==========+==========+ | <tag/value/ == <tag>value</tag> | |Y| [1] | |N| | |N| | +-----------------------------------------+----------+----------+----------+ | <br/> supported | |N| | |Y| | |Y| [2] | +-----------------------------------------+----------+----------+----------+ | <script/> supported | |N| | |Y| | |N| | +-----------------------------------------+----------+----------+----------+ | should be served as text/html | |Y| | |N| [3]_ | |Y| | +-----------------------------------------+----------+----------+----------+ | should be served as | |N| | |Y| | |N| | | application/xhtml+xml | | | | +-----------------------------------------+----------+----------+----------+ | strict error handling | |N| | |Y| | |N| | +-----------------------------------------+----------+----------+----------+ | inline SVG | |N| | |Y| | |Y| | +-----------------------------------------+----------+----------+----------+ | inline MathML | |N| | |Y| | |Y| | +-----------------------------------------+----------+----------+----------+ | <video> tag | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ | <audio> tag | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ | New semantic tags like <article> | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ .. [1] This is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above. .. [2] This is for compatibility with server code that generates XHTML for tags such as <br> . It should not be used in new code. .. [3] XHTML 1.0 is the last XHTML standard that allows to be served as text/html for backwards compatibility reasons. .. |Y| image:: _static/yes.png :alt: Yes .. |N| image:: _static/no.png :alt: No What does \"strict\" mean? \u00b6 HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values). Some of these work because of the lenient error handling most browsers use when they encounter a markup error, others are actually specified. The following constructs are optional in HTML5 by standard, but have to be supported by browsers: Wrapping the document in an <html> tag Wrapping header elements in <head> or the body elements in <body> Closing the <p> , <li> , <dt> , <dd> , <tr> , <td> , <th> , <tbody> , <thead> , or <tfoot> tags. Quoting attributes, so long as they contain no whitespace or special characters (like < , > , ' , or \" ). Requiring boolean attributes to have a value. This means the following page in HTML5 is perfectly valid: .. sourcecode:: html &lt;!doctype html&gt; &lt;title&gt;Hello HTML5&lt;/title&gt; &lt;div class=header&gt; &lt;h1&gt;Hello HTML5&lt;/h1&gt; &lt;p class=tagline&gt;HTML5 is awesome &lt;/div&gt; &lt;ul class=nav&gt; &lt;li&gt;&lt;a href=/index&gt;Index&lt;/a&gt; &lt;li&gt;&lt;a href=/downloads&gt;Downloads&lt;/a&gt; &lt;li&gt;&lt;a href=/about&gt;About&lt;/a&gt; &lt;/ul&gt; &lt;div class=body&gt; &lt;h2&gt;HTML5 is probably the future&lt;/h2&gt; &lt;p&gt; There might be some other things around but in terms of browser vendor support, HTML5 is hard to beat. &lt;dl&gt; &lt;dt&gt;Key 1 &lt;dd&gt;Value 1 &lt;dt&gt;Key 2 &lt;dd&gt;Value 2 &lt;/dl&gt; &lt;/div&gt; New technologies in HTML5 \u00b6 HTML5 adds many new features that make Web applications easier to write and to use. The <audio> and <video> tags provide a way to embed audio and video without complicated add-ons like QuickTime or Flash. Semantic elements like <article> , <header> , <nav> , and <time> that make content easier to understand. The <canvas> tag, which supports a powerful drawing API, reducing the need for server-generated images to present data graphically. New form control types like <input type=\"date\"> that allow user agents to make entering and validating values easier. Advanced JavaScript APIs like Web Storage, Web Workers, Web Sockets, geolocation, and offline applications. Many other features have been added, as well. A good guide to new features in HTML5 is Mark Pilgrim's soon-to-be-published book, Dive Into HTML5 _. Not all of them are supported in browsers yet, however, so use caution. .. _Dive Into HTML5: http://diveintohtml5.info/table-of-contents.html What should be used? \u00b6 Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above: Internet Explorer (which, sadly, currently leads in market share) has poor support for XHTML. Many JavaScript libraries also do not support XHTML, due to the more complicated namespacing API it requires. HTML5 adds several new features, including semantic tags and the long-awaited <audio> and <video> tags. It has the support of most browser vendors behind it. It is much easier to write, and more compact. For most applications, it is undoubtedly better to use HTML5 than XHTML.","title":"HTML/XHTML FAQ"},{"location":"htmlfaq/#htmlxhtml-faq","text":"The Flask documentation and example applications are using HTML5. You may notice that in many situations, when end tags are optional they are not used, so that the HTML is cleaner and faster to load. Because there is much confusion about HTML and XHTML among developers, this document tries to answer some of the major questions.","title":"HTML/XHTML FAQ"},{"location":"htmlfaq/#history-of-xhtml","text":"For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer's lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type :mimetype: application/xhtml+xml , but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful. One of the most important causes of pain is XML's draconian (strict and ruthless) error handling. When an XML parsing error is encountered, the browser is supposed to show the user an ugly error message, instead of attempting to recover from the error and display what it can. Most of the (X)HTML generation on the web is based on non-XML template engines (such as Jinja, the one used in Flask) which do not protect you from accidentally creating invalid XHTML. There are XML based template engines, such as Kid and the popular Genshi, but they often come with a larger runtime overhead and are not as straightforward to use because they have to obey XML rules. The majority of users, however, assumed they were properly using XHTML. They wrote an XHTML doctype at the top of the document and self-closed all the necessary tags ( <br> becomes <br/> or <br></br> in XHTML). However, even if the document properly validates as XHTML, what really determines XHTML/HTML processing in browsers is the MIME type, which as said before is often not set properly. So the valid XHTML was being treated as invalid HTML. XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements.","title":"History of XHTML"},{"location":"htmlfaq/#history-of-html5","text":"Development of the HTML5 specification was started in 2004 under the name \"Web Applications 1.0\" by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications. For example, in HTML4 <title/Hello/ theoretically parses exactly the same as <title>Hello</title> . However, since people were using XHTML-like tags along the lines of <link /> , browser vendors implemented the XHTML syntax over the syntax defined by the specification. In 2007, the specification was adopted as the basis of a new HTML specification under the umbrella of the W3C, known as HTML5. Currently, it appears that XHTML is losing traction, as the XHTML 2 working group has been disbanded and HTML5 is being implemented by all major browser vendors.","title":"History of HTML5"},{"location":"htmlfaq/#html-versus-xhtml","text":"The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.) .. tabularcolumns:: |p{9cm}|p{2cm}|p{2cm}|p{2cm}| +-----------------------------------------+----------+----------+----------+ | | HTML4.01 | XHTML1.1 | HTML5 | +=========================================+==========+==========+==========+ | <tag/value/ == <tag>value</tag> | |Y| [1] | |N| | |N| | +-----------------------------------------+----------+----------+----------+ | <br/> supported | |N| | |Y| | |Y| [2] | +-----------------------------------------+----------+----------+----------+ | <script/> supported | |N| | |Y| | |N| | +-----------------------------------------+----------+----------+----------+ | should be served as text/html | |Y| | |N| [3]_ | |Y| | +-----------------------------------------+----------+----------+----------+ | should be served as | |N| | |Y| | |N| | | application/xhtml+xml | | | | +-----------------------------------------+----------+----------+----------+ | strict error handling | |N| | |Y| | |N| | +-----------------------------------------+----------+----------+----------+ | inline SVG | |N| | |Y| | |Y| | +-----------------------------------------+----------+----------+----------+ | inline MathML | |N| | |Y| | |Y| | +-----------------------------------------+----------+----------+----------+ | <video> tag | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ | <audio> tag | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ | New semantic tags like <article> | |N| | |N| | |Y| | +-----------------------------------------+----------+----------+----------+ .. [1] This is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above. .. [2] This is for compatibility with server code that generates XHTML for tags such as <br> . It should not be used in new code. .. [3] XHTML 1.0 is the last XHTML standard that allows to be served as text/html for backwards compatibility reasons. .. |Y| image:: _static/yes.png :alt: Yes .. |N| image:: _static/no.png :alt: No","title":"HTML versus XHTML"},{"location":"htmlfaq/#what-does-strict-mean","text":"HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values). Some of these work because of the lenient error handling most browsers use when they encounter a markup error, others are actually specified. The following constructs are optional in HTML5 by standard, but have to be supported by browsers: Wrapping the document in an <html> tag Wrapping header elements in <head> or the body elements in <body> Closing the <p> , <li> , <dt> , <dd> , <tr> , <td> , <th> , <tbody> , <thead> , or <tfoot> tags. Quoting attributes, so long as they contain no whitespace or special characters (like < , > , ' , or \" ). Requiring boolean attributes to have a value. This means the following page in HTML5 is perfectly valid: .. sourcecode:: html &lt;!doctype html&gt; &lt;title&gt;Hello HTML5&lt;/title&gt; &lt;div class=header&gt; &lt;h1&gt;Hello HTML5&lt;/h1&gt; &lt;p class=tagline&gt;HTML5 is awesome &lt;/div&gt; &lt;ul class=nav&gt; &lt;li&gt;&lt;a href=/index&gt;Index&lt;/a&gt; &lt;li&gt;&lt;a href=/downloads&gt;Downloads&lt;/a&gt; &lt;li&gt;&lt;a href=/about&gt;About&lt;/a&gt; &lt;/ul&gt; &lt;div class=body&gt; &lt;h2&gt;HTML5 is probably the future&lt;/h2&gt; &lt;p&gt; There might be some other things around but in terms of browser vendor support, HTML5 is hard to beat. &lt;dl&gt; &lt;dt&gt;Key 1 &lt;dd&gt;Value 1 &lt;dt&gt;Key 2 &lt;dd&gt;Value 2 &lt;/dl&gt; &lt;/div&gt;","title":"What does \"strict\" mean?"},{"location":"htmlfaq/#new-technologies-in-html5","text":"HTML5 adds many new features that make Web applications easier to write and to use. The <audio> and <video> tags provide a way to embed audio and video without complicated add-ons like QuickTime or Flash. Semantic elements like <article> , <header> , <nav> , and <time> that make content easier to understand. The <canvas> tag, which supports a powerful drawing API, reducing the need for server-generated images to present data graphically. New form control types like <input type=\"date\"> that allow user agents to make entering and validating values easier. Advanced JavaScript APIs like Web Storage, Web Workers, Web Sockets, geolocation, and offline applications. Many other features have been added, as well. A good guide to new features in HTML5 is Mark Pilgrim's soon-to-be-published book, Dive Into HTML5 _. Not all of them are supported in browsers yet, however, so use caution. .. _Dive Into HTML5: http://diveintohtml5.info/table-of-contents.html","title":"New technologies in HTML5"},{"location":"htmlfaq/#what-should-be-used","text":"Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above: Internet Explorer (which, sadly, currently leads in market share) has poor support for XHTML. Many JavaScript libraries also do not support XHTML, due to the more complicated namespacing API it requires. HTML5 adds several new features, including semantic tags and the long-awaited <audio> and <video> tags. It has the support of most browser vendors behind it. It is much easier to write, and more compact. For most applications, it is undoubtedly better to use HTML5 than XHTML.","title":"What should be used?"},{"location":"latexindex/","text":":orphan: Flask Documentation \u00b6 .. include:: contents.rst.inc","title":"Latexindex"},{"location":"latexindex/#flask-documentation","text":".. include:: contents.rst.inc","title":"Flask Documentation"},{"location":"license/","text":"License \u00b6 Flask is licensed under a three clause BSD License. It basically means: do whatever you want with it as long as the copyright in Flask sticks around, the conditions are not modified and the disclaimer is present. Furthermore you must not use the names of the authors to promote derivatives of the software without written consent. The full license text can be found below (:ref: flask-license ). For the documentation and artwork different licenses apply. .. _authors: Authors \u00b6 .. include:: ../AUTHORS General License Definitions \u00b6 The following section contains the full license texts for Flask and the documentation. \"AUTHORS\" hereby refers to all the authors listed in the :ref: authors section. The \":ref: flask-license \" applies to all the source code shipped as part of Flask (Flask itself as well as the examples and the unittests) as well as documentation. The \":ref: artwork-license \" applies to the project's Horn-Logo. .. _flask-license: Flask License \u00b6 .. include:: ../LICENSE .. _artwork-license: Flask Artwork License \u00b6 .. include:: ../artwork/LICENSE","title":"License"},{"location":"license/#license","text":"Flask is licensed under a three clause BSD License. It basically means: do whatever you want with it as long as the copyright in Flask sticks around, the conditions are not modified and the disclaimer is present. Furthermore you must not use the names of the authors to promote derivatives of the software without written consent. The full license text can be found below (:ref: flask-license ). For the documentation and artwork different licenses apply. .. _authors:","title":"License"},{"location":"license/#authors","text":".. include:: ../AUTHORS","title":"Authors"},{"location":"license/#general-license-definitions","text":"The following section contains the full license texts for Flask and the documentation. \"AUTHORS\" hereby refers to all the authors listed in the :ref: authors section. The \":ref: flask-license \" applies to all the source code shipped as part of Flask (Flask itself as well as the examples and the unittests) as well as documentation. The \":ref: artwork-license \" applies to the project's Horn-Logo. .. _flask-license:","title":"General License Definitions"},{"location":"license/#flask-license","text":".. include:: ../LICENSE .. _artwork-license:","title":"Flask License"},{"location":"license/#flask-artwork-license","text":".. include:: ../artwork/LICENSE","title":"Flask Artwork License"},{"location":"logging/","text":"Logging \u00b6 Flask uses standard Python :mod: logging . All Flask-related messages are logged under the 'flask' logger namespace. :meth: Flask.logger <flask.Flask.logger> returns the logger named 'flask.app' , and can be used to log messages for your application. :: @app.route('/login', methods=['POST']) def login(): user = get_user(request.form['username']) if user.check_password(request.form['password']): login_user(user) app.logger.info('%s logged in successfully', user.username) return redirect(url_for('index')) else: app.logger.info('%s failed to log in', user.username) abort(401) Basic Configuration \u00b6 When you want to configure logging for your project, you should do it as soon as possible when the program starts. If :meth: app.logger <flask.Flask.logger> is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object. This example uses :func: ~logging.config.dictConfig to create a logging configuration similar to Flask's default, except for all logs:: from logging.config import dictConfig dictConfig ({ 'version' : 1 , 'formatters' : { 'default' : { 'format' : '[ %(asctime)s ] %(levelname)s in %(module)s : %(message)s ' , }}, 'handlers' : { 'wsgi' : { 'class' : 'logging.StreamHandler' , 'stream' : 'ext://flask.logging.wsgi_errors_stream' , 'formatter' : 'default' }}, 'root' : { 'level' : 'INFO' , 'handlers' : [ 'wsgi' ] } }) app = Flask ( __name__ ) Default Configuration If you do not configure logging yourself, Flask will add a :class:`~logging.StreamHandler` to :meth:`app.logger <flask.Flask.logger>` automatically. During requests, it will write to the stream specified by the WSGI server in ``environ['wsgi.errors']`` (which is usually :data:`sys.stderr`). Outside a request, it will log to :data:`sys.stderr`. Removing the Default Handler If you configured logging after accessing :meth: app.logger <flask.Flask.logger> , and need to remove the default handler, you can import and remove it:: from flask.logging import default_handler app . logger . removeHandler ( default_handler ) Email Errors to Admins \u00b6 When running the application on a remote server for production, you probably won't be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you'll only check that file if a user tells you something went wrong. To be proactive about discovering and fixing bugs, you can configure a :class: logging.handlers.SMTPHandler to send an email when errors and higher are logged. :: import logging from logging.handlers import SMTPHandler mail_handler = SMTPHandler ( mailhost = '127.0.0.1' , fromaddr = 'server-error@example.com' , toaddrs = [ 'admin@example.com' ], subject = 'Application Error' ) mail_handler . setLevel ( logging . ERROR ) mail_handler . setFormatter ( logging . Formatter ( '[ %(asctime)s ] %(levelname)s in %(module)s : %(message)s ' )) if not app . debug : app . logger . addHandler ( mail_handler ) This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler. Injecting Request Information \u00b6 Seeing more information about the request, such as the IP address, may help debugging some errors. You can subclass :class: logging.Formatter to inject your own fields that can be used in messages. You can change the formatter for Flask's default handler, the mail handler defined above, or any other handler. :: from flask import request from flask.logging import default_handler class RequestFormatter ( logging . Formatter ): def format ( self , record ): record . url = request . url record . remote_addr = request . remote_addr return super ( RequestFormatter , self ) . format ( record ) formatter = RequestFormatter ( '[ %(asctime)s ] %(remote_addr)s requested %(url)s \\n ' ' %(levelname)s in %(module)s : %(message)s ' ) default_handler . setFormatter ( formatter ) mail_handler . setFormatter ( formatter ) Other Libraries \u00b6 Other libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger. :: from flask.logging import default_handler root = logging . getLogger () root . addHandler ( default_handler ) root . addHandler ( mail_handler ) Depending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger. :: for logger in ( app.logger, logging.getLogger('sqlalchemy'), logging.getLogger('other_package'), ): logger.addHandler(default_handler) logger.addHandler(mail_handler) Werkzeug Werkzeug logs basic request/response information to the ``'werkzeug'`` logger. If the root logger has no handlers configured, Werkzeug adds a :class:`~logging.StreamHandler` to its logger. Flask Extensions Depending on the situation, an extension may choose to log to :meth: app.logger <flask.Flask.logger> or its own named logger. Consult each extension's documentation for details.","title":"Logging"},{"location":"logging/#logging","text":"Flask uses standard Python :mod: logging . All Flask-related messages are logged under the 'flask' logger namespace. :meth: Flask.logger <flask.Flask.logger> returns the logger named 'flask.app' , and can be used to log messages for your application. :: @app.route('/login', methods=['POST']) def login(): user = get_user(request.form['username']) if user.check_password(request.form['password']): login_user(user) app.logger.info('%s logged in successfully', user.username) return redirect(url_for('index')) else: app.logger.info('%s failed to log in', user.username) abort(401)","title":"Logging"},{"location":"logging/#basic-configuration","text":"When you want to configure logging for your project, you should do it as soon as possible when the program starts. If :meth: app.logger <flask.Flask.logger> is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object. This example uses :func: ~logging.config.dictConfig to create a logging configuration similar to Flask's default, except for all logs:: from logging.config import dictConfig dictConfig ({ 'version' : 1 , 'formatters' : { 'default' : { 'format' : '[ %(asctime)s ] %(levelname)s in %(module)s : %(message)s ' , }}, 'handlers' : { 'wsgi' : { 'class' : 'logging.StreamHandler' , 'stream' : 'ext://flask.logging.wsgi_errors_stream' , 'formatter' : 'default' }}, 'root' : { 'level' : 'INFO' , 'handlers' : [ 'wsgi' ] } }) app = Flask ( __name__ ) Default Configuration If you do not configure logging yourself, Flask will add a :class:`~logging.StreamHandler` to :meth:`app.logger <flask.Flask.logger>` automatically. During requests, it will write to the stream specified by the WSGI server in ``environ['wsgi.errors']`` (which is usually :data:`sys.stderr`). Outside a request, it will log to :data:`sys.stderr`. Removing the Default Handler If you configured logging after accessing :meth: app.logger <flask.Flask.logger> , and need to remove the default handler, you can import and remove it:: from flask.logging import default_handler app . logger . removeHandler ( default_handler )","title":"Basic Configuration"},{"location":"logging/#email-errors-to-admins","text":"When running the application on a remote server for production, you probably won't be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you'll only check that file if a user tells you something went wrong. To be proactive about discovering and fixing bugs, you can configure a :class: logging.handlers.SMTPHandler to send an email when errors and higher are logged. :: import logging from logging.handlers import SMTPHandler mail_handler = SMTPHandler ( mailhost = '127.0.0.1' , fromaddr = 'server-error@example.com' , toaddrs = [ 'admin@example.com' ], subject = 'Application Error' ) mail_handler . setLevel ( logging . ERROR ) mail_handler . setFormatter ( logging . Formatter ( '[ %(asctime)s ] %(levelname)s in %(module)s : %(message)s ' )) if not app . debug : app . logger . addHandler ( mail_handler ) This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler.","title":"Email Errors to Admins"},{"location":"logging/#injecting-request-information","text":"Seeing more information about the request, such as the IP address, may help debugging some errors. You can subclass :class: logging.Formatter to inject your own fields that can be used in messages. You can change the formatter for Flask's default handler, the mail handler defined above, or any other handler. :: from flask import request from flask.logging import default_handler class RequestFormatter ( logging . Formatter ): def format ( self , record ): record . url = request . url record . remote_addr = request . remote_addr return super ( RequestFormatter , self ) . format ( record ) formatter = RequestFormatter ( '[ %(asctime)s ] %(remote_addr)s requested %(url)s \\n ' ' %(levelname)s in %(module)s : %(message)s ' ) default_handler . setFormatter ( formatter ) mail_handler . setFormatter ( formatter )","title":"Injecting Request Information"},{"location":"logging/#other-libraries","text":"Other libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger. :: from flask.logging import default_handler root = logging . getLogger () root . addHandler ( default_handler ) root . addHandler ( mail_handler ) Depending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger. :: for logger in ( app.logger, logging.getLogger('sqlalchemy'), logging.getLogger('other_package'), ): logger.addHandler(default_handler) logger.addHandler(mail_handler) Werkzeug Werkzeug logs basic request/response information to the ``'werkzeug'`` logger. If the root logger has no handlers configured, Werkzeug adds a :class:`~logging.StreamHandler` to its logger. Flask Extensions Depending on the situation, an extension may choose to log to :meth: app.logger <flask.Flask.logger> or its own named logger. Consult each extension's documentation for details.","title":"Other Libraries"},{"location":"reqcontext/","text":".. currentmodule:: flask The Request Context \u00b6 The request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the :data: request and :data: session proxies are accessed instead. This is similar to the :doc: /appcontext , which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed. Purpose of the Context \u00b6 When the :class: Flask application handles a request, it creates a :class: Request object based on the environment it received from the WSGI server. Because a worker (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term context local for this. Flask automatically pushes a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the :data: request proxy, which points to the request object for the current request. Lifetime of the Context \u00b6 When a Flask application begins handling a request, it pushes a request context, which also pushes an :doc: /appcontext . When the request ends it pops the request context then the application context. The context is unique to each thread (or other worker type). :data: request cannot be passed to another thread, the other thread will have a different context stack and will not know about the request the parent thread was pointing to. Context locals are implemented in Werkzeug. See :doc: werkzeug:local for more information on how this works internally. Manually Push a Context \u00b6 If you try to access :data: request , or anything that uses it, outside a request context, you'll get this error message: .. code-block:: pytb RuntimeError : Working outside of request context . This typically means that you attempted to use functionality that needed an active HTTP request . Consult the documentation on testing for information about how to avoid this problem . This should typically only happen when testing code that expects an active request. One option is to use the :meth: test client <Flask.test_client> to simulate a full request. Or you can use :meth: ~Flask.test_request_context in a with block, and everything that runs in the block will have access to :data: request , populated with your test data. :: def generate_report(year): format = request.args.get('format') ... with app.test_request_context( '/make_report/2017', data={'format': 'short'}): generate_report() If you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function. For information on how to use the request context from the interactive Python shell, see :doc: /shell . How the Context Works \u00b6 The :meth: Flask.wsgi_app method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work as stacks, :data: _request_ctx_stack and :data: _app_ctx_stack . When contexts are pushed onto the stack, the proxies that depend on them are available and point at information from the top context on the stack. When the request starts, a :class: ~ctx.RequestContext is created and pushed, which creates and pushes an :class: ~ctx.AppContext first if a context for that application is not already the top context. While these contexts are pushed, the :data: current_app , :data: g , :data: request , and :data: session proxies are available to the original thread handling the request. Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together. After the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the :meth: ~Flask.teardown_request and :meth: ~Flask.teardown_appcontext functions are are executed. These execute even if an unhandled exception occurred during dispatch. Callbacks and Errors \u00b6 Flask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages. A :class: Blueprint can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request. . Before each request, :meth: ~Flask.before_request functions are \u00b6 called. If one of these functions return a value, the other functions are skipped. The return value is treated as the response and the view function is not called. . If the :meth: ~Flask.before_request functions did not return a \u00b6 response, the view function for the matched route is called and returns a response. . The return value of the view is converted into an actual response \u00b6 object and passed to the :meth: ~Flask.after_request functions. Each function returns a modified or new response object. . After the response is returned, the contexts are popped, which calls \u00b6 the :meth: ~Flask.teardown_request and :meth: ~Flask.teardown_appcontext functions. These functions are called even if an unhandled exception was raised at any point above. If an exception is raised before the teardown functions, Flask tries to match it with an :meth: ~Flask.errorhandler function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic 500 Internal Server Error response. The teardown functions are still called, and are passed the exception object. If debug mode is enabled, unhandled exceptions are not converted to a 500 response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback. Teardown Callbacks The teardown callbacks are independent of the request dispatch , and are instead called by the contexts when they are popped . The functions are called even if there is an unhandled exception during dispatch , and for manually pushed contexts . This means there is no guarantee that any other parts of the request dispatch have run first . Be sure to write these functions in a way that does not depend on other callbacks and will not fail . During testing , it can be useful to defer popping the contexts after the request ends , so that their data can be accessed in the test function . Using the : meth : `~Flask.test_client` as a `` with `` block to preserve the contexts until the with block exits . .. code - block :: python from flask import Flask , request app = Flask ( __name__ ) @app.route ( '/' ) def hello (): print ( 'during view' ) return 'Hello, World!' @app.teardown_request def show_teardown ( exception ): print ( 'after with block' ) with app . test_request_context (): print ( 'during with block' ) # teardown functions are called after the context with block exits with app . test_client () as client : client . get ( '/' ) # the contexts are not popped even though the request ended print ( request . path ) # the contexts are popped and teardown functions are called after # the client with block exists Signals ~~~~~~~ If : data : `~signals.signals_available` is true , the following signals are sent : #. :data:`request_started` is sent before the : meth : `~Flask.before_request` functions are called . #. :data:`request_finished` is sent after the : meth : `~Flask.after_request` functions are called . #. :data:`got_request_exception` is sent when an exception begins to be handled , but before an : meth : `~Flask.errorhandler` is looked up or called . #. :data:`request_tearing_down` is sent after the : meth : `~Flask.teardown_request` functions are called . Context Preservation on Error ----------------------------- At the end of a request , the request context is popped and all data associated with it is destroyed . If an error occurs during development , it is useful to delay destroying the data for debugging purposes . When the development server is running in development mode ( the `` FLASK_ENV `` environment variable is set to `` 'development' `` ), the error and data will be preserved and shown in the interactive debugger . This behavior can be controlled with the : data : `PRESERVE_CONTEXT_ON_EXCEPTION` config . As described above , it defaults to `` True `` in the development environment . Do not enable : data : `PRESERVE_CONTEXT_ON_EXCEPTION` in production , as it will cause your application to leak memory on exceptions . .. _notes - on - proxies : Notes On Proxies ---------------- Some of the objects provided by Flask are proxies to other objects . The proxies are accessed in the same way for each worker thread , but point to the unique object bound to each worker behind the scenes as described on this page . Most of the time you don 't have to care about that, but there are some exceptions where it is good to know that this object is an actual proxy : - The proxy objects cannot fake their type as the actual object types . If you want to perform instance checks , you have to do that on the object being proxied . - If the specific object reference is important , for example for sending : ref : `signals` or passing data to a background thread . If you need to access the underlying object that is proxied , use the : meth : `~werkzeug.local.LocalProxy._get_current_object` method :: app = current_app . _get_current_object () my_signal . send ( app )","title":"Reqcontext"},{"location":"reqcontext/#the-request-context","text":"The request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the :data: request and :data: session proxies are accessed instead. This is similar to the :doc: /appcontext , which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed.","title":"The Request Context"},{"location":"reqcontext/#purpose-of-the-context","text":"When the :class: Flask application handles a request, it creates a :class: Request object based on the environment it received from the WSGI server. Because a worker (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term context local for this. Flask automatically pushes a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the :data: request proxy, which points to the request object for the current request.","title":"Purpose of the Context"},{"location":"reqcontext/#lifetime-of-the-context","text":"When a Flask application begins handling a request, it pushes a request context, which also pushes an :doc: /appcontext . When the request ends it pops the request context then the application context. The context is unique to each thread (or other worker type). :data: request cannot be passed to another thread, the other thread will have a different context stack and will not know about the request the parent thread was pointing to. Context locals are implemented in Werkzeug. See :doc: werkzeug:local for more information on how this works internally.","title":"Lifetime of the Context"},{"location":"reqcontext/#manually-push-a-context","text":"If you try to access :data: request , or anything that uses it, outside a request context, you'll get this error message: .. code-block:: pytb RuntimeError : Working outside of request context . This typically means that you attempted to use functionality that needed an active HTTP request . Consult the documentation on testing for information about how to avoid this problem . This should typically only happen when testing code that expects an active request. One option is to use the :meth: test client <Flask.test_client> to simulate a full request. Or you can use :meth: ~Flask.test_request_context in a with block, and everything that runs in the block will have access to :data: request , populated with your test data. :: def generate_report(year): format = request.args.get('format') ... with app.test_request_context( '/make_report/2017', data={'format': 'short'}): generate_report() If you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function. For information on how to use the request context from the interactive Python shell, see :doc: /shell .","title":"Manually Push a Context"},{"location":"reqcontext/#how-the-context-works","text":"The :meth: Flask.wsgi_app method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work as stacks, :data: _request_ctx_stack and :data: _app_ctx_stack . When contexts are pushed onto the stack, the proxies that depend on them are available and point at information from the top context on the stack. When the request starts, a :class: ~ctx.RequestContext is created and pushed, which creates and pushes an :class: ~ctx.AppContext first if a context for that application is not already the top context. While these contexts are pushed, the :data: current_app , :data: g , :data: request , and :data: session proxies are available to the original thread handling the request. Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together. After the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the :meth: ~Flask.teardown_request and :meth: ~Flask.teardown_appcontext functions are are executed. These execute even if an unhandled exception occurred during dispatch.","title":"How the Context Works"},{"location":"reqcontext/#callbacks-and-errors","text":"Flask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages. A :class: Blueprint can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request.","title":"Callbacks and Errors"},{"location":"reqcontext/#before-each-request-methflaskbefore_request-functions-are","text":"called. If one of these functions return a value, the other functions are skipped. The return value is treated as the response and the view function is not called.","title":". Before each request, :meth:~Flask.before_request functions are"},{"location":"reqcontext/#if-the-methflaskbefore_request-functions-did-not-return-a","text":"response, the view function for the matched route is called and returns a response.","title":". If the :meth:~Flask.before_request functions did not return a"},{"location":"reqcontext/#the-return-value-of-the-view-is-converted-into-an-actual-response","text":"object and passed to the :meth: ~Flask.after_request functions. Each function returns a modified or new response object.","title":". The return value of the view is converted into an actual response"},{"location":"reqcontext/#after-the-response-is-returned-the-contexts-are-popped-which-calls","text":"the :meth: ~Flask.teardown_request and :meth: ~Flask.teardown_appcontext functions. These functions are called even if an unhandled exception was raised at any point above. If an exception is raised before the teardown functions, Flask tries to match it with an :meth: ~Flask.errorhandler function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic 500 Internal Server Error response. The teardown functions are still called, and are passed the exception object. If debug mode is enabled, unhandled exceptions are not converted to a 500 response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback. Teardown Callbacks The teardown callbacks are independent of the request dispatch , and are instead called by the contexts when they are popped . The functions are called even if there is an unhandled exception during dispatch , and for manually pushed contexts . This means there is no guarantee that any other parts of the request dispatch have run first . Be sure to write these functions in a way that does not depend on other callbacks and will not fail . During testing , it can be useful to defer popping the contexts after the request ends , so that their data can be accessed in the test function . Using the : meth : `~Flask.test_client` as a `` with `` block to preserve the contexts until the with block exits . .. code - block :: python from flask import Flask , request app = Flask ( __name__ ) @app.route ( '/' ) def hello (): print ( 'during view' ) return 'Hello, World!' @app.teardown_request def show_teardown ( exception ): print ( 'after with block' ) with app . test_request_context (): print ( 'during with block' ) # teardown functions are called after the context with block exits with app . test_client () as client : client . get ( '/' ) # the contexts are not popped even though the request ended print ( request . path ) # the contexts are popped and teardown functions are called after # the client with block exists Signals ~~~~~~~ If : data : `~signals.signals_available` is true , the following signals are sent : #. :data:`request_started` is sent before the : meth : `~Flask.before_request` functions are called . #. :data:`request_finished` is sent after the : meth : `~Flask.after_request` functions are called . #. :data:`got_request_exception` is sent when an exception begins to be handled , but before an : meth : `~Flask.errorhandler` is looked up or called . #. :data:`request_tearing_down` is sent after the : meth : `~Flask.teardown_request` functions are called . Context Preservation on Error ----------------------------- At the end of a request , the request context is popped and all data associated with it is destroyed . If an error occurs during development , it is useful to delay destroying the data for debugging purposes . When the development server is running in development mode ( the `` FLASK_ENV `` environment variable is set to `` 'development' `` ), the error and data will be preserved and shown in the interactive debugger . This behavior can be controlled with the : data : `PRESERVE_CONTEXT_ON_EXCEPTION` config . As described above , it defaults to `` True `` in the development environment . Do not enable : data : `PRESERVE_CONTEXT_ON_EXCEPTION` in production , as it will cause your application to leak memory on exceptions . .. _notes - on - proxies : Notes On Proxies ---------------- Some of the objects provided by Flask are proxies to other objects . The proxies are accessed in the same way for each worker thread , but point to the unique object bound to each worker behind the scenes as described on this page . Most of the time you don 't have to care about that, but there are some exceptions where it is good to know that this object is an actual proxy : - The proxy objects cannot fake their type as the actual object types . If you want to perform instance checks , you have to do that on the object being proxied . - If the specific object reference is important , for example for sending : ref : `signals` or passing data to a background thread . If you need to access the underlying object that is proxied , use the : meth : `~werkzeug.local.LocalProxy._get_current_object` method :: app = current_app . _get_current_object () my_signal . send ( app )","title":". After the response is returned, the contexts are popped, which calls"},{"location":"security/","text":"Security Considerations \u00b6 Web applications usually face all kinds of security problems and it's very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself. Cross-Site Scripting (XSS) \u00b6 Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on Cross-Site Scripting <https://en.wikipedia.org/wiki/Cross-site_scripting> _. Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful: generating HTML without the help of Jinja2 calling :class: ~flask.Markup on data submitted by users sending out HTML from uploaded files, never do that, use the Content-Disposition: attachment header to prevent that problem. sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML. Another thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them: .. sourcecode:: html+jinja &lt;input value=\" {{ value }} \"&gt; Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript: .. sourcecode:: html onmouseover=alert(document.cookie) When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack. There is one class of XSS issues that Jinja's escaping does not protect against. The a tag's href attribute can contain a javascript: URI, which the browser will execute when clicked if not secured properly. .. sourcecode:: html &lt;a href=\" {{ value }} \"&gt;click here&lt;/a&gt; &lt;a href=\"javascript:alert('unsafe');\"&gt;click here&lt;/a&gt; To prevent this, you'll need to set the :ref: security-csp response header. Cross-Site Request Forgery (CSRF) \u00b6 Another big problem is CSRF. This is a very complex topic and I won't outline it here in detail just mention what it is and how to theoretically prevent it. If your authentication information is stored in cookies, you have implicit state management. The state of \"being logged in\" is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don't keep that in mind, some people might be able to trick your application's users with social engineering to do stupid things without them knowing. Say you have a specific URL that, when you sent POST requests to will delete a user's profile (say http://example.com/user/delete ). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted. Imagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats. How can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie and also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal. Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask. JSON Security \u00b6 In Flask 0.10 and lower, :func: ~flask.jsonify did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4. ECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have other more serious vulnerabilities <https://github.com/pallets/flask/issues/248#issuecomment-59934857> _, so this behavior was changed and :func: ~flask.jsonify now supports serializing arrays. Security Headers \u00b6 Browsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The Flask-Talisman _ extension can be used to manage HTTPS and the security headers for you. .. _Flask-Talisman: https://github.com/GoogleCloudPlatform/flask-talisman HTTP Strict Transport Security (HSTS) Tells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks. :: response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security .. _security-csp: Content Security Policy (CSP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Tell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be:: response.headers['Content-Security-Policy'] = \"default-src 'self'\" - https://csp.withgoogle.com/docs/index.html - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy X-Content-Type-Options ~~~~~~~~~~~~~~~~~~~~~~ Forces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack. :: response.headers['X-Content-Type-Options'] = 'nosniff' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options X-Frame-Options ~~~~~~~~~~~~~~~ Prevents external sites from embedding your site in an ``iframe``. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page's elements. This is also known as \"clickjacking\". :: response.headers['X-Frame-Options'] = 'SAMEORIGIN' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options X-XSS-Protection ~~~~~~~~~~~~~~~~ The browser will try to prevent reflected XSS attacks by not loading the page if the request contains something that looks like JavaScript and the response contains the same data. :: response.headers['X-XSS-Protection'] = '1; mode=block' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection .. _security-cookie: Set-Cookie options ~~~~~~~~~~~~~~~~~~ These options can be added to a ``Set-Cookie`` header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too. - ``Secure`` limits cookies to HTTPS traffic only. - ``HttpOnly`` protects the contents of cookies from being read with JavaScript. - ``SameSite`` restricts how cookies are sent with requests from external sites. Can be set to ``'Lax'`` (recommended) or ``'Strict'``. ``Lax`` prevents sending cookies with CSRF-prone requests from external sites, such as submitting a form. ``Strict`` prevents sending cookies with all external requests, including following regular links. :: app.config.update( SESSION_COOKIE_SECURE=True, SESSION_COOKIE_HTTPONLY=True, SESSION_COOKIE_SAMESITE='Lax', ) response.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax') Specifying ``Expires`` or ``Max-Age`` options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed. :: # cookie expires after 10 minutes response.set_cookie('snakes', '3', max_age=600) For the session cookie, if :attr:`session.permanent <flask.session.permanent>` is set, then :data:`PERMANENT_SESSION_LIFETIME` is used to set the expiration. Flask's default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time. :: app.config.update( PERMANENT_SESSION_LIFETIME=600 ) @app.route('/login', methods=['POST']) def login(): ... session.clear() session['user_id'] = user.id session.permanent = True ... Use :class:`itsdangerous.TimedSerializer` to sign and validate other cookie values (or any values that need secure signatures). - https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie .. _samesite_support: https://caniuse.com/#feat=same-site-cookie-attribute HTTP Public Key Pinning (HPKP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks. .. warning:: Be careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly. - https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning","title":"Security Considerations"},{"location":"security/#security-considerations","text":"Web applications usually face all kinds of security problems and it's very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself.","title":"Security Considerations"},{"location":"security/#cross-site-scripting-xss","text":"Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on Cross-Site Scripting <https://en.wikipedia.org/wiki/Cross-site_scripting> _. Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful: generating HTML without the help of Jinja2 calling :class: ~flask.Markup on data submitted by users sending out HTML from uploaded files, never do that, use the Content-Disposition: attachment header to prevent that problem. sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML. Another thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them: .. sourcecode:: html+jinja &lt;input value=\" {{ value }} \"&gt; Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript: .. sourcecode:: html onmouseover=alert(document.cookie) When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack. There is one class of XSS issues that Jinja's escaping does not protect against. The a tag's href attribute can contain a javascript: URI, which the browser will execute when clicked if not secured properly. .. sourcecode:: html &lt;a href=\" {{ value }} \"&gt;click here&lt;/a&gt; &lt;a href=\"javascript:alert('unsafe');\"&gt;click here&lt;/a&gt; To prevent this, you'll need to set the :ref: security-csp response header.","title":"Cross-Site Scripting (XSS)"},{"location":"security/#cross-site-request-forgery-csrf","text":"Another big problem is CSRF. This is a very complex topic and I won't outline it here in detail just mention what it is and how to theoretically prevent it. If your authentication information is stored in cookies, you have implicit state management. The state of \"being logged in\" is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don't keep that in mind, some people might be able to trick your application's users with social engineering to do stupid things without them knowing. Say you have a specific URL that, when you sent POST requests to will delete a user's profile (say http://example.com/user/delete ). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted. Imagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats. How can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie and also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal. Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.","title":"Cross-Site Request Forgery (CSRF)"},{"location":"security/#json-security","text":"In Flask 0.10 and lower, :func: ~flask.jsonify did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4. ECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have other more serious vulnerabilities <https://github.com/pallets/flask/issues/248#issuecomment-59934857> _, so this behavior was changed and :func: ~flask.jsonify now supports serializing arrays.","title":"JSON Security"},{"location":"security/#security-headers","text":"Browsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The Flask-Talisman _ extension can be used to manage HTTPS and the security headers for you. .. _Flask-Talisman: https://github.com/GoogleCloudPlatform/flask-talisman HTTP Strict Transport Security (HSTS) Tells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks. :: response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security .. _security-csp: Content Security Policy (CSP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Tell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be:: response.headers['Content-Security-Policy'] = \"default-src 'self'\" - https://csp.withgoogle.com/docs/index.html - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy X-Content-Type-Options ~~~~~~~~~~~~~~~~~~~~~~ Forces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack. :: response.headers['X-Content-Type-Options'] = 'nosniff' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options X-Frame-Options ~~~~~~~~~~~~~~~ Prevents external sites from embedding your site in an ``iframe``. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page's elements. This is also known as \"clickjacking\". :: response.headers['X-Frame-Options'] = 'SAMEORIGIN' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options X-XSS-Protection ~~~~~~~~~~~~~~~~ The browser will try to prevent reflected XSS attacks by not loading the page if the request contains something that looks like JavaScript and the response contains the same data. :: response.headers['X-XSS-Protection'] = '1; mode=block' - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection .. _security-cookie: Set-Cookie options ~~~~~~~~~~~~~~~~~~ These options can be added to a ``Set-Cookie`` header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too. - ``Secure`` limits cookies to HTTPS traffic only. - ``HttpOnly`` protects the contents of cookies from being read with JavaScript. - ``SameSite`` restricts how cookies are sent with requests from external sites. Can be set to ``'Lax'`` (recommended) or ``'Strict'``. ``Lax`` prevents sending cookies with CSRF-prone requests from external sites, such as submitting a form. ``Strict`` prevents sending cookies with all external requests, including following regular links. :: app.config.update( SESSION_COOKIE_SECURE=True, SESSION_COOKIE_HTTPONLY=True, SESSION_COOKIE_SAMESITE='Lax', ) response.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax') Specifying ``Expires`` or ``Max-Age`` options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed. :: # cookie expires after 10 minutes response.set_cookie('snakes', '3', max_age=600) For the session cookie, if :attr:`session.permanent <flask.session.permanent>` is set, then :data:`PERMANENT_SESSION_LIFETIME` is used to set the expiration. Flask's default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time. :: app.config.update( PERMANENT_SESSION_LIFETIME=600 ) @app.route('/login', methods=['POST']) def login(): ... session.clear() session['user_id'] = user.id session.permanent = True ... Use :class:`itsdangerous.TimedSerializer` to sign and validate other cookie values (or any values that need secure signatures). - https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie .. _samesite_support: https://caniuse.com/#feat=same-site-cookie-attribute HTTP Public Key Pinning (HPKP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks. .. warning:: Be careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly. - https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning","title":"Security Headers"},{"location":"server/","text":"Development Server \u00b6 .. currentmodule:: flask Starting with Flask 0.11 there are multiple built-in ways to run a development server. The best one is the :command: flask command line utility but you can also continue using the :meth: Flask.run method. Command Line \u00b6 The :command: flask command line script (:ref: cli ) is strongly recommended for development because it provides a superior reload experience due to how it loads the application. The basic usage is like this:: $ export FLASK_APP = my_application $ export FLASK_ENV = development $ flask run This enables the development environment, including the interactive debugger and reloader, and then starts the server on http://localhost:5000/ . The individual features of the server can be controlled by passing more arguments to the run option. For instance the reloader can be disabled:: $ flask run --no-reload .. note:: Prior to Flask 1.0 the :envvar:`FLASK_ENV` environment variable was not supported and you needed to enable debug mode by exporting ``FLASK_DEBUG=1``. This can still be used to control debug mode, but you should prefer setting the development environment as shown above. In Code \u00b6 The alternative way to start the application is through the :meth: Flask.run method. This will immediately launch a local server exactly the same way the :command: flask script does. Example:: if __name__ == '__main__': app.run() This works well for the common case but it does not work well for development which is why from Flask 0.11 onwards the :command: flask method is recommended. The reason for this is that due to how the reload mechanism works there are some bizarre side-effects (like executing certain code twice, sometimes crashing without message or dying when a syntax or import error happens). It is however still a perfectly valid method for invoking a non automatic reloading application.","title":"Development Server"},{"location":"server/#development-server","text":".. currentmodule:: flask Starting with Flask 0.11 there are multiple built-in ways to run a development server. The best one is the :command: flask command line utility but you can also continue using the :meth: Flask.run method.","title":"Development Server"},{"location":"server/#command-line","text":"The :command: flask command line script (:ref: cli ) is strongly recommended for development because it provides a superior reload experience due to how it loads the application. The basic usage is like this:: $ export FLASK_APP = my_application $ export FLASK_ENV = development $ flask run This enables the development environment, including the interactive debugger and reloader, and then starts the server on http://localhost:5000/ . The individual features of the server can be controlled by passing more arguments to the run option. For instance the reloader can be disabled:: $ flask run --no-reload .. note:: Prior to Flask 1.0 the :envvar:`FLASK_ENV` environment variable was not supported and you needed to enable debug mode by exporting ``FLASK_DEBUG=1``. This can still be used to control debug mode, but you should prefer setting the development environment as shown above.","title":"Command Line"},{"location":"server/#in-code","text":"The alternative way to start the application is through the :meth: Flask.run method. This will immediately launch a local server exactly the same way the :command: flask script does. Example:: if __name__ == '__main__': app.run() This works well for the common case but it does not work well for development which is why from Flask 0.11 onwards the :command: flask method is recommended. The reason for this is that due to how the reload mechanism works there are some bizarre side-effects (like executing certain code twice, sometimes crashing without message or dying when a syntax or import error happens). It is however still a perfectly valid method for invoking a non automatic reloading application.","title":"In Code"},{"location":"shell/","text":"Working with the Shell \u00b6 .. versionadded:: 0.3 One of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around. There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you're not triggering a request like a browser does which means that :data: ~flask.g , :data: ~flask.request and others are not available. But the code you want to test might depend on them, so what can you do? This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unittesting and other situations that require a faked request context. Generally it's recommended that you read the :ref: request-context chapter of the documentation first. Command Line Interface \u00b6 Starting with Flask 0.11 the recommended way to work with the shell is the flask shell command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context. For more information see :ref: cli . Creating a Request Context \u00b6 The easiest way to create a proper request context from the shell is by using the :attr: ~flask.Flask.test_request_context method which creates us a :class: ~flask.ctx.RequestContext : ctx = app.test_request_context() Normally you would use the with statement to make this request object active, but in the shell it's easier to use the :meth: ~flask.ctx.RequestContext.push and :meth: ~flask.ctx.RequestContext.pop methods by hand: ctx.push() From that point onwards you can work with the request object until you call pop : ctx.pop() Firing Before/After Request \u00b6 By just creating a request context, you still don't have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the :data: ~flask.g object etc. This however can easily be done yourself. Just call :meth: ~flask.Flask.preprocess_request : ctx = app.test_request_context() ctx.push() app.preprocess_request() Keep in mind that the :meth: ~flask.Flask.preprocess_request function might return a response object, in that case just ignore it. To shutdown a request, you need to trick a bit before the after request functions (triggered by :meth: ~flask.Flask.process_response ) operate on a response object: app.process_response(app.response_class()) ctx.pop() The functions registered as :meth: ~flask.Flask.teardown_request are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections). Further Improving the Shell Experience \u00b6 If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc. Just put them into a module (like shelltools ) and import from there: from shelltools import *","title":"Working with the Shell"},{"location":"shell/#working-with-the-shell","text":".. versionadded:: 0.3 One of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around. There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you're not triggering a request like a browser does which means that :data: ~flask.g , :data: ~flask.request and others are not available. But the code you want to test might depend on them, so what can you do? This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unittesting and other situations that require a faked request context. Generally it's recommended that you read the :ref: request-context chapter of the documentation first.","title":"Working with the Shell"},{"location":"shell/#command-line-interface","text":"Starting with Flask 0.11 the recommended way to work with the shell is the flask shell command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context. For more information see :ref: cli .","title":"Command Line Interface"},{"location":"shell/#creating-a-request-context","text":"The easiest way to create a proper request context from the shell is by using the :attr: ~flask.Flask.test_request_context method which creates us a :class: ~flask.ctx.RequestContext : ctx = app.test_request_context() Normally you would use the with statement to make this request object active, but in the shell it's easier to use the :meth: ~flask.ctx.RequestContext.push and :meth: ~flask.ctx.RequestContext.pop methods by hand: ctx.push() From that point onwards you can work with the request object until you call pop : ctx.pop()","title":"Creating a Request Context"},{"location":"shell/#firing-beforeafter-request","text":"By just creating a request context, you still don't have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the :data: ~flask.g object etc. This however can easily be done yourself. Just call :meth: ~flask.Flask.preprocess_request : ctx = app.test_request_context() ctx.push() app.preprocess_request() Keep in mind that the :meth: ~flask.Flask.preprocess_request function might return a response object, in that case just ignore it. To shutdown a request, you need to trick a bit before the after request functions (triggered by :meth: ~flask.Flask.process_response ) operate on a response object: app.process_response(app.response_class()) ctx.pop() The functions registered as :meth: ~flask.Flask.teardown_request are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections).","title":"Firing Before/After Request"},{"location":"shell/#further-improving-the-shell-experience","text":"If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc. Just put them into a module (like shelltools ) and import from there: from shelltools import *","title":"Further Improving the Shell Experience"},{"location":"signals/","text":"Signals \u00b6 .. versionadded:: 0.6 Starting with Flask 0.6, there is integrated support for signalling in Flask. This support is provided by the excellent blinker _ library and will gracefully fall back if it is not available. What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened. Flask comes with a couple of signals and other extensions might provide more. Also keep in mind that signals are intended to notify subscribers and should not encourage subscribers to modify data. You will notice that there are signals that appear to do the same thing like some of the builtin decorators do (eg: :data: ~flask.request_started is very similar to :meth: ~flask.Flask.before_request ). However, there are differences in how they work. The core :meth: ~flask.Flask.before_request handler, for example, is executed in a specific order and is able to abort the request early by returning a response. In contrast all signal handlers are executed in undefined order and do not modify any data. The big advantage of signals over handlers is that you can safely subscribe to them for just a split second. These temporary subscriptions are helpful for unit testing for example. Say you want to know what templates were rendered as part of a request: signals allow you to do exactly that. Subscribing to Signals \u00b6 To subscribe to a signal, you can use the :meth: ~blinker.base.Signal.connect method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the :meth: ~blinker.base.Signal.disconnect method. For all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension. For example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template:: from flask import template_rendered from contextlib import contextmanager @contextmanager def captured_templates ( app ): recorded = [] def record ( sender , template , context , ** extra ): recorded . append (( template , context )) template_rendered . connect ( record , app ) try : yield recorded finally : template_rendered . disconnect ( record , app ) This can now easily be paired with a test client:: with captured_templates(app) as templates: rv = app.test_client().get('/') assert rv.status_code == 200 assert len(templates) == 1 template, context = templates[0] assert template.name == 'index.html' assert len(context['items']) == 10 Make sure to subscribe with an extra **extra argument so that your calls don't fail if Flask introduces new arguments to the signals. All the template rendering in the code issued by the application app in the body of the with block will now be recorded in the templates variable. Whenever a template is rendered, the template object as well as context are appended to it. Additionally there is a convenient helper method (:meth: ~blinker.base.Signal.connected_to ) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument:: from flask import template_rendered def captured_templates ( app , recorded , ** extra ): def record ( sender , template , context ): recorded . append (( template , context )) return template_rendered . connected_to ( record , app ) The example above would then look like this:: templates = [] with captured_templates(app, templates, **extra): ... template, context = templates[0] .. admonition:: Blinker API Changes The :meth: ~blinker.base.Signal.connected_to method arrived in Blinker with version 1.1. Creating Signals \u00b6 If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom :class: ~blinker.base.Namespace .. This is what is recommended most of the time:: from blinker import Namespace my_signals = Namespace () Now you can create new signals like this:: model_saved = my_signals.signal('model-saved') The name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the :attr: ~blinker.base.NamedSignal.name attribute. .. admonition:: For Extension Developers If you are writing a Flask extension and you want to gracefully degrade for missing blinker installations, you can do so by using the :class: flask.signals.Namespace class. Sending Signals \u00b6 If you want to emit a signal, you can do so by calling the :meth: ~blinker.base.Signal.send method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:: class Model ( object ) : ... def save ( self ) : model_saved . send ( self ) Try to always pick a good sender. If you have a class that is emitting a signal, pass self as sender. If you are emitting a signal from a random function, you can pass current_app._get_current_object() as sender. .. admonition:: Passing Proxies as Senders Never pass :data: ~flask.current_app as sender to a signal. Use current_app._get_current_object() instead. The reason for this is that :data: ~flask.current_app is a proxy and not the real application object. Signals and Flask's Request Context \u00b6 Signals fully support :ref: request-context when receiving signals. Context-local variables are consistently available between :data: ~flask.request_started and :data: ~flask.request_finished , so you can rely on :class: flask.g and others as needed. Note the limitations described in :ref: signals-sending and the :data: ~flask.request_tearing_down signal. Decorator Based Signal Subscriptions \u00b6 With Blinker 1.1 you can also easily subscribe to signals by using the new :meth: ~blinker.base.NamedSignal.connect_via decorator:: from flask import template_rendered @template_rendered.connect_via ( app ) def when_template_rendered ( sender , template , context , ** extra ): print 'Template %s is rendered with %s ' % ( template . name , context ) Core Signals \u00b6 Take a look at :ref: core-signals-list for a list of all builtin signals. .. _blinker: https://pypi.org/project/blinker/","title":"Signals"},{"location":"signals/#signals","text":".. versionadded:: 0.6 Starting with Flask 0.6, there is integrated support for signalling in Flask. This support is provided by the excellent blinker _ library and will gracefully fall back if it is not available. What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened. Flask comes with a couple of signals and other extensions might provide more. Also keep in mind that signals are intended to notify subscribers and should not encourage subscribers to modify data. You will notice that there are signals that appear to do the same thing like some of the builtin decorators do (eg: :data: ~flask.request_started is very similar to :meth: ~flask.Flask.before_request ). However, there are differences in how they work. The core :meth: ~flask.Flask.before_request handler, for example, is executed in a specific order and is able to abort the request early by returning a response. In contrast all signal handlers are executed in undefined order and do not modify any data. The big advantage of signals over handlers is that you can safely subscribe to them for just a split second. These temporary subscriptions are helpful for unit testing for example. Say you want to know what templates were rendered as part of a request: signals allow you to do exactly that.","title":"Signals"},{"location":"signals/#subscribing-to-signals","text":"To subscribe to a signal, you can use the :meth: ~blinker.base.Signal.connect method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the :meth: ~blinker.base.Signal.disconnect method. For all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension. For example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template:: from flask import template_rendered from contextlib import contextmanager @contextmanager def captured_templates ( app ): recorded = [] def record ( sender , template , context , ** extra ): recorded . append (( template , context )) template_rendered . connect ( record , app ) try : yield recorded finally : template_rendered . disconnect ( record , app ) This can now easily be paired with a test client:: with captured_templates(app) as templates: rv = app.test_client().get('/') assert rv.status_code == 200 assert len(templates) == 1 template, context = templates[0] assert template.name == 'index.html' assert len(context['items']) == 10 Make sure to subscribe with an extra **extra argument so that your calls don't fail if Flask introduces new arguments to the signals. All the template rendering in the code issued by the application app in the body of the with block will now be recorded in the templates variable. Whenever a template is rendered, the template object as well as context are appended to it. Additionally there is a convenient helper method (:meth: ~blinker.base.Signal.connected_to ) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument:: from flask import template_rendered def captured_templates ( app , recorded , ** extra ): def record ( sender , template , context ): recorded . append (( template , context )) return template_rendered . connected_to ( record , app ) The example above would then look like this:: templates = [] with captured_templates(app, templates, **extra): ... template, context = templates[0] .. admonition:: Blinker API Changes The :meth: ~blinker.base.Signal.connected_to method arrived in Blinker with version 1.1.","title":"Subscribing to Signals"},{"location":"signals/#creating-signals","text":"If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom :class: ~blinker.base.Namespace .. This is what is recommended most of the time:: from blinker import Namespace my_signals = Namespace () Now you can create new signals like this:: model_saved = my_signals.signal('model-saved') The name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the :attr: ~blinker.base.NamedSignal.name attribute. .. admonition:: For Extension Developers If you are writing a Flask extension and you want to gracefully degrade for missing blinker installations, you can do so by using the :class: flask.signals.Namespace class.","title":"Creating Signals"},{"location":"signals/#sending-signals","text":"If you want to emit a signal, you can do so by calling the :meth: ~blinker.base.Signal.send method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:: class Model ( object ) : ... def save ( self ) : model_saved . send ( self ) Try to always pick a good sender. If you have a class that is emitting a signal, pass self as sender. If you are emitting a signal from a random function, you can pass current_app._get_current_object() as sender. .. admonition:: Passing Proxies as Senders Never pass :data: ~flask.current_app as sender to a signal. Use current_app._get_current_object() instead. The reason for this is that :data: ~flask.current_app is a proxy and not the real application object.","title":"Sending Signals"},{"location":"signals/#signals-and-flasks-request-context","text":"Signals fully support :ref: request-context when receiving signals. Context-local variables are consistently available between :data: ~flask.request_started and :data: ~flask.request_finished , so you can rely on :class: flask.g and others as needed. Note the limitations described in :ref: signals-sending and the :data: ~flask.request_tearing_down signal.","title":"Signals and Flask's Request Context"},{"location":"signals/#decorator-based-signal-subscriptions","text":"With Blinker 1.1 you can also easily subscribe to signals by using the new :meth: ~blinker.base.NamedSignal.connect_via decorator:: from flask import template_rendered @template_rendered.connect_via ( app ) def when_template_rendered ( sender , template , context , ** extra ): print 'Template %s is rendered with %s ' % ( template . name , context )","title":"Decorator Based Signal Subscriptions"},{"location":"signals/#core-signals","text":"Take a look at :ref: core-signals-list for a list of all builtin signals. .. _blinker: https://pypi.org/project/blinker/","title":"Core Signals"},{"location":"styleguide/","text":"Pocoo Styleguide \u00b6 The Pocoo styleguide is the styleguide for all Pocoo Projects, including Flask. This styleguide is a requirement for Patches to Flask and a recommendation for Flask extensions. In general the Pocoo Styleguide closely follows :pep: 8 with some small differences and extensions. General Layout \u00b6 Indentation: 4 real spaces. No tabs, no exceptions. Maximum line length: 79 characters with a soft limit for 84 if absolutely necessary. Try to avoid too nested code by cleverly placing break , continue and return statements. Continuing long statements: To continue a statement you can use backslashes in which case you should align the next line with the last dot or equal sign, or indent four spaces:: this_is_a_very_long(function_call, 'with many parameters' ) \\ .that_returns_an_object_with_an_attribute MyModel.query.filter(MyModel.scalar &gt; 120) \\ .order_by(MyModel.name.desc()) \\ .limit(10) If you break in a statement with parentheses or braces, align to the braces:: this_is_a_very_long(function_call, 'with many parameters', 23, 42, 'and even more') For lists or tuples with many items, break immediately after the opening brace:: items = [ 'this is the first', 'set of items', 'with more items', 'to come in this line', 'like this' ] Blank lines: Top level functions and classes are separated by two lines, everything else by one. Do not use too many blank lines to separate logical segments in code. Example:: def hello ( name ) : print 'Hello %s!' % name def goodbye ( name ) : print 'See you %s.' % name class MyClass ( object ) : \"\"\"This is a simple docstring\"\"\" def __init__ ( self , name ) : self . name = name def get_annoying_name ( self ) : return self . name . upper () + '!!!!111' Expressions and Statements \u00b6 General whitespace rules: No whitespace for unary operators that are not words (e.g.: - , ~ etc.) as well on the inner side of parentheses. Whitespace is placed between binary operators. Good:: exp = -1.05 value = (item_value / item_count) * offset / exp value = my_list[index] value = my_dict['key'] Bad:: exp = - 1.05 value = ( item_value / item_count ) * offset / exp value = (item_value/item_count)*offset/exp value=( item_value/item_count ) * offset/exp value = my_list[ index ] value = my_dict ['key'] Yoda statements are a no-go: Never compare constant with variable, always variable with constant: Good:: if method == 'md5': pass Bad:: if 'md5' == method: pass Comparisons: against arbitrary types: == and != against singletons with is and is not (eg: foo is not None ) never compare something with True or False (for example never do foo == False , do not foo instead) Negated containment checks: use foo not in bar instead of not foo in bar Instance checks: isinstance(a, C) instead of type(A) is C , but try to avoid instance checks in general. Check for features. Naming Conventions \u00b6 Class names: CamelCase , with acronyms kept uppercase ( HTTPWriter and not HttpWriter ) Variable names: lowercase_with_underscores Method and function names: lowercase_with_underscores Constants: UPPERCASE_WITH_UNDERSCORES precompiled regular expressions: name_re Protected members are prefixed with a single underscore. Double underscores are reserved for mixin classes. On classes with keywords, trailing underscores are appended. Clashes with builtins are allowed and must not be resolved by appending an underline to the variable name. If the function needs to access a shadowed builtin, rebind the builtin to a different name instead. Function and method arguments: class methods: cls as first parameter instance methods: self as first parameter lambdas for properties might have the first parameter replaced with x like in display_name = property(lambda x: x.real_name or x.username) Docstrings \u00b6 Docstring conventions: All docstrings are formatted with reStructuredText as understood by Sphinx. Depending on the number of lines in the docstring, they are laid out differently. If it's just one line, the closing triple quote is on the same line as the opening, otherwise the text is on the same line as the opening quote and the triple quote that closes the string on its own line:: def foo(): \"\"\"This is a simple docstring\"\"\" def bar(): \"\"\"This is a longer docstring with so much information in there that it spans three lines. In this case the closing triple quote is on its own line. \"\"\" Module header: The module header consists of a utf-8 encoding declaration (if non ASCII letters are used, but it is recommended all the time) and a standard docstring:: # -*- coding: utf-8 -*- \"\"\" package.module ~~~~~~~~~~~~~~ A brief description goes here. :copyright: (c) YEAR by AUTHOR. :license: LICENSE_NAME, see LICENSE_FILE for more details. \"\"\" Please keep in mind that proper copyrights and license files are a requirement for approved Flask extensions. Comments \u00b6 Rules for comments are similar to docstrings. Both are formatted with reStructuredText. If a comment is used to document an attribute, put a colon after the opening pound sign ( # ):: class User ( object ) : # : the name of the user as unicode string name = Column ( String ) # : the sha1 hash of the password + inline salt pw_hash = Column ( String )","title":"Pocoo Styleguide"},{"location":"styleguide/#pocoo-styleguide","text":"The Pocoo styleguide is the styleguide for all Pocoo Projects, including Flask. This styleguide is a requirement for Patches to Flask and a recommendation for Flask extensions. In general the Pocoo Styleguide closely follows :pep: 8 with some small differences and extensions.","title":"Pocoo Styleguide"},{"location":"styleguide/#general-layout","text":"Indentation: 4 real spaces. No tabs, no exceptions. Maximum line length: 79 characters with a soft limit for 84 if absolutely necessary. Try to avoid too nested code by cleverly placing break , continue and return statements. Continuing long statements: To continue a statement you can use backslashes in which case you should align the next line with the last dot or equal sign, or indent four spaces:: this_is_a_very_long(function_call, 'with many parameters' ) \\ .that_returns_an_object_with_an_attribute MyModel.query.filter(MyModel.scalar &gt; 120) \\ .order_by(MyModel.name.desc()) \\ .limit(10) If you break in a statement with parentheses or braces, align to the braces:: this_is_a_very_long(function_call, 'with many parameters', 23, 42, 'and even more') For lists or tuples with many items, break immediately after the opening brace:: items = [ 'this is the first', 'set of items', 'with more items', 'to come in this line', 'like this' ] Blank lines: Top level functions and classes are separated by two lines, everything else by one. Do not use too many blank lines to separate logical segments in code. Example:: def hello ( name ) : print 'Hello %s!' % name def goodbye ( name ) : print 'See you %s.' % name class MyClass ( object ) : \"\"\"This is a simple docstring\"\"\" def __init__ ( self , name ) : self . name = name def get_annoying_name ( self ) : return self . name . upper () + '!!!!111'","title":"General Layout"},{"location":"styleguide/#expressions-and-statements","text":"General whitespace rules: No whitespace for unary operators that are not words (e.g.: - , ~ etc.) as well on the inner side of parentheses. Whitespace is placed between binary operators. Good:: exp = -1.05 value = (item_value / item_count) * offset / exp value = my_list[index] value = my_dict['key'] Bad:: exp = - 1.05 value = ( item_value / item_count ) * offset / exp value = (item_value/item_count)*offset/exp value=( item_value/item_count ) * offset/exp value = my_list[ index ] value = my_dict ['key'] Yoda statements are a no-go: Never compare constant with variable, always variable with constant: Good:: if method == 'md5': pass Bad:: if 'md5' == method: pass Comparisons: against arbitrary types: == and != against singletons with is and is not (eg: foo is not None ) never compare something with True or False (for example never do foo == False , do not foo instead) Negated containment checks: use foo not in bar instead of not foo in bar Instance checks: isinstance(a, C) instead of type(A) is C , but try to avoid instance checks in general. Check for features.","title":"Expressions and Statements"},{"location":"styleguide/#naming-conventions","text":"Class names: CamelCase , with acronyms kept uppercase ( HTTPWriter and not HttpWriter ) Variable names: lowercase_with_underscores Method and function names: lowercase_with_underscores Constants: UPPERCASE_WITH_UNDERSCORES precompiled regular expressions: name_re Protected members are prefixed with a single underscore. Double underscores are reserved for mixin classes. On classes with keywords, trailing underscores are appended. Clashes with builtins are allowed and must not be resolved by appending an underline to the variable name. If the function needs to access a shadowed builtin, rebind the builtin to a different name instead. Function and method arguments: class methods: cls as first parameter instance methods: self as first parameter lambdas for properties might have the first parameter replaced with x like in display_name = property(lambda x: x.real_name or x.username)","title":"Naming Conventions"},{"location":"styleguide/#docstrings","text":"Docstring conventions: All docstrings are formatted with reStructuredText as understood by Sphinx. Depending on the number of lines in the docstring, they are laid out differently. If it's just one line, the closing triple quote is on the same line as the opening, otherwise the text is on the same line as the opening quote and the triple quote that closes the string on its own line:: def foo(): \"\"\"This is a simple docstring\"\"\" def bar(): \"\"\"This is a longer docstring with so much information in there that it spans three lines. In this case the closing triple quote is on its own line. \"\"\" Module header: The module header consists of a utf-8 encoding declaration (if non ASCII letters are used, but it is recommended all the time) and a standard docstring:: # -*- coding: utf-8 -*- \"\"\" package.module ~~~~~~~~~~~~~~ A brief description goes here. :copyright: (c) YEAR by AUTHOR. :license: LICENSE_NAME, see LICENSE_FILE for more details. \"\"\" Please keep in mind that proper copyrights and license files are a requirement for approved Flask extensions.","title":"Docstrings"},{"location":"styleguide/#comments","text":"Rules for comments are similar to docstrings. Both are formatted with reStructuredText. If a comment is used to document an attribute, put a colon after the opening pound sign ( # ):: class User ( object ) : # : the name of the user as unicode string name = Column ( String ) # : the sha1 hash of the password + inline salt pw_hash = Column ( String )","title":"Comments"},{"location":"testing/","text":"Testing Flask Applications \u00b6 Something that is untested is broken. The origin of this quote is unknown and while it is not entirely correct, it is also not far from the truth. Untested applications make it hard to improve existing code and developers of untested applications tend to become pretty paranoid. If an application has automated tests, you can safely make changes and instantly know if anything breaks. Flask provides a way to test your application by exposing the Werkzeug test :class: ~werkzeug.test.Client and handling the context locals for you. You can then use that with your favourite testing solution. In this documentation we will use the pytest _ package as the base framework for our tests. You can install it with pip , like so:: $ pip install pytest https://pytest.org The Application \u00b6 First, we need an application to test; we will use the application from the :ref: tutorial . If you don't have that application yet, get the source code from :gh: the examples <examples/tutorial> . The Testing Skeleton \u00b6 We begin by adding a tests directory under the application root. Then create a Python file to store our tests (:file: test_flaskr.py ). When we format the filename like test_*.py , it will be auto-discoverable by pytest. Next, we create a pytest fixture _ called :func: client that configures the application for testing and initializes a new database:: import os import tempfile import pytest from flaskr import flaskr @pytest.fixture def client (): db_fd , flaskr . app . config [ 'DATABASE' ] = tempfile . mkstemp () flaskr . app . config [ 'TESTING' ] = True client = flaskr . app . test_client () with flaskr . app . app_context (): flaskr . init_db () yield client os . close ( db_fd ) os . unlink ( flaskr . app . config [ 'DATABASE' ]) This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us. During setup, the TESTING config flag is activated. What this does is disable error catching during request handling, so that you get better error reports when performing test requests against the application. Because SQLite3 is filesystem-based, we can easily use the :mod: tempfile module to create a temporary database and initialize it. The :func: ~tempfile.mkstemp function does two things for us: it returns a low-level file handle and a random file name, the latter we use as database name. We just have to keep the db_fd around so that we can use the :func: os.close function to close the file. To delete the database after the test, the fixture closes the file and removes it from the filesystem. If we now run the test suite, we should see the following output:: $ pytest ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 0 items =========== no tests ran in 0 .07 seconds ============ Even though it did not run any actual tests, we already know that our flaskr application is syntactically valid, otherwise the import would have died with an exception. https://docs.pytest.org/en/latest/fixture.html The First Test \u00b6 Now it's time to start testing the functionality of the application. Let's check that the application shows \"No entries here so far\" if we access the root of the application ( / ). To do this, we add a new test function to :file: test_flaskr.py , like this:: def test_empty_db(client): \"\"\"Start with a blank database.\"\"\" rv = client.get('/') assert b'No entries here so far' in rv.data Notice that our test functions begin with the word test ; this allows pytest _ to automatically identify the function as a test to run. By using client.get we can send an HTTP GET request to the application with the given path. The return value will be a :class: ~flask.Flask.response_class object. We can now use the :attr: ~werkzeug.wrappers.BaseResponse.data attribute to inspect the return value (as string) from the application. In this case, we ensure that 'No entries here so far' is part of the output. Run it again and you should see one passing test:: $ pytest -v ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 1 items tests/test_flaskr.py::test_empty_db PASSED ============= 1 passed in 0 .10 seconds ============== Logging In and Out \u00b6 The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to follow_redirects . Add the following two functions to your :file: test_flaskr.py file:: def login(client, username, password): return client.post('/login', data=dict( username=username, password=password ), follow_redirects=True) def logout(client): return client.get('/logout', follow_redirects=True) Now we can easily test that logging in and out works and that it fails with invalid credentials. Add this new test function:: def test_login_logout(client): \"\"\"Make sure login and logout works.\"\"\" rv = login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD']) assert b'You were logged in' in rv.data rv = logout(client) assert b'You were logged out' in rv.data rv = login(client, flaskr.app.config['USERNAME'] + 'x', flaskr.app.config['PASSWORD']) assert b'Invalid username' in rv.data rv = login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD'] + 'x') assert b'Invalid password' in rv.data Test Adding Messages \u00b6 We should also test that adding messages works. Add a new test function like this:: def test_messages(client): \"\"\"Test that messages work.\"\"\" login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD']) rv = client.post('/add', data=dict( title='&lt;Hello&gt;', text='&lt;strong&gt;HTML&lt;/strong&gt; allowed here' ), follow_redirects=True) assert b'No entries here so far' not in rv.data assert b'&amp;lt;Hello&amp;gt;' in rv.data assert b'&lt;strong&gt;HTML&lt;/strong&gt; allowed here' in rv.data Here we check that HTML is allowed in the text but not in the title, which is the intended behavior. Running that should now give us three passing tests:: $ pytest -v ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 3 items tests/test_flaskr.py::test_empty_db PASSED tests/test_flaskr.py::test_login_logout PASSED tests/test_flaskr.py::test_messages PASSED ============= 3 passed in 0 .23 seconds ============== Other Testing Tricks \u00b6 Besides using the test client as shown above, there is also the :meth: ~flask.Flask.test_request_context method that can be used in combination with the with statement to activate a request context temporarily. With this you can access the :class: ~flask.request , :class: ~flask.g and :class: ~flask.session objects like in view functions. Here is a full example that demonstrates this approach:: import flask app = flask . Flask ( __name__ ) with app . test_request_context ( '/?name=Peter' ): assert flask . request . path == '/' assert flask . request . args [ 'name' ] == 'Peter' All the other objects that are context bound can be used in the same way. If you want to test your application with different configurations and there does not seem to be a good way to do that, consider switching to application factories (see :ref: app-factories ). Note however that if you are using a test request context, the :meth: ~flask.Flask.before_request and :meth: ~flask.Flask.after_request functions are not called automatically. However :meth: ~flask.Flask.teardown_request functions are indeed executed when the test request context leaves the with block. If you do want the :meth: ~flask.Flask.before_request functions to be called as well, you need to call :meth: ~flask.Flask.preprocess_request yourself:: app = flask.Flask(__name__) with app.test_request_context('/?name=Peter'): app.preprocess_request() ... This can be necessary to open database connections or something similar depending on how your application was designed. If you want to call the :meth: ~flask.Flask.after_request functions you need to call into :meth: ~flask.Flask.process_response which however requires that you pass it a response object:: app = flask.Flask(__name__) with app.test_request_context('/?name=Peter'): resp = Response('...') resp = app.process_response(resp) ... This in general is less useful because at that point you can directly start using the test client. Faking Resources and Context \u00b6 .. versionadded:: 0.10 A very common pattern is to store user authorization information and database connections on the application context or the :attr: flask.g object. The general pattern for this is to put the object on there on first usage and then to remove it on a teardown. Imagine for instance this code to get the current user:: def get_user(): user = getattr(g, 'user', None) if user is None: user = fetch_current_user_from_database() g.user = user return user For a test it would be nice to override this user from the outside without having to change some code. This can be accomplished with hooking the :data: flask.appcontext_pushed signal:: from contextlib import contextmanager from flask import appcontext_pushed , g @contextmanager def user_set ( app , user ): def handler ( sender , ** kwargs ): g . user = user with appcontext_pushed . connected_to ( handler , app ): yield And then to use it:: from flask import json , jsonify @app.route ( '/users/me' ) def users_me (): return jsonify ( username = g . user . username ) with user_set ( app , my_user ): with app . test_client () as c : resp = c . get ( '/users/me' ) data = json . loads ( resp . data ) self . assert_equal ( data [ 'username' ], my_user . username ) Keeping the Context Around \u00b6 .. versionadded:: 0.4 Sometimes it is helpful to trigger a regular request but still keep the context around for a little longer so that additional introspection can happen. With Flask 0.4 this is possible by using the :meth: ~flask.Flask.test_client with a with block:: app = flask.Flask(__name__) with app.test_client() as c: rv = c.get('/?tequila=42') assert request.args['tequila'] == '42' If you were to use just the :meth: ~flask.Flask.test_client without the with block, the assert would fail with an error because request is no longer available (because you are trying to use it outside of the actual request). Accessing and Modifying Sessions \u00b6 .. versionadded:: 0.8 Sometimes it can be very helpful to access or modify the sessions from the test client. Generally there are two ways for this. If you just want to ensure that a session has certain keys set to certain values you can just keep the context around and access :data: flask.session :: with app.test_client() as c: rv = c.get('/') assert flask.session['foo'] == 42 This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called \u201csession transaction\u201d which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored. This works independently of the session backend used:: with app.test_client() as c: with c.session_transaction() as sess: sess['a_key'] = 'a value' # once this is reached the session was stored Note that in this case you have to use the sess object instead of the :data: flask.session proxy. The object however itself will provide the same interface. Testing JSON APIs \u00b6 .. versionadded:: 1.0 Flask has great support for JSON, and is a popular choice for building JSON APIs. Making requests with JSON data and examining JSON data in responses is very convenient:: from flask import request , jsonify @app.route ( '/api/auth' ) def auth (): json_data = request . get_json () email = json_data [ 'email' ] password = json_data [ 'password' ] return jsonify ( token = generate_token ( email , password )) with app . test_client () as c : rv = c . post ( '/api/auth' , json = { 'email' : 'flask@example.com' , 'password' : 'secret' }) json_data = rv . get_json () assert verify_token ( email , json_data [ 'token' ]) Passing the json argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to application/json . You can get the JSON data from the request or response with get_json . Testing CLI Commands \u00b6 Click comes with utilities for testing _ your CLI commands. A :class: ~click.testing.CliRunner runs commands in isolation and captures the output in a :class: ~click.testing.Result object. Flask provides :meth: ~flask.Flask.test_cli_runner to create a :class: ~flask.testing.FlaskCliRunner that passes the Flask app to the CLI automatically. Use its :meth: ~flask.testing.FlaskCliRunner.invoke method to call commands in the same way they would be called from the command line. :: import click @app.cli.command ( 'hello' ) @click.option ( '--name' , default = 'World' ) def hello_command ( name ) click . echo ( f 'Hello, {name}!' ) def test_hello (): runner = app . test_cli_runner () # invoke the command directly result = runner . invoke ( hello_command , [ '--name' , 'Flask' ]) assert 'Hello, Flask' in result . output # or by name result = runner . invoke ( args = [ 'hello' ]) assert 'World' in result . output In the example above, invoking the command by name is useful because it verifies that the command was correctly registered with the app. If you want to test how your command parses parameters, without running the command, use its :meth: ~click.BaseCommand.make_context method. This is useful for testing complex validation rules and custom types. :: def upper(ctx, param, value): if value is not None: return value.upper() @app.cli.command('hello') @click.option('--name', default='World', callback=upper) def hello_command(name) click.echo(f'Hello, {name}!') def test_hello_params(): context = hello_command.make_context('hello', ['--name', 'flask']) assert context.params['name'] == 'FLASK' .. _click: http://click.pocoo.org/ .. _utilities for testing: http://click.pocoo.org/testing","title":"Testing Flask Applications"},{"location":"testing/#testing-flask-applications","text":"Something that is untested is broken. The origin of this quote is unknown and while it is not entirely correct, it is also not far from the truth. Untested applications make it hard to improve existing code and developers of untested applications tend to become pretty paranoid. If an application has automated tests, you can safely make changes and instantly know if anything breaks. Flask provides a way to test your application by exposing the Werkzeug test :class: ~werkzeug.test.Client and handling the context locals for you. You can then use that with your favourite testing solution. In this documentation we will use the pytest _ package as the base framework for our tests. You can install it with pip , like so:: $ pip install pytest https://pytest.org","title":"Testing Flask Applications"},{"location":"testing/#the-application","text":"First, we need an application to test; we will use the application from the :ref: tutorial . If you don't have that application yet, get the source code from :gh: the examples <examples/tutorial> .","title":"The Application"},{"location":"testing/#the-testing-skeleton","text":"We begin by adding a tests directory under the application root. Then create a Python file to store our tests (:file: test_flaskr.py ). When we format the filename like test_*.py , it will be auto-discoverable by pytest. Next, we create a pytest fixture _ called :func: client that configures the application for testing and initializes a new database:: import os import tempfile import pytest from flaskr import flaskr @pytest.fixture def client (): db_fd , flaskr . app . config [ 'DATABASE' ] = tempfile . mkstemp () flaskr . app . config [ 'TESTING' ] = True client = flaskr . app . test_client () with flaskr . app . app_context (): flaskr . init_db () yield client os . close ( db_fd ) os . unlink ( flaskr . app . config [ 'DATABASE' ]) This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us. During setup, the TESTING config flag is activated. What this does is disable error catching during request handling, so that you get better error reports when performing test requests against the application. Because SQLite3 is filesystem-based, we can easily use the :mod: tempfile module to create a temporary database and initialize it. The :func: ~tempfile.mkstemp function does two things for us: it returns a low-level file handle and a random file name, the latter we use as database name. We just have to keep the db_fd around so that we can use the :func: os.close function to close the file. To delete the database after the test, the fixture closes the file and removes it from the filesystem. If we now run the test suite, we should see the following output:: $ pytest ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 0 items =========== no tests ran in 0 .07 seconds ============ Even though it did not run any actual tests, we already know that our flaskr application is syntactically valid, otherwise the import would have died with an exception. https://docs.pytest.org/en/latest/fixture.html","title":"The Testing Skeleton"},{"location":"testing/#the-first-test","text":"Now it's time to start testing the functionality of the application. Let's check that the application shows \"No entries here so far\" if we access the root of the application ( / ). To do this, we add a new test function to :file: test_flaskr.py , like this:: def test_empty_db(client): \"\"\"Start with a blank database.\"\"\" rv = client.get('/') assert b'No entries here so far' in rv.data Notice that our test functions begin with the word test ; this allows pytest _ to automatically identify the function as a test to run. By using client.get we can send an HTTP GET request to the application with the given path. The return value will be a :class: ~flask.Flask.response_class object. We can now use the :attr: ~werkzeug.wrappers.BaseResponse.data attribute to inspect the return value (as string) from the application. In this case, we ensure that 'No entries here so far' is part of the output. Run it again and you should see one passing test:: $ pytest -v ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 1 items tests/test_flaskr.py::test_empty_db PASSED ============= 1 passed in 0 .10 seconds ==============","title":"The First Test"},{"location":"testing/#logging-in-and-out","text":"The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to follow_redirects . Add the following two functions to your :file: test_flaskr.py file:: def login(client, username, password): return client.post('/login', data=dict( username=username, password=password ), follow_redirects=True) def logout(client): return client.get('/logout', follow_redirects=True) Now we can easily test that logging in and out works and that it fails with invalid credentials. Add this new test function:: def test_login_logout(client): \"\"\"Make sure login and logout works.\"\"\" rv = login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD']) assert b'You were logged in' in rv.data rv = logout(client) assert b'You were logged out' in rv.data rv = login(client, flaskr.app.config['USERNAME'] + 'x', flaskr.app.config['PASSWORD']) assert b'Invalid username' in rv.data rv = login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD'] + 'x') assert b'Invalid password' in rv.data","title":"Logging In and Out"},{"location":"testing/#test-adding-messages","text":"We should also test that adding messages works. Add a new test function like this:: def test_messages(client): \"\"\"Test that messages work.\"\"\" login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD']) rv = client.post('/add', data=dict( title='&lt;Hello&gt;', text='&lt;strong&gt;HTML&lt;/strong&gt; allowed here' ), follow_redirects=True) assert b'No entries here so far' not in rv.data assert b'&amp;lt;Hello&amp;gt;' in rv.data assert b'&lt;strong&gt;HTML&lt;/strong&gt; allowed here' in rv.data Here we check that HTML is allowed in the text but not in the title, which is the intended behavior. Running that should now give us three passing tests:: $ pytest -v ================ test session starts ================ rootdir: ./flask/examples/flaskr, inifile: setup.cfg collected 3 items tests/test_flaskr.py::test_empty_db PASSED tests/test_flaskr.py::test_login_logout PASSED tests/test_flaskr.py::test_messages PASSED ============= 3 passed in 0 .23 seconds ==============","title":"Test Adding Messages"},{"location":"testing/#other-testing-tricks","text":"Besides using the test client as shown above, there is also the :meth: ~flask.Flask.test_request_context method that can be used in combination with the with statement to activate a request context temporarily. With this you can access the :class: ~flask.request , :class: ~flask.g and :class: ~flask.session objects like in view functions. Here is a full example that demonstrates this approach:: import flask app = flask . Flask ( __name__ ) with app . test_request_context ( '/?name=Peter' ): assert flask . request . path == '/' assert flask . request . args [ 'name' ] == 'Peter' All the other objects that are context bound can be used in the same way. If you want to test your application with different configurations and there does not seem to be a good way to do that, consider switching to application factories (see :ref: app-factories ). Note however that if you are using a test request context, the :meth: ~flask.Flask.before_request and :meth: ~flask.Flask.after_request functions are not called automatically. However :meth: ~flask.Flask.teardown_request functions are indeed executed when the test request context leaves the with block. If you do want the :meth: ~flask.Flask.before_request functions to be called as well, you need to call :meth: ~flask.Flask.preprocess_request yourself:: app = flask.Flask(__name__) with app.test_request_context('/?name=Peter'): app.preprocess_request() ... This can be necessary to open database connections or something similar depending on how your application was designed. If you want to call the :meth: ~flask.Flask.after_request functions you need to call into :meth: ~flask.Flask.process_response which however requires that you pass it a response object:: app = flask.Flask(__name__) with app.test_request_context('/?name=Peter'): resp = Response('...') resp = app.process_response(resp) ... This in general is less useful because at that point you can directly start using the test client.","title":"Other Testing Tricks"},{"location":"testing/#faking-resources-and-context","text":".. versionadded:: 0.10 A very common pattern is to store user authorization information and database connections on the application context or the :attr: flask.g object. The general pattern for this is to put the object on there on first usage and then to remove it on a teardown. Imagine for instance this code to get the current user:: def get_user(): user = getattr(g, 'user', None) if user is None: user = fetch_current_user_from_database() g.user = user return user For a test it would be nice to override this user from the outside without having to change some code. This can be accomplished with hooking the :data: flask.appcontext_pushed signal:: from contextlib import contextmanager from flask import appcontext_pushed , g @contextmanager def user_set ( app , user ): def handler ( sender , ** kwargs ): g . user = user with appcontext_pushed . connected_to ( handler , app ): yield And then to use it:: from flask import json , jsonify @app.route ( '/users/me' ) def users_me (): return jsonify ( username = g . user . username ) with user_set ( app , my_user ): with app . test_client () as c : resp = c . get ( '/users/me' ) data = json . loads ( resp . data ) self . assert_equal ( data [ 'username' ], my_user . username )","title":"Faking Resources and Context"},{"location":"testing/#keeping-the-context-around","text":".. versionadded:: 0.4 Sometimes it is helpful to trigger a regular request but still keep the context around for a little longer so that additional introspection can happen. With Flask 0.4 this is possible by using the :meth: ~flask.Flask.test_client with a with block:: app = flask.Flask(__name__) with app.test_client() as c: rv = c.get('/?tequila=42') assert request.args['tequila'] == '42' If you were to use just the :meth: ~flask.Flask.test_client without the with block, the assert would fail with an error because request is no longer available (because you are trying to use it outside of the actual request).","title":"Keeping the Context Around"},{"location":"testing/#accessing-and-modifying-sessions","text":".. versionadded:: 0.8 Sometimes it can be very helpful to access or modify the sessions from the test client. Generally there are two ways for this. If you just want to ensure that a session has certain keys set to certain values you can just keep the context around and access :data: flask.session :: with app.test_client() as c: rv = c.get('/') assert flask.session['foo'] == 42 This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called \u201csession transaction\u201d which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored. This works independently of the session backend used:: with app.test_client() as c: with c.session_transaction() as sess: sess['a_key'] = 'a value' # once this is reached the session was stored Note that in this case you have to use the sess object instead of the :data: flask.session proxy. The object however itself will provide the same interface.","title":"Accessing and Modifying Sessions"},{"location":"testing/#testing-json-apis","text":".. versionadded:: 1.0 Flask has great support for JSON, and is a popular choice for building JSON APIs. Making requests with JSON data and examining JSON data in responses is very convenient:: from flask import request , jsonify @app.route ( '/api/auth' ) def auth (): json_data = request . get_json () email = json_data [ 'email' ] password = json_data [ 'password' ] return jsonify ( token = generate_token ( email , password )) with app . test_client () as c : rv = c . post ( '/api/auth' , json = { 'email' : 'flask@example.com' , 'password' : 'secret' }) json_data = rv . get_json () assert verify_token ( email , json_data [ 'token' ]) Passing the json argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to application/json . You can get the JSON data from the request or response with get_json .","title":"Testing JSON APIs"},{"location":"testing/#testing-cli-commands","text":"Click comes with utilities for testing _ your CLI commands. A :class: ~click.testing.CliRunner runs commands in isolation and captures the output in a :class: ~click.testing.Result object. Flask provides :meth: ~flask.Flask.test_cli_runner to create a :class: ~flask.testing.FlaskCliRunner that passes the Flask app to the CLI automatically. Use its :meth: ~flask.testing.FlaskCliRunner.invoke method to call commands in the same way they would be called from the command line. :: import click @app.cli.command ( 'hello' ) @click.option ( '--name' , default = 'World' ) def hello_command ( name ) click . echo ( f 'Hello, {name}!' ) def test_hello (): runner = app . test_cli_runner () # invoke the command directly result = runner . invoke ( hello_command , [ '--name' , 'Flask' ]) assert 'Hello, Flask' in result . output # or by name result = runner . invoke ( args = [ 'hello' ]) assert 'World' in result . output In the example above, invoking the command by name is useful because it verifies that the command was correctly registered with the app. If you want to test how your command parses parameters, without running the command, use its :meth: ~click.BaseCommand.make_context method. This is useful for testing complex validation rules and custom types. :: def upper(ctx, param, value): if value is not None: return value.upper() @app.cli.command('hello') @click.option('--name', default='World', callback=upper) def hello_command(name) click.echo(f'Hello, {name}!') def test_hello_params(): context = hello_command.make_context('hello', ['--name', 'flask']) assert context.params['name'] == 'FLASK' .. _click: http://click.pocoo.org/ .. _utilities for testing: http://click.pocoo.org/testing","title":"Testing CLI Commands"},{"location":"unicode/","text":"Unicode in Flask \u00b6 Flask, like Jinja2 and Werkzeug, is totally Unicode based when it comes to text. Not only these libraries, also the majority of web related Python libraries that deal with text. If you don't know Unicode so far, you should probably read The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets <https://www.joelonsoftware.com/articles/Unicode.html> _. This part of the documentation just tries to cover the very basics so that you have a pleasant experience with Unicode related things. Automatic Conversion \u00b6 Flask has a few assumptions about your application (which you can change of course) that give you basic and painless Unicode support: the encoding for text on your website is UTF-8 internally you will always use Unicode exclusively for text except for literal strings with only ASCII character points. encoding and decoding happens whenever you are talking over a protocol that requires bytes to be transmitted. So what does this mean to you? HTTP is based on bytes. Not only the protocol, also the system used to address documents on servers (so called URIs or URLs). However HTML which is usually transmitted on top of HTTP supports a large variety of character sets and which ones are used, are transmitted in an HTTP header. To not make this too complex Flask just assumes that if you are sending Unicode out you want it to be UTF-8 encoded. Flask will do the encoding and setting of the appropriate headers for you. The same is true if you are talking to databases with the help of SQLAlchemy or a similar ORM system. Some databases have a protocol that already transmits Unicode and if they do not, SQLAlchemy or your other ORM should take care of that. The Golden Rule \u00b6 So the rule of thumb: if you are not dealing with binary data, work with Unicode. What does working with Unicode in Python 2.x mean? as long as you are using ASCII charpoints only (basically numbers, some special characters of latin letters without umlauts or anything fancy) you can use regular string literals ( 'Hello World' ). if you need anything else than ASCII in a string you have to mark this string as Unicode string by prefixing it with a lowercase u . (like u'H\u00e4nsel und Gretel' ) if you are using non-Unicode characters in your Python files you have to tell Python which encoding your file uses. Again, I recommend UTF-8 for this purpose. To tell the interpreter your encoding you can put the # -*- coding: utf-8 -*- into the first or second line of your Python source file. Jinja is configured to decode the template files from UTF-8. So make sure to tell your editor to save the file as UTF-8 there as well. Encoding and Decoding Yourself \u00b6 If you are talking with a filesystem or something that is not really based on Unicode you will have to ensure that you decode properly when working with Unicode interface. So for example if you want to load a file on the filesystem and embed it into a Jinja2 template you will have to decode it from the encoding of that file. Here the old problem that text files do not specify their encoding comes into play. So do yourself a favour and limit yourself to UTF-8 for text files as well. Anyways. To load such a file with Unicode you can use the built-in :meth: str.decode method:: def read_file(filename, charset='utf-8'): with open(filename, 'r') as f: return f.read().decode(charset) To go from Unicode into a specific charset such as UTF-8 you can use the :meth: unicode.encode method:: def write_file(filename, contents, charset='utf-8'): with open(filename, 'w') as f: f.write(contents.encode(charset)) Configuring Editors \u00b6 Most editors save as UTF-8 by default nowadays but in case your editor is not configured to do this you have to change it. Here some common ways to set your editor to store as UTF-8: Vim: put set enc=utf-8 to your .vimrc file. Emacs: either use an encoding cookie or put this into your .emacs file:: (prefer-coding-system 'utf-8) (setq default-buffer-file-coding-system 'utf-8) Notepad++: Go to Settings -> Preferences ... Select the \"New Document/Default Directory\" tab Select \"UTF-8 without BOM\" as encoding It is also recommended to use the Unix newline format, you can select it in the same panel but this is not a requirement.","title":"Unicode in Flask"},{"location":"unicode/#unicode-in-flask","text":"Flask, like Jinja2 and Werkzeug, is totally Unicode based when it comes to text. Not only these libraries, also the majority of web related Python libraries that deal with text. If you don't know Unicode so far, you should probably read The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets <https://www.joelonsoftware.com/articles/Unicode.html> _. This part of the documentation just tries to cover the very basics so that you have a pleasant experience with Unicode related things.","title":"Unicode in Flask"},{"location":"unicode/#automatic-conversion","text":"Flask has a few assumptions about your application (which you can change of course) that give you basic and painless Unicode support: the encoding for text on your website is UTF-8 internally you will always use Unicode exclusively for text except for literal strings with only ASCII character points. encoding and decoding happens whenever you are talking over a protocol that requires bytes to be transmitted. So what does this mean to you? HTTP is based on bytes. Not only the protocol, also the system used to address documents on servers (so called URIs or URLs). However HTML which is usually transmitted on top of HTTP supports a large variety of character sets and which ones are used, are transmitted in an HTTP header. To not make this too complex Flask just assumes that if you are sending Unicode out you want it to be UTF-8 encoded. Flask will do the encoding and setting of the appropriate headers for you. The same is true if you are talking to databases with the help of SQLAlchemy or a similar ORM system. Some databases have a protocol that already transmits Unicode and if they do not, SQLAlchemy or your other ORM should take care of that.","title":"Automatic Conversion"},{"location":"unicode/#the-golden-rule","text":"So the rule of thumb: if you are not dealing with binary data, work with Unicode. What does working with Unicode in Python 2.x mean? as long as you are using ASCII charpoints only (basically numbers, some special characters of latin letters without umlauts or anything fancy) you can use regular string literals ( 'Hello World' ). if you need anything else than ASCII in a string you have to mark this string as Unicode string by prefixing it with a lowercase u . (like u'H\u00e4nsel und Gretel' ) if you are using non-Unicode characters in your Python files you have to tell Python which encoding your file uses. Again, I recommend UTF-8 for this purpose. To tell the interpreter your encoding you can put the # -*- coding: utf-8 -*- into the first or second line of your Python source file. Jinja is configured to decode the template files from UTF-8. So make sure to tell your editor to save the file as UTF-8 there as well.","title":"The Golden Rule"},{"location":"unicode/#encoding-and-decoding-yourself","text":"If you are talking with a filesystem or something that is not really based on Unicode you will have to ensure that you decode properly when working with Unicode interface. So for example if you want to load a file on the filesystem and embed it into a Jinja2 template you will have to decode it from the encoding of that file. Here the old problem that text files do not specify their encoding comes into play. So do yourself a favour and limit yourself to UTF-8 for text files as well. Anyways. To load such a file with Unicode you can use the built-in :meth: str.decode method:: def read_file(filename, charset='utf-8'): with open(filename, 'r') as f: return f.read().decode(charset) To go from Unicode into a specific charset such as UTF-8 you can use the :meth: unicode.encode method:: def write_file(filename, contents, charset='utf-8'): with open(filename, 'w') as f: f.write(contents.encode(charset))","title":"Encoding and Decoding Yourself"},{"location":"unicode/#configuring-editors","text":"Most editors save as UTF-8 by default nowadays but in case your editor is not configured to do this you have to change it. Here some common ways to set your editor to store as UTF-8: Vim: put set enc=utf-8 to your .vimrc file. Emacs: either use an encoding cookie or put this into your .emacs file:: (prefer-coding-system 'utf-8) (setq default-buffer-file-coding-system 'utf-8) Notepad++: Go to Settings -> Preferences ... Select the \"New Document/Default Directory\" tab Select \"UTF-8 without BOM\" as encoding It is also recommended to use the Unix newline format, you can select it in the same panel but this is not a requirement.","title":"Configuring Editors"},{"location":"upgrading/","text":"Upgrading to Newer Releases \u00b6 Flask itself is changing like any software is changing over time. Most of the changes are the nice kind, the kind where you don't have to change anything in your code to profit from a new release. However every once in a while there are changes that do require some changes in your code or there are changes that make it possible for you to improve your own code quality by taking advantage of new features in Flask. This section of the documentation enumerates all the changes in Flask from release to release and how you can change your code to have a painless updating experience. Use the :command: pip command to upgrade your existing Flask installation by providing the --upgrade parameter:: $ pip install --upgrade Flask Version 0.12 \u00b6 Changes to send_file The `` filename `` is no longer automatically inferred from file - like objects . This means that the following code will no longer automatically have `` X - Sendfile `` support , etag generation or MIME - type guessing :: response = send_file ( open ( '/path/to/file.txt' )) Any of the following is functionally equivalent :: fname = '/path/to/file.txt' # Just pass the filepath directly response = send_file ( fname ) # Set the MIME - type and ETag explicitly response = send_file ( open ( fname ), mimetype = 'text/plain' ) response . set_etag (...) # Set `attachment_filename` for MIME - type guessing # ETag still needs to be manually set response = send_file ( open ( fname ), attachment_filename = fname ) response . set_etag (...) The reason for this is that some file - like objects have an invalid or even misleading `` name `` attribute . Silently swallowing errors in such cases was not a satisfying solution . Additionally the default of falling back to `` application / octet - stream `` has been restricted . If Flask can 't guess one or the user didn' t provide one , the function fails if no filename information was provided . .. _upgrading - to - 011 : Version 0.11 ------------ 0.11 is an odd release in the Flask release cycle because it was supposed to be the 1.0 release . However because there was such a long lead time up to the release we decided to push out a 0.11 release first with some changes removed to make the transition easier . If you have been tracking the master branch which was 1.0 you might see some unexpected changes . In case you did track the master branch you will notice that : command : `flask --app` is removed now . You need to use the environment variable to specify an application . Debugging ````````` Flask 0.11 removed the ``debug_log_format`` attribute from Flask applications. Instead the new ``LOGGER_HANDLER_POLICY`` configuration can be used to disable the default log handlers and custom log handlers can be set up. Error handling `````````````` The behavior of error handlers was changed. The precedence of handlers used to be based on the decoration/call order of :meth:` ~ flask . Flask . errorhandler ` and :meth:` ~ flask . Flask . register_error_handler `, respectively. Now the inheritance hierarchy takes precedence and handlers for more specific exception classes are executed instead of more general ones. See :ref:` error - handlers ` for specifics. Trying to register a handler on an instance now raises :exc:` ValueError `. .. note:: There used to be a logic error allowing you to register handlers only for exception *instances*. This was unintended and plain wrong, and therefore was replaced with the intended behavior of registering handlers only using exception classes and HTTP error codes. Templating `````````` The :func:` ~ flask . templating . render_template_string ` function has changed to autoescape template variables by default. This better matches the behavior of :func:` ~ flask . templating . render_template `. Extension imports ````````````````` Extension imports of the form `` flask . ext . foo `` are deprecated , you should use `` flask_foo `` . The old form still works , but Flask will issue a `` flask . exthook . ExtDeprecationWarning `` for each extension you import the old way . We also provide a migration utility called `flask-ext-migrate <https://github.com/pallets/flask-ext-migrate>` _ that is supposed to automatically rewrite your imports for this . .. _upgrading - to - 010 : Version 0.10 ------------ The biggest change going from 0.9 to 0.10 is that the cookie serialization format changed from pickle to a specialized JSON format . This change has been done in order to avoid the damage an attacker can do if the secret key is leaked . When you upgrade you will notice two major changes : all sessions that were issued before the upgrade are invalidated and you can only store a limited amount of types in the session . The new sessions are by design much more restricted to only allow JSON with a few small extensions for tuples and strings with HTML markup . In order to not break people 's sessions it is possible to continue using the old session system by using the `Flask-OldSessions`_ extension. Flask also started storing the :data:`flask.g` object on the application context instead of the request context. This change should be transparent for you but it means that you now can store things on the ``g`` object when there is no request context yet but an application context. The old ``flask.Flask.request_globals_class`` attribute was renamed to :attr:`flask.Flask.app_ctx_globals_class`. .. _Flask-OldSessions: https://pythonhosted.org/Flask-OldSessions/ Version 0.9 ----------- The behavior of returning tuples from a function was simplified. If you return a tuple it no longer defines the arguments for the response object you' re creating , it 's now always a tuple in the form ``(response, status, headers)`` where at least one item has to be provided. If you depend on the old behavior, you can add it easily by subclassing Flask:: class TraditionalFlask(Flask): def make_response(self, rv): if isinstance(rv, tuple): return self.response_class(*rv) return Flask.make_response(self, rv) If you maintain an extension that was using :data:`~flask._request_ctx_stack` before, please consider changing to :data:`~flask._app_ctx_stack` if it makes sense for your extension. For instance, the app context stack makes sense for extensions which connect to databases. Using the app context stack instead of the request context stack will make extensions more readily handle use cases outside of requests. Version 0.8 ----------- Flask introduced a new session interface system. We also noticed that there was a naming collision between ``flask.session`` the module that implements sessions and :data:`flask.session` which is the global session object. With that introduction we moved the implementation details for the session system into a new module called :mod:`flask.sessions`. If you used the previously undocumented session support we urge you to upgrade. If invalid JSON data was submitted Flask will now raise a :exc:`~werkzeug.exceptions.BadRequest` exception instead of letting the default :exc:`ValueError` bubble up. This has the advantage that you no longer have to handle that error to avoid an internal server error showing up for the user. If you were catching this down explicitly in the past as :exc:`ValueError` you will need to change this. Due to a bug in the test client Flask 0.7 did not trigger teardown handlers when the test client was used in a with statement. This was since fixed but might require some changes in your test suites if you relied on this behavior. Version 0.7 ----------- In Flask 0.7 we cleaned up the code base internally a lot and did some backwards incompatible changes that make it easier to implement larger applications with Flask. Because we want to make upgrading as easy as possible we tried to counter the problems arising from these changes by providing a script that can ease the transition. The script scans your whole application and generates a unified diff with changes it assumes are safe to apply. However as this is an automated tool it won' t be able to find all use cases and it might miss some . We internally spread a lot of deprecation warnings all over the place to make it easy to find pieces of code that it was unable to upgrade . We strongly recommend that you hand review the generated patchfile and only apply the chunks that look good . If you are using git as version control system for your project we recommend applying the patch with `` path - p1 < patchfile . diff `` and then using the interactive commit feature to only apply the chunks that look good . To apply the upgrade script do the following : 1. Download the script : `flask-07-upgrade.py <https://raw.githubusercontent.com/pallets/flask/0.12.3/scripts/flask-07-upgrade.py>` _ 2 . Run it in the directory of your application :: $ python flask - 07 - upgrade . py > patchfile . diff 3 . Review the generated patchfile . 4 . Apply the patch :: $ patch - p1 < patchfile . diff 5 . If you were using per - module template folders you need to move some templates around . Previously if you had a folder named : file : `templates` next to a blueprint named `` admin `` the implicit template path automatically was : file : `admin/index.html` for a template file called : file : `templates/index.html` . This no longer is the case . Now you need to name the template : file : `templates/admin/index.html` . The tool will not detect this so you will have to do that on your own . Please note that deprecation warnings are disabled by default starting with Python 2.7 . In order to see the deprecation warnings that might be emitted you have to enabled them with the : mod : `warnings` module . If you are working with windows and you lack the `` patch `` command line utility you can get it as part of various Unix runtime environments for windows including cygwin , msysgit or ming32 . Also source control systems like svn , hg or git have builtin support for applying unified diffs as generated by the tool . Check the manual of your version control system for more information . Bug in Request Locals Due to a bug in earlier implementations the request local proxies now raise a :exc: RuntimeError instead of an :exc: AttributeError when they are unbound. If you caught these exceptions with :exc: AttributeError before, you should catch them with :exc: RuntimeError now. Additionally the :func: ~flask.send_file function is now issuing deprecation warnings if you depend on functionality that will be removed in Flask 0.11. Previously it was possible to use etags and mimetypes when file objects were passed. This was unreliable and caused issues for a few setups. If you get a deprecation warning, make sure to update your application to work with either filenames there or disable etag attaching and attach them yourself. Old code:: return send_file(my_file_object) return send_file(my_file_object) New code:: return send_file(my_file_object, add_etags=False) Upgrading to new Teardown Handling We streamlined the behavior of the callbacks for request handling. For things that modify the response the :meth:`~flask.Flask.after_request` decorators continue to work as expected, but for things that absolutely must happen at the end of request we introduced the new :meth:`~flask.Flask.teardown_request` decorator. Unfortunately that change also made after-request work differently under error conditions. It's not consistently skipped if exceptions happen whereas previously it might have been called twice to ensure it is executed at the end of the request. If you have database connection code that looks like this:: @app.after_request def after_request(response): g.db.close() return response You are now encouraged to use this instead:: @app.teardown_request def after_request(exception): if hasattr(g, 'db'): g.db.close() On the upside this change greatly improves the internal code flow and makes it easier to customize the dispatching and error handling. This makes it now a lot easier to write unit tests as you can prevent closing down of database connections for a while. You can take advantage of the fact that the teardown callbacks are called when the response context is removed from the stack so a test can query the database after request handling:: with app.test_client() as client: resp = client.get('/') # g.db is still bound if there is such a thing # and here it's gone Manual Error Handler Attaching `````````````````````````````` While it is still possible to attach error handlers to :attr:`Flask.error_handlers` it's discouraged to do so and in fact deprecated. In general we no longer recommend custom error handler attaching via assignments to the underlying dictionary due to the more complex internal handling to support arbitrary exception classes and blueprints. See :meth:`Flask.errorhandler` for more information. The proper upgrade is to change this:: app.error_handlers[403] = handle_error Into this:: app.register_error_handler(403, handle_error) Alternatively you should just attach the function with a decorator:: @app.errorhandler(403) def handle_error(e): ... (Note that :meth:`register_error_handler` is new in Flask 0.7) Blueprint Support ````````````````` Blueprints replace the previous concept of \u201cModules\u201d in Flask. They provide better semantics for various features and work better with large applications. The update script provided should be able to upgrade your applications automatically, but there might be some cases where it fails to upgrade. What changed? - Blueprints need explicit names. Modules had an automatic name guessing scheme where the shortname for the module was taken from the last part of the import module. The upgrade script tries to guess that name but it might fail as this information could change at runtime. - Blueprints have an inverse behavior for :meth:`url_for`. Previously ``.foo`` told :meth:`url_for` that it should look for the endpoint ``foo`` on the application. Now it means \u201crelative to current module\u201d. The script will inverse all calls to :meth:`url_for` automatically for you. It will do this in a very eager way so you might end up with some unnecessary leading dots in your code if you're not using modules. - Blueprints do not automatically provide static folders. They will also no longer automatically export templates from a folder called :file:`templates` next to their location however but it can be enabled from the constructor. Same with static files: if you want to continue serving static files you need to tell the constructor explicitly the path to the static folder (which can be relative to the blueprint's module path). - Rendering templates was simplified. Now the blueprints can provide template folders which are added to a general template searchpath. This means that you need to add another subfolder with the blueprint's name into that folder if you want :file:`blueprintname/template.html` as the template name. If you continue to use the ``Module`` object which is deprecated, Flask will restore the previous behavior as good as possible. However we strongly recommend upgrading to the new blueprints as they provide a lot of useful improvement such as the ability to attach a blueprint multiple times, blueprint specific error handlers and a lot more. Version 0.6 ----------- Flask 0.6 comes with a backwards incompatible change which affects the order of after-request handlers. Previously they were called in the order of the registration, now they are called in reverse order. This change was made so that Flask behaves more like people expected it to work and how other systems handle request pre- and post-processing. If you depend on the order of execution of post-request functions, be sure to change the order. Another change that breaks backwards compatibility is that context processors will no longer override values passed directly to the template rendering function. If for example ``request`` is as variable passed directly to the template, the default context processor will not override it with the current request object. This makes it easier to extend context processors later to inject additional variables without breaking existing template not expecting them. Version 0.5 ----------- Flask 0.5 is the first release that comes as a Python package instead of a single module. There were a couple of internal refactoring so if you depend on undocumented internal details you probably have to adapt the imports. The following changes may be relevant to your application: - autoescaping no longer happens for all templates. Instead it is configured to only happen on files ending with ``.html``, ``.htm``, ``.xml`` and ``.xhtml``. If you have templates with different extensions you should override the :meth:`~flask.Flask.select_jinja_autoescape` method. - Flask no longer supports zipped applications in this release. This functionality might come back in future releases if there is demand for this feature. Removing support for this makes the Flask internal code easier to understand and fixes a couple of small issues that make debugging harder than necessary. - The ``create_jinja_loader`` function is gone. If you want to customize the Jinja loader now, use the :meth:`~flask.Flask.create_jinja_environment` method instead. Version 0.4 ----------- For application developers there are no changes that require changes in your code. In case you are developing on a Flask extension however, and that extension has a unittest-mode you might want to link the activation of that mode to the new ``TESTING`` flag. Version 0.3 ----------- Flask 0.3 introduces configuration support and logging as well as categories for flashing messages. All these are features that are 100% backwards compatible but you might want to take advantage of them. Configuration Support ````````````````````` The configuration support makes it easier to write any kind of application that requires some sort of configuration. (Which most likely is the case for any application out there). If you previously had code like this:: app.debug = DEBUG app.secret_key = SECRET_KEY You no longer have to do that, instead you can just load a configuration into the config object. How this works is outlined in :ref:`config`. Logging Integration ``````````````````` Flask now configures a logger for you with some basic and useful defaults. If you run your application in production and want to profit from automatic error logging, you might be interested in attaching a proper log handler. Also you can start logging warnings and errors into the logger when appropriately. For more information on that, read :ref:`application-errors`. Categories for Flash Messages ````````````````````````````` Flash messages can now have categories attached. This makes it possible to render errors, warnings or regular messages differently for example. This is an opt-in feature because it requires some rethinking in the code. Read all about that in the :ref:`message-flashing-pattern` pattern.","title":"Upgrading to Newer Releases"},{"location":"upgrading/#upgrading-to-newer-releases","text":"Flask itself is changing like any software is changing over time. Most of the changes are the nice kind, the kind where you don't have to change anything in your code to profit from a new release. However every once in a while there are changes that do require some changes in your code or there are changes that make it possible for you to improve your own code quality by taking advantage of new features in Flask. This section of the documentation enumerates all the changes in Flask from release to release and how you can change your code to have a painless updating experience. Use the :command: pip command to upgrade your existing Flask installation by providing the --upgrade parameter:: $ pip install --upgrade Flask","title":"Upgrading to Newer Releases"},{"location":"upgrading/#version-012","text":"Changes to send_file The `` filename `` is no longer automatically inferred from file - like objects . This means that the following code will no longer automatically have `` X - Sendfile `` support , etag generation or MIME - type guessing :: response = send_file ( open ( '/path/to/file.txt' )) Any of the following is functionally equivalent :: fname = '/path/to/file.txt' # Just pass the filepath directly response = send_file ( fname ) # Set the MIME - type and ETag explicitly response = send_file ( open ( fname ), mimetype = 'text/plain' ) response . set_etag (...) # Set `attachment_filename` for MIME - type guessing # ETag still needs to be manually set response = send_file ( open ( fname ), attachment_filename = fname ) response . set_etag (...) The reason for this is that some file - like objects have an invalid or even misleading `` name `` attribute . Silently swallowing errors in such cases was not a satisfying solution . Additionally the default of falling back to `` application / octet - stream `` has been restricted . If Flask can 't guess one or the user didn' t provide one , the function fails if no filename information was provided . .. _upgrading - to - 011 : Version 0.11 ------------ 0.11 is an odd release in the Flask release cycle because it was supposed to be the 1.0 release . However because there was such a long lead time up to the release we decided to push out a 0.11 release first with some changes removed to make the transition easier . If you have been tracking the master branch which was 1.0 you might see some unexpected changes . In case you did track the master branch you will notice that : command : `flask --app` is removed now . You need to use the environment variable to specify an application . Debugging ````````` Flask 0.11 removed the ``debug_log_format`` attribute from Flask applications. Instead the new ``LOGGER_HANDLER_POLICY`` configuration can be used to disable the default log handlers and custom log handlers can be set up. Error handling `````````````` The behavior of error handlers was changed. The precedence of handlers used to be based on the decoration/call order of :meth:` ~ flask . Flask . errorhandler ` and :meth:` ~ flask . Flask . register_error_handler `, respectively. Now the inheritance hierarchy takes precedence and handlers for more specific exception classes are executed instead of more general ones. See :ref:` error - handlers ` for specifics. Trying to register a handler on an instance now raises :exc:` ValueError `. .. note:: There used to be a logic error allowing you to register handlers only for exception *instances*. This was unintended and plain wrong, and therefore was replaced with the intended behavior of registering handlers only using exception classes and HTTP error codes. Templating `````````` The :func:` ~ flask . templating . render_template_string ` function has changed to autoescape template variables by default. This better matches the behavior of :func:` ~ flask . templating . render_template `. Extension imports ````````````````` Extension imports of the form `` flask . ext . foo `` are deprecated , you should use `` flask_foo `` . The old form still works , but Flask will issue a `` flask . exthook . ExtDeprecationWarning `` for each extension you import the old way . We also provide a migration utility called `flask-ext-migrate <https://github.com/pallets/flask-ext-migrate>` _ that is supposed to automatically rewrite your imports for this . .. _upgrading - to - 010 : Version 0.10 ------------ The biggest change going from 0.9 to 0.10 is that the cookie serialization format changed from pickle to a specialized JSON format . This change has been done in order to avoid the damage an attacker can do if the secret key is leaked . When you upgrade you will notice two major changes : all sessions that were issued before the upgrade are invalidated and you can only store a limited amount of types in the session . The new sessions are by design much more restricted to only allow JSON with a few small extensions for tuples and strings with HTML markup . In order to not break people 's sessions it is possible to continue using the old session system by using the `Flask-OldSessions`_ extension. Flask also started storing the :data:`flask.g` object on the application context instead of the request context. This change should be transparent for you but it means that you now can store things on the ``g`` object when there is no request context yet but an application context. The old ``flask.Flask.request_globals_class`` attribute was renamed to :attr:`flask.Flask.app_ctx_globals_class`. .. _Flask-OldSessions: https://pythonhosted.org/Flask-OldSessions/ Version 0.9 ----------- The behavior of returning tuples from a function was simplified. If you return a tuple it no longer defines the arguments for the response object you' re creating , it 's now always a tuple in the form ``(response, status, headers)`` where at least one item has to be provided. If you depend on the old behavior, you can add it easily by subclassing Flask:: class TraditionalFlask(Flask): def make_response(self, rv): if isinstance(rv, tuple): return self.response_class(*rv) return Flask.make_response(self, rv) If you maintain an extension that was using :data:`~flask._request_ctx_stack` before, please consider changing to :data:`~flask._app_ctx_stack` if it makes sense for your extension. For instance, the app context stack makes sense for extensions which connect to databases. Using the app context stack instead of the request context stack will make extensions more readily handle use cases outside of requests. Version 0.8 ----------- Flask introduced a new session interface system. We also noticed that there was a naming collision between ``flask.session`` the module that implements sessions and :data:`flask.session` which is the global session object. With that introduction we moved the implementation details for the session system into a new module called :mod:`flask.sessions`. If you used the previously undocumented session support we urge you to upgrade. If invalid JSON data was submitted Flask will now raise a :exc:`~werkzeug.exceptions.BadRequest` exception instead of letting the default :exc:`ValueError` bubble up. This has the advantage that you no longer have to handle that error to avoid an internal server error showing up for the user. If you were catching this down explicitly in the past as :exc:`ValueError` you will need to change this. Due to a bug in the test client Flask 0.7 did not trigger teardown handlers when the test client was used in a with statement. This was since fixed but might require some changes in your test suites if you relied on this behavior. Version 0.7 ----------- In Flask 0.7 we cleaned up the code base internally a lot and did some backwards incompatible changes that make it easier to implement larger applications with Flask. Because we want to make upgrading as easy as possible we tried to counter the problems arising from these changes by providing a script that can ease the transition. The script scans your whole application and generates a unified diff with changes it assumes are safe to apply. However as this is an automated tool it won' t be able to find all use cases and it might miss some . We internally spread a lot of deprecation warnings all over the place to make it easy to find pieces of code that it was unable to upgrade . We strongly recommend that you hand review the generated patchfile and only apply the chunks that look good . If you are using git as version control system for your project we recommend applying the patch with `` path - p1 < patchfile . diff `` and then using the interactive commit feature to only apply the chunks that look good . To apply the upgrade script do the following : 1. Download the script : `flask-07-upgrade.py <https://raw.githubusercontent.com/pallets/flask/0.12.3/scripts/flask-07-upgrade.py>` _ 2 . Run it in the directory of your application :: $ python flask - 07 - upgrade . py > patchfile . diff 3 . Review the generated patchfile . 4 . Apply the patch :: $ patch - p1 < patchfile . diff 5 . If you were using per - module template folders you need to move some templates around . Previously if you had a folder named : file : `templates` next to a blueprint named `` admin `` the implicit template path automatically was : file : `admin/index.html` for a template file called : file : `templates/index.html` . This no longer is the case . Now you need to name the template : file : `templates/admin/index.html` . The tool will not detect this so you will have to do that on your own . Please note that deprecation warnings are disabled by default starting with Python 2.7 . In order to see the deprecation warnings that might be emitted you have to enabled them with the : mod : `warnings` module . If you are working with windows and you lack the `` patch `` command line utility you can get it as part of various Unix runtime environments for windows including cygwin , msysgit or ming32 . Also source control systems like svn , hg or git have builtin support for applying unified diffs as generated by the tool . Check the manual of your version control system for more information . Bug in Request Locals Due to a bug in earlier implementations the request local proxies now raise a :exc: RuntimeError instead of an :exc: AttributeError when they are unbound. If you caught these exceptions with :exc: AttributeError before, you should catch them with :exc: RuntimeError now. Additionally the :func: ~flask.send_file function is now issuing deprecation warnings if you depend on functionality that will be removed in Flask 0.11. Previously it was possible to use etags and mimetypes when file objects were passed. This was unreliable and caused issues for a few setups. If you get a deprecation warning, make sure to update your application to work with either filenames there or disable etag attaching and attach them yourself. Old code:: return send_file(my_file_object) return send_file(my_file_object) New code:: return send_file(my_file_object, add_etags=False) Upgrading to new Teardown Handling We streamlined the behavior of the callbacks for request handling. For things that modify the response the :meth:`~flask.Flask.after_request` decorators continue to work as expected, but for things that absolutely must happen at the end of request we introduced the new :meth:`~flask.Flask.teardown_request` decorator. Unfortunately that change also made after-request work differently under error conditions. It's not consistently skipped if exceptions happen whereas previously it might have been called twice to ensure it is executed at the end of the request. If you have database connection code that looks like this:: @app.after_request def after_request(response): g.db.close() return response You are now encouraged to use this instead:: @app.teardown_request def after_request(exception): if hasattr(g, 'db'): g.db.close() On the upside this change greatly improves the internal code flow and makes it easier to customize the dispatching and error handling. This makes it now a lot easier to write unit tests as you can prevent closing down of database connections for a while. You can take advantage of the fact that the teardown callbacks are called when the response context is removed from the stack so a test can query the database after request handling:: with app.test_client() as client: resp = client.get('/') # g.db is still bound if there is such a thing # and here it's gone Manual Error Handler Attaching `````````````````````````````` While it is still possible to attach error handlers to :attr:`Flask.error_handlers` it's discouraged to do so and in fact deprecated. In general we no longer recommend custom error handler attaching via assignments to the underlying dictionary due to the more complex internal handling to support arbitrary exception classes and blueprints. See :meth:`Flask.errorhandler` for more information. The proper upgrade is to change this:: app.error_handlers[403] = handle_error Into this:: app.register_error_handler(403, handle_error) Alternatively you should just attach the function with a decorator:: @app.errorhandler(403) def handle_error(e): ... (Note that :meth:`register_error_handler` is new in Flask 0.7) Blueprint Support ````````````````` Blueprints replace the previous concept of \u201cModules\u201d in Flask. They provide better semantics for various features and work better with large applications. The update script provided should be able to upgrade your applications automatically, but there might be some cases where it fails to upgrade. What changed? - Blueprints need explicit names. Modules had an automatic name guessing scheme where the shortname for the module was taken from the last part of the import module. The upgrade script tries to guess that name but it might fail as this information could change at runtime. - Blueprints have an inverse behavior for :meth:`url_for`. Previously ``.foo`` told :meth:`url_for` that it should look for the endpoint ``foo`` on the application. Now it means \u201crelative to current module\u201d. The script will inverse all calls to :meth:`url_for` automatically for you. It will do this in a very eager way so you might end up with some unnecessary leading dots in your code if you're not using modules. - Blueprints do not automatically provide static folders. They will also no longer automatically export templates from a folder called :file:`templates` next to their location however but it can be enabled from the constructor. Same with static files: if you want to continue serving static files you need to tell the constructor explicitly the path to the static folder (which can be relative to the blueprint's module path). - Rendering templates was simplified. Now the blueprints can provide template folders which are added to a general template searchpath. This means that you need to add another subfolder with the blueprint's name into that folder if you want :file:`blueprintname/template.html` as the template name. If you continue to use the ``Module`` object which is deprecated, Flask will restore the previous behavior as good as possible. However we strongly recommend upgrading to the new blueprints as they provide a lot of useful improvement such as the ability to attach a blueprint multiple times, blueprint specific error handlers and a lot more. Version 0.6 ----------- Flask 0.6 comes with a backwards incompatible change which affects the order of after-request handlers. Previously they were called in the order of the registration, now they are called in reverse order. This change was made so that Flask behaves more like people expected it to work and how other systems handle request pre- and post-processing. If you depend on the order of execution of post-request functions, be sure to change the order. Another change that breaks backwards compatibility is that context processors will no longer override values passed directly to the template rendering function. If for example ``request`` is as variable passed directly to the template, the default context processor will not override it with the current request object. This makes it easier to extend context processors later to inject additional variables without breaking existing template not expecting them. Version 0.5 ----------- Flask 0.5 is the first release that comes as a Python package instead of a single module. There were a couple of internal refactoring so if you depend on undocumented internal details you probably have to adapt the imports. The following changes may be relevant to your application: - autoescaping no longer happens for all templates. Instead it is configured to only happen on files ending with ``.html``, ``.htm``, ``.xml`` and ``.xhtml``. If you have templates with different extensions you should override the :meth:`~flask.Flask.select_jinja_autoescape` method. - Flask no longer supports zipped applications in this release. This functionality might come back in future releases if there is demand for this feature. Removing support for this makes the Flask internal code easier to understand and fixes a couple of small issues that make debugging harder than necessary. - The ``create_jinja_loader`` function is gone. If you want to customize the Jinja loader now, use the :meth:`~flask.Flask.create_jinja_environment` method instead. Version 0.4 ----------- For application developers there are no changes that require changes in your code. In case you are developing on a Flask extension however, and that extension has a unittest-mode you might want to link the activation of that mode to the new ``TESTING`` flag. Version 0.3 ----------- Flask 0.3 introduces configuration support and logging as well as categories for flashing messages. All these are features that are 100% backwards compatible but you might want to take advantage of them. Configuration Support ````````````````````` The configuration support makes it easier to write any kind of application that requires some sort of configuration. (Which most likely is the case for any application out there). If you previously had code like this:: app.debug = DEBUG app.secret_key = SECRET_KEY You no longer have to do that, instead you can just load a configuration into the config object. How this works is outlined in :ref:`config`. Logging Integration ``````````````````` Flask now configures a logger for you with some basic and useful defaults. If you run your application in production and want to profit from automatic error logging, you might be interested in attaching a proper log handler. Also you can start logging warnings and errors into the logger when appropriately. For more information on that, read :ref:`application-errors`. Categories for Flash Messages ````````````````````````````` Flash messages can now have categories attached. This makes it possible to render errors, warnings or regular messages differently for example. This is an opt-in feature because it requires some rethinking in the code. Read all about that in the :ref:`message-flashing-pattern` pattern.","title":"Version 0.12"},{"location":"views/","text":"Pluggable Views \u00b6 .. versionadded:: 0.7 Flask 0.7 introduces pluggable views inspired by the generic views from Django which are based on classes instead of functions. The main intention is that you can replace parts of the implementations and this way have customizable pluggable views. Basic Principle \u00b6 Consider you have a function that loads a list of objects from the database and renders into a template:: @app.route('/users/') def show_users(page): users = User.query.all() return render_template('users.html', users=users) This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this:: from flask.views import View class ShowUsers ( View ): def dispatch_request ( self ): users = User . query . all () return render_template ( 'users.html' , objects = users ) app . add_url_rule ( '/users/' , view_func = ShowUsers . as_view ( 'show_users' )) As you can see what you have to do is to create a subclass of :class: flask.views.View and implement :meth: ~flask.views.View.dispatch_request . Then we have to convert that class into an actual view function by using the :meth: ~flask.views.View.as_view class method. The string you pass to that function is the name of the endpoint that view will then have. But this by itself is not helpful, so let's refactor the code a bit:: from flask.views import View class ListView ( View ): def get_template_name ( self ): raise NotImplementedError () def render_template ( self , context ): return render_template ( self . get_template_name (), ** context ) def dispatch_request ( self ): context = { 'objects' : self . get_objects ()} return self . render_template ( context ) class UserView ( ListView ): def get_template_name ( self ): return 'users.html' def get_objects ( self ): return User . query . all () This of course is not that helpful for such a small example, but it's good enough to explain the basic principle. When you have a class-based view the question comes up what self points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the :meth: ~flask.views.View.dispatch_request method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the :meth: ~flask.views.View.as_view function. For instance you can write a class like this:: class RenderTemplateView ( View ) : def __init__ ( self , template_name ) : self . template_name = template_name def dispatch_request ( self ) : return render_template ( self . template_name ) And then you can register it like this:: app.add_url_rule('/about', view_func=RenderTemplateView.as_view( 'about_page', template_name='about.html')) Method Hints \u00b6 Pluggable views are attached to the application like a regular function by either using :func: ~flask.Flask.route or better :meth: ~flask.Flask.add_url_rule . That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a :attr: ~flask.views.View.methods attribute that has this information:: class MyView ( View ) : methods = [ 'GET' , 'POST' ] def dispatch_request ( self ) : if request . method == 'POST' : ... ... app . add_url_rule ( '/myview' , view_func = MyView . as_view ( 'myview' )) Method Based Dispatching \u00b6 For RESTful APIs it's especially helpful to execute a different function for each HTTP method. With the :class: flask.views.MethodView you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase):: from flask.views import MethodView class UserAPI ( MethodView ): def get ( self ): users = User . query . all () ... def post ( self ): user = User . from_form_data ( request . form ) ... app . add_url_rule ( '/users/' , view_func = UserAPI . as_view ( 'users' )) That way you also don't have to provide the :attr: ~flask.views.View.methods attribute. It's automatically set based on the methods defined in the class. Decorating Views \u00b6 Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of :meth: ~flask.views.View.as_view by hand:: def user_required(f): \"\"\"Checks whether user is logged in or raises error 401.\"\"\" def decorator(*args, **kwargs): if not g.user: abort(401) return f(*args, **kwargs) return decorator view = user_required(UserAPI.as_view('users')) app.add_url_rule('/users/', view_func=view) Starting with Flask 0.8 there is also an alternative way where you can specify a list of decorators to apply in the class declaration:: class UserAPI ( MethodView ) : decorators = [ user_required ] Due to the implicit self from the caller's perspective you cannot use regular view decorators on the individual methods of the view however, keep this in mind. Method Views for APIs \u00b6 Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the :class: ~flask.views.MethodView . That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web: =============== =============== ====================================== URL Method Description /users/ GET Gives a list of all users /users/ POST Creates a new user /users/<id> GET Shows a single user /users/<id> PUT Updates a single user /users/<id> DELETE Deletes a single user =============== =============== ====================================== So how would you go about doing that with the :class: ~flask.views.MethodView ? The trick is to take advantage of the fact that you can provide multiple rules to the same view. Let's assume for the moment the view would look like this:: class UserAPI ( MethodView ) : def get ( self , user_id ) : if user_id is None : # return a list of users pass else : # expose a single user pass def post ( self ) : # create a new user pass def delete ( self , user_id ) : # delete a single user pass def put ( self , user_id ) : # update a single user pass So how do we hook this up with the routing system? By adding two rules and explicitly mentioning the methods for each:: user_view = UserAPI . as_view ( 'user_api' ) app . add_url_rule ( '/users/' , defaults = { 'user_id': None } , view_func = user_view , methods = [ 'GET' , ] ) app . add_url_rule ( '/users/' , view_func = user_view , methods = [ 'POST' , ] ) app . add_url_rule ( '/users/&lt;int:user_id&gt;' , view_func = user_view , methods = [ 'GET' , 'PUT' , 'DELETE' ] ) If you have a lot of APIs that look similar you can refactor that registration code:: def register_api ( view , endpoint , url , pk = 'id' , pk_type = 'int' ): view_func = view . as_view ( endpoint ) app . add_url_rule ( url , defaults = { pk : None } , view_func = view_func , methods = [ 'GET' , ] ) app . add_url_rule ( url , view_func = view_func , methods = [ 'POST' , ] ) app . add_url_rule ( '%s&lt;%s:%s&gt;' % ( url , pk_type , pk ), view_func = view_func , methods = [ 'GET' , 'PUT' , 'DELETE' ] ) register_api ( UserAPI , 'user_api' , '/users/' , pk = 'user_id' )","title":"Pluggable Views"},{"location":"views/#pluggable-views","text":".. versionadded:: 0.7 Flask 0.7 introduces pluggable views inspired by the generic views from Django which are based on classes instead of functions. The main intention is that you can replace parts of the implementations and this way have customizable pluggable views.","title":"Pluggable Views"},{"location":"views/#basic-principle","text":"Consider you have a function that loads a list of objects from the database and renders into a template:: @app.route('/users/') def show_users(page): users = User.query.all() return render_template('users.html', users=users) This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this:: from flask.views import View class ShowUsers ( View ): def dispatch_request ( self ): users = User . query . all () return render_template ( 'users.html' , objects = users ) app . add_url_rule ( '/users/' , view_func = ShowUsers . as_view ( 'show_users' )) As you can see what you have to do is to create a subclass of :class: flask.views.View and implement :meth: ~flask.views.View.dispatch_request . Then we have to convert that class into an actual view function by using the :meth: ~flask.views.View.as_view class method. The string you pass to that function is the name of the endpoint that view will then have. But this by itself is not helpful, so let's refactor the code a bit:: from flask.views import View class ListView ( View ): def get_template_name ( self ): raise NotImplementedError () def render_template ( self , context ): return render_template ( self . get_template_name (), ** context ) def dispatch_request ( self ): context = { 'objects' : self . get_objects ()} return self . render_template ( context ) class UserView ( ListView ): def get_template_name ( self ): return 'users.html' def get_objects ( self ): return User . query . all () This of course is not that helpful for such a small example, but it's good enough to explain the basic principle. When you have a class-based view the question comes up what self points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the :meth: ~flask.views.View.dispatch_request method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the :meth: ~flask.views.View.as_view function. For instance you can write a class like this:: class RenderTemplateView ( View ) : def __init__ ( self , template_name ) : self . template_name = template_name def dispatch_request ( self ) : return render_template ( self . template_name ) And then you can register it like this:: app.add_url_rule('/about', view_func=RenderTemplateView.as_view( 'about_page', template_name='about.html'))","title":"Basic Principle"},{"location":"views/#method-hints","text":"Pluggable views are attached to the application like a regular function by either using :func: ~flask.Flask.route or better :meth: ~flask.Flask.add_url_rule . That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a :attr: ~flask.views.View.methods attribute that has this information:: class MyView ( View ) : methods = [ 'GET' , 'POST' ] def dispatch_request ( self ) : if request . method == 'POST' : ... ... app . add_url_rule ( '/myview' , view_func = MyView . as_view ( 'myview' ))","title":"Method Hints"},{"location":"views/#method-based-dispatching","text":"For RESTful APIs it's especially helpful to execute a different function for each HTTP method. With the :class: flask.views.MethodView you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase):: from flask.views import MethodView class UserAPI ( MethodView ): def get ( self ): users = User . query . all () ... def post ( self ): user = User . from_form_data ( request . form ) ... app . add_url_rule ( '/users/' , view_func = UserAPI . as_view ( 'users' )) That way you also don't have to provide the :attr: ~flask.views.View.methods attribute. It's automatically set based on the methods defined in the class.","title":"Method Based Dispatching"},{"location":"views/#decorating-views","text":"Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of :meth: ~flask.views.View.as_view by hand:: def user_required(f): \"\"\"Checks whether user is logged in or raises error 401.\"\"\" def decorator(*args, **kwargs): if not g.user: abort(401) return f(*args, **kwargs) return decorator view = user_required(UserAPI.as_view('users')) app.add_url_rule('/users/', view_func=view) Starting with Flask 0.8 there is also an alternative way where you can specify a list of decorators to apply in the class declaration:: class UserAPI ( MethodView ) : decorators = [ user_required ] Due to the implicit self from the caller's perspective you cannot use regular view decorators on the individual methods of the view however, keep this in mind.","title":"Decorating Views"},{"location":"views/#method-views-for-apis","text":"Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the :class: ~flask.views.MethodView . That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web: =============== =============== ====================================== URL Method Description /users/ GET Gives a list of all users /users/ POST Creates a new user /users/<id> GET Shows a single user /users/<id> PUT Updates a single user /users/<id> DELETE Deletes a single user =============== =============== ====================================== So how would you go about doing that with the :class: ~flask.views.MethodView ? The trick is to take advantage of the fact that you can provide multiple rules to the same view. Let's assume for the moment the view would look like this:: class UserAPI ( MethodView ) : def get ( self , user_id ) : if user_id is None : # return a list of users pass else : # expose a single user pass def post ( self ) : # create a new user pass def delete ( self , user_id ) : # delete a single user pass def put ( self , user_id ) : # update a single user pass So how do we hook this up with the routing system? By adding two rules and explicitly mentioning the methods for each:: user_view = UserAPI . as_view ( 'user_api' ) app . add_url_rule ( '/users/' , defaults = { 'user_id': None } , view_func = user_view , methods = [ 'GET' , ] ) app . add_url_rule ( '/users/' , view_func = user_view , methods = [ 'POST' , ] ) app . add_url_rule ( '/users/&lt;int:user_id&gt;' , view_func = user_view , methods = [ 'GET' , 'PUT' , 'DELETE' ] ) If you have a lot of APIs that look similar you can refactor that registration code:: def register_api ( view , endpoint , url , pk = 'id' , pk_type = 'int' ): view_func = view . as_view ( endpoint ) app . add_url_rule ( url , defaults = { pk : None } , view_func = view_func , methods = [ 'GET' , ] ) app . add_url_rule ( url , view_func = view_func , methods = [ 'POST' , ] ) app . add_url_rule ( '%s&lt;%s:%s&gt;' % ( url , pk_type , pk ), view_func = view_func , methods = [ 'GET' , 'PUT' , 'DELETE' ] ) register_api ( UserAPI , 'user_api' , '/users/' , pk = 'user_id' )","title":"Method Views for APIs"},{"location":"deploying/","text":".. _deployment: Deployment Options \u00b6 While lightweight and easy to use, Flask's built-in server is not suitable for production as it doesn't scale well. Some of the options available for properly running Flask in production are documented here. If you want to deploy your Flask application to a WSGI server not listed here, look up the server documentation about how to use a WSGI app with it. Just remember that your :class: Flask application object is the actual WSGI application. Hosted options \u00b6 Deploying Flask on Heroku <https://devcenter.heroku.com/articles/getting-started-with-python> _ Deploying Flask on OpenShift <https://developers.openshift.com/en/python-flask.html> _ Deploying Flask on Webfaction <http://flask.pocoo.org/snippets/65/> _ Deploying Flask on Google App Engine <https://cloud.google.com/appengine/docs/standard/python/getting-started/python-standard-env> _ Deploying Flask on AWS Elastic Beanstalk <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html> _ Sharing your Localhost Server with Localtunnel <http://flask.pocoo.org/snippets/89/> _ Deploying on Azure (IIS) <https://azure.microsoft.com/documentation/articles/web-sites-python-configure/> _ Deploying on PythonAnywhere <https://help.pythonanywhere.com/pages/Flask/> _ Self-hosted options \u00b6 .. toctree:: :maxdepth: 2 wsgi-standalone uwsgi mod_wsgi fastcgi cgi","title":"Index"},{"location":"deploying/#deployment-options","text":"While lightweight and easy to use, Flask's built-in server is not suitable for production as it doesn't scale well. Some of the options available for properly running Flask in production are documented here. If you want to deploy your Flask application to a WSGI server not listed here, look up the server documentation about how to use a WSGI app with it. Just remember that your :class: Flask application object is the actual WSGI application.","title":"Deployment Options"},{"location":"deploying/#hosted-options","text":"Deploying Flask on Heroku <https://devcenter.heroku.com/articles/getting-started-with-python> _ Deploying Flask on OpenShift <https://developers.openshift.com/en/python-flask.html> _ Deploying Flask on Webfaction <http://flask.pocoo.org/snippets/65/> _ Deploying Flask on Google App Engine <https://cloud.google.com/appengine/docs/standard/python/getting-started/python-standard-env> _ Deploying Flask on AWS Elastic Beanstalk <https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create-deploy-python-flask.html> _ Sharing your Localhost Server with Localtunnel <http://flask.pocoo.org/snippets/89/> _ Deploying on Azure (IIS) <https://azure.microsoft.com/documentation/articles/web-sites-python-configure/> _ Deploying on PythonAnywhere <https://help.pythonanywhere.com/pages/Flask/> _","title":"Hosted options"},{"location":"deploying/#self-hosted-options","text":".. toctree:: :maxdepth: 2 wsgi-standalone uwsgi mod_wsgi fastcgi cgi","title":"Self-hosted options"},{"location":"deploying/cgi/","text":"CGI \u00b6 If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a sub-optimal performance. This is also the way you can use a Flask application on Google's App Engine _, where execution happens in a CGI-like environment. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to CGI / app engine. With CGI, you will also have to make sure that your code does not contain any print statements, or that sys.stdout is overridden by something that doesn't write into the HTTP response. Creating a .cgi file \u00b6 First you need to create the CGI application file. Let's call it :file: yourapplication.cgi :: #!/usr/bin/python from wsgiref.handlers import CGIHandler from yourapplication import app CGIHandler () . run ( app ) Server Setup \u00b6 Usually there are two ways to configure the server. Either just copy the .cgi into a :file: cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly. In Apache for example you can put something like this into the config: .. sourcecode:: apache ScriptAlias /app /path/to/the/application.cgi On shared webhosting, though, you might not have access to your Apache config. In this case, a file called .htaccess , sitting in the public directory you want your app to be available, works too but the ScriptAlias directive won't work in that case: .. sourcecode:: apache RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f # Don't interfere with static files RewriteRule ^(.*)$ /path/to/the/application.cgi/$1 [L] For more information consult the documentation of your webserver. .. _App Engine: https://developers.google.com/appengine/","title":"CGI"},{"location":"deploying/cgi/#cgi","text":"If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a sub-optimal performance. This is also the way you can use a Flask application on Google's App Engine _, where execution happens in a CGI-like environment. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to CGI / app engine. With CGI, you will also have to make sure that your code does not contain any print statements, or that sys.stdout is overridden by something that doesn't write into the HTTP response.","title":"CGI"},{"location":"deploying/cgi/#creating-a-cgi-file","text":"First you need to create the CGI application file. Let's call it :file: yourapplication.cgi :: #!/usr/bin/python from wsgiref.handlers import CGIHandler from yourapplication import app CGIHandler () . run ( app )","title":"Creating a .cgi file"},{"location":"deploying/cgi/#server-setup","text":"Usually there are two ways to configure the server. Either just copy the .cgi into a :file: cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly. In Apache for example you can put something like this into the config: .. sourcecode:: apache ScriptAlias /app /path/to/the/application.cgi On shared webhosting, though, you might not have access to your Apache config. In this case, a file called .htaccess , sitting in the public directory you want your app to be available, works too but the ScriptAlias directive won't work in that case: .. sourcecode:: apache RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f # Don't interfere with static files RewriteRule ^(.*)$ /path/to/the/application.cgi/$1 [L] For more information consult the documentation of your webserver. .. _App Engine: https://developers.google.com/appengine/","title":"Server Setup"},{"location":"deploying/fastcgi/","text":".. _deploying-fastcgi: FastCGI \u00b6 FastCGI is a deployment option on servers like nginx , lighttpd , and cherokee ; see :doc: uwsgi and :doc: wsgi-standalone for other options. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is flup which we will use for this guide. Make sure to have it installed to follow along. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to FastCGI. Creating a .fcgi file \u00b6 First you need to create the FastCGI server file. Let's call it yourapplication.fcgi :: #!/usr/bin/python from flup.server.fcgi import WSGIServer from yourapplication import app if __name__ == '__main__' : WSGIServer ( app ) . run () This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the :class: ~flup.server.fcgi.WSGIServer :: WSGIServer(application, bindAddress='/path/to/fcgi.sock').run() The path has to be the exact same path you define in the server config. Save the :file: yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in :file: /var/www/yourapplication or something similar. Make sure to set the executable bit on that file so that the servers can execute it: .. sourcecode:: text $ chmod +x /var/www/yourapplication/yourapplication.fcgi Configuring Apache \u00b6 The example above is good enough for a basic Apache deployment but your .fcgi file will appear in your application URL e.g. example.com/yourapplication.fcgi/news/ . There are few ways to configure your application so that yourapplication.fcgi does not appear in the URL. A preferable way is to use the ScriptAlias and SetHandler configuration directives to route requests to the FastCGI server. The following example uses FastCgiServer to start 5 instances of the application which will handle all incoming requests:: LoadModule fastcgi_module /usr/lib64/httpd/modules/mod_fastcgi.so FastCgiServer /var/www/html/yourapplication/app.fcgi -idle-timeout 300 -processes 5 &lt;VirtualHost *&gt; ServerName webapp1.mydomain.com DocumentRoot /var/www/html/yourapplication AddHandler fastcgi-script fcgi ScriptAlias / /var/www/html/yourapplication/app.fcgi/ &lt;Location /&gt; SetHandler fastcgi-script &lt;/Location&gt; &lt;/VirtualHost&gt; These processes will be managed by Apache. If you're using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it's simply used as an identifier to other directives such as AliasMatch:: FastCgiServer /var/www/html/yourapplication -host 127.0.0.1:3000 If you cannot set ScriptAlias, for example on a shared web host, you can use WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess:: &lt;IfModule mod_fcgid.c&gt; AddHandler fcgid-script .fcgi &lt;Files ~ (\\.fcgi)&gt; SetHandler fcgid-script Options +FollowSymLinks +ExecCGI &lt;/Files&gt; &lt;/IfModule&gt; &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks RewriteEngine On RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ yourapplication.fcgi/$1 [QSA,L] &lt;/IfModule&gt; Set yourapplication.fcgi:: #!/usr/bin/python #: optional path to your local python site-packages folder import sys sys . path . insert ( 0 , '&lt;your_local_path&gt;/lib/python&lt;your_python_version&gt;/site-packages' ) from flup.server.fcgi import WSGIServer from yourapplication import app class ScriptNameStripper ( object ): def __init__ ( self , app ): self . app = app def __call__ ( self , environ , start_response ): environ [ 'SCRIPT_NAME' ] = '' return self . app ( environ , start_response ) app = ScriptNameStripper ( app ) if __name__ == '__main__' : WSGIServer ( app ) . run () Configuring lighttpd \u00b6 A basic FastCGI configuration for lighttpd looks like that:: fastcgi.server = (\"/yourapplication.fcgi\" =&gt; (( \"socket\" =&gt; \"/tmp/yourapplication-fcgi.sock\", \"bin-path\" =&gt; \"/var/www/yourapplication/yourapplication.fcgi\", \"check-local\" =&gt; \"disable\", \"max-procs\" =&gt; 1 )) ) alias.url = ( \"/static/\" =&gt; \"/path/to/your/static/\" ) url.rewrite-once = ( \"^(/static($|/.*))$\" =&gt; \"$1\", \"^(/.*)$\" =&gt; \"/yourapplication.fcgi$1\" ) Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication . If you want the application to work in the URL root you have to work around a lighttpd bug with the :class: ~werkzeug.contrib.fixers.LighttpdCGIRootFix middleware. Make sure to apply it only if you are mounting the application the URL root. Also, see the Lighty docs for more information on FastCGI and Python <https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI> _ (note that explicitly passing a socket to run() is no longer necessary). Configuring nginx \u00b6 Installing FastCGI applications on nginx is a bit different because by default no FastCGI parameters are forwarded. A basic Flask FastCGI configuration for nginx looks like this:: location = / yourapplication { rewrite ^ /yourapplication/ last ; } location / yourapplication { try_files $uri @yourapplication ; } location @ yourapplication { include fastcgi_params ; fastcgi_split_path_info ^(/ yourapplication )(.*)$; fastcgi_param PATH_INFO $ fastcgi_path_info ; fastcgi_param SCRIPT_NAME $ fastcgi_script_name ; fastcgi_pass unix :/ tmp / yourapplication-fcgi . sock ; } This configuration binds the application to /yourapplication . If you want to have it in the URL root it's a bit simpler because you don't have to figure out how to calculate PATH_INFO and SCRIPT_NAME :: location / { try_files $uri @yourapplication ; } location @ yourapplication { include fastcgi_params ; fastcgi_param PATH_INFO $ fastcgi_script_name ; fastcgi_param SCRIPT_NAME \"\" ; fastcgi_pass unix :/ tmp / yourapplication-fcgi . sock ; } Running FastCGI Processes \u00b6 Since nginx and others do not load FastCGI apps, you have to do it by yourself. Supervisor can manage FastCGI processes. <http://supervisord.org/configuration.html#fcgi-program-x-section-settings> _ You can look around for other FastCGI process managers or write a script to run your .fcgi file at boot, e.g. using a SysV init.d script. For a temporary solution, you can always run the .fcgi script inside GNU screen. See man screen for details, and note that this is a manual solution which does not persist across system restart:: $ screen $ /var/www/yourapplication/yourapplication.fcgi Debugging \u00b6 FastCGI deployments tend to be hard to debug on most web servers. Very often the only thing the server log tells you is something along the lines of \"premature end of headers\". In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand. This example assumes your application is called application.fcgi and that your web server user is www-data :: $ su www-data $ cd /var/www/yourapplication $ python application.fcgi Traceback ( most recent call last ) : File \"yourapplication.fcgi\" , line 4 , in & lt ; module & gt ; ImportError: No module named yourapplication In this case the error seems to be \"yourapplication\" not being on the python path. Common problems are: Relative paths being used. Don't rely on the current working directory. The code depending on environment variables that are not set by the web server. Different python interpreters being used. .. _nginx: https://nginx.org/ .. _lighttpd: https://www.lighttpd.net/ .. _cherokee: http://cherokee-project.com/ .. _flup: https://pypi.org/project/flup/","title":"Fastcgi"},{"location":"deploying/fastcgi/#fastcgi","text":"FastCGI is a deployment option on servers like nginx , lighttpd , and cherokee ; see :doc: uwsgi and :doc: wsgi-standalone for other options. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is flup which we will use for this guide. Make sure to have it installed to follow along. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to FastCGI.","title":"FastCGI"},{"location":"deploying/fastcgi/#creating-a-fcgi-file","text":"First you need to create the FastCGI server file. Let's call it yourapplication.fcgi :: #!/usr/bin/python from flup.server.fcgi import WSGIServer from yourapplication import app if __name__ == '__main__' : WSGIServer ( app ) . run () This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the :class: ~flup.server.fcgi.WSGIServer :: WSGIServer(application, bindAddress='/path/to/fcgi.sock').run() The path has to be the exact same path you define in the server config. Save the :file: yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in :file: /var/www/yourapplication or something similar. Make sure to set the executable bit on that file so that the servers can execute it: .. sourcecode:: text $ chmod +x /var/www/yourapplication/yourapplication.fcgi","title":"Creating a .fcgi file"},{"location":"deploying/fastcgi/#configuring-apache","text":"The example above is good enough for a basic Apache deployment but your .fcgi file will appear in your application URL e.g. example.com/yourapplication.fcgi/news/ . There are few ways to configure your application so that yourapplication.fcgi does not appear in the URL. A preferable way is to use the ScriptAlias and SetHandler configuration directives to route requests to the FastCGI server. The following example uses FastCgiServer to start 5 instances of the application which will handle all incoming requests:: LoadModule fastcgi_module /usr/lib64/httpd/modules/mod_fastcgi.so FastCgiServer /var/www/html/yourapplication/app.fcgi -idle-timeout 300 -processes 5 &lt;VirtualHost *&gt; ServerName webapp1.mydomain.com DocumentRoot /var/www/html/yourapplication AddHandler fastcgi-script fcgi ScriptAlias / /var/www/html/yourapplication/app.fcgi/ &lt;Location /&gt; SetHandler fastcgi-script &lt;/Location&gt; &lt;/VirtualHost&gt; These processes will be managed by Apache. If you're using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it's simply used as an identifier to other directives such as AliasMatch:: FastCgiServer /var/www/html/yourapplication -host 127.0.0.1:3000 If you cannot set ScriptAlias, for example on a shared web host, you can use WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess:: &lt;IfModule mod_fcgid.c&gt; AddHandler fcgid-script .fcgi &lt;Files ~ (\\.fcgi)&gt; SetHandler fcgid-script Options +FollowSymLinks +ExecCGI &lt;/Files&gt; &lt;/IfModule&gt; &lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks RewriteEngine On RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ yourapplication.fcgi/$1 [QSA,L] &lt;/IfModule&gt; Set yourapplication.fcgi:: #!/usr/bin/python #: optional path to your local python site-packages folder import sys sys . path . insert ( 0 , '&lt;your_local_path&gt;/lib/python&lt;your_python_version&gt;/site-packages' ) from flup.server.fcgi import WSGIServer from yourapplication import app class ScriptNameStripper ( object ): def __init__ ( self , app ): self . app = app def __call__ ( self , environ , start_response ): environ [ 'SCRIPT_NAME' ] = '' return self . app ( environ , start_response ) app = ScriptNameStripper ( app ) if __name__ == '__main__' : WSGIServer ( app ) . run ()","title":"Configuring Apache"},{"location":"deploying/fastcgi/#configuring-lighttpd","text":"A basic FastCGI configuration for lighttpd looks like that:: fastcgi.server = (\"/yourapplication.fcgi\" =&gt; (( \"socket\" =&gt; \"/tmp/yourapplication-fcgi.sock\", \"bin-path\" =&gt; \"/var/www/yourapplication/yourapplication.fcgi\", \"check-local\" =&gt; \"disable\", \"max-procs\" =&gt; 1 )) ) alias.url = ( \"/static/\" =&gt; \"/path/to/your/static/\" ) url.rewrite-once = ( \"^(/static($|/.*))$\" =&gt; \"$1\", \"^(/.*)$\" =&gt; \"/yourapplication.fcgi$1\" ) Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication . If you want the application to work in the URL root you have to work around a lighttpd bug with the :class: ~werkzeug.contrib.fixers.LighttpdCGIRootFix middleware. Make sure to apply it only if you are mounting the application the URL root. Also, see the Lighty docs for more information on FastCGI and Python <https://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI> _ (note that explicitly passing a socket to run() is no longer necessary).","title":"Configuring lighttpd"},{"location":"deploying/fastcgi/#configuring-nginx","text":"Installing FastCGI applications on nginx is a bit different because by default no FastCGI parameters are forwarded. A basic Flask FastCGI configuration for nginx looks like this:: location = / yourapplication { rewrite ^ /yourapplication/ last ; } location / yourapplication { try_files $uri @yourapplication ; } location @ yourapplication { include fastcgi_params ; fastcgi_split_path_info ^(/ yourapplication )(.*)$; fastcgi_param PATH_INFO $ fastcgi_path_info ; fastcgi_param SCRIPT_NAME $ fastcgi_script_name ; fastcgi_pass unix :/ tmp / yourapplication-fcgi . sock ; } This configuration binds the application to /yourapplication . If you want to have it in the URL root it's a bit simpler because you don't have to figure out how to calculate PATH_INFO and SCRIPT_NAME :: location / { try_files $uri @yourapplication ; } location @ yourapplication { include fastcgi_params ; fastcgi_param PATH_INFO $ fastcgi_script_name ; fastcgi_param SCRIPT_NAME \"\" ; fastcgi_pass unix :/ tmp / yourapplication-fcgi . sock ; }","title":"Configuring nginx"},{"location":"deploying/fastcgi/#running-fastcgi-processes","text":"Since nginx and others do not load FastCGI apps, you have to do it by yourself. Supervisor can manage FastCGI processes. <http://supervisord.org/configuration.html#fcgi-program-x-section-settings> _ You can look around for other FastCGI process managers or write a script to run your .fcgi file at boot, e.g. using a SysV init.d script. For a temporary solution, you can always run the .fcgi script inside GNU screen. See man screen for details, and note that this is a manual solution which does not persist across system restart:: $ screen $ /var/www/yourapplication/yourapplication.fcgi","title":"Running FastCGI Processes"},{"location":"deploying/fastcgi/#debugging","text":"FastCGI deployments tend to be hard to debug on most web servers. Very often the only thing the server log tells you is something along the lines of \"premature end of headers\". In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand. This example assumes your application is called application.fcgi and that your web server user is www-data :: $ su www-data $ cd /var/www/yourapplication $ python application.fcgi Traceback ( most recent call last ) : File \"yourapplication.fcgi\" , line 4 , in & lt ; module & gt ; ImportError: No module named yourapplication In this case the error seems to be \"yourapplication\" not being on the python path. Common problems are: Relative paths being used. Don't rely on the current working directory. The code depending on environment variables that are not set by the web server. Different python interpreters being used. .. _nginx: https://nginx.org/ .. _lighttpd: https://www.lighttpd.net/ .. _cherokee: http://cherokee-project.com/ .. _flup: https://pypi.org/project/flup/","title":"Debugging"},{"location":"deploying/mod_wsgi/","text":".. _mod_wsgi-deployment: mod_wsgi (Apache) \u00b6 If you are using the Apache webserver, consider using mod_wsgi . .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to mod_wsgi. .. _Apache: https://httpd.apache.org/ Installing mod_wsgi \u00b6 If you don't have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself. The mod wsgi installation instructions cover source installations on UNIX systems. If you are using Ubuntu/Debian you can apt-get it and activate it as follows: .. sourcecode:: text $ apt-get install libapache2-mod-wsgi If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can install it as follows: .. sourcecode:: text $ yum install mod_wsgi On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add: .. sourcecode:: text $ pkg install ap22-mod_wsgi2 If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package. If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server. Creating a .wsgi file \u00b6 To run your application you need a :file: yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application. For most applications the following file should be sufficient:: from yourapplication import app as application If a factory function is used in a :file: __init__.py file, then the function should be imported:: from yourapplication import create_app application = create_app () If you don't have a factory function for application creation but a singleton instance you can directly import that one as application . Store that file somewhere that you will find it again (e.g.: :file: /var/www/yourapplication ) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don't want to install it system wide consider using a virtual python _ instance. Keep in mind that you will have to actually install your application into the virtualenv as well. Alternatively there is the option to just patch the path in the .wsgi file before the import:: import sys sys . path . insert ( 0 , '/path/to/the/application' ) Configuring Apache \u00b6 The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons: .. sourcecode:: apache &lt;VirtualHost *&gt; ServerName example.com WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5 WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi &lt;Directory /var/www/yourapplication&gt; WSGIProcessGroup yourapplication WSGIApplicationGroup %{GLOBAL} Order deny,allow Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; Note: WSGIDaemonProcess isn't implemented in Windows and Apache will refuse to run with the above configuration. On a Windows system, eliminate those lines: .. sourcecode:: apache & lt ; VirtualHost *& gt ; ServerName example . com WSGIScriptAlias / C : \\ yourdir \\ yourapp . wsgi & lt ; Directory C : \\ yourdir & gt ; Order deny , allow Allow from all & lt ;/ Directory & gt ; & lt ;/ VirtualHost & gt ; Note: There have been some changes in access control configuration for Apache 2.4 _. .. _Apache 2.4: https://httpd.apache.org/docs/trunk/upgrading.html Most notably, the syntax for directory permissions has changed from httpd 2.2 .. sourcecode:: apache Order allow,deny Allow from all to httpd 2.4 syntax .. sourcecode:: apache Require all granted For more information consult the mod_wsgi documentation _. .. _mod_wsgi: https://github.com/GrahamDumpleton/mod_wsgi .. _installation instructions: https://modwsgi.readthedocs.io/en/develop/installation.html .. _virtual python: https://pypi.org/project/virtualenv/ .. _mod_wsgi documentation: https://modwsgi.readthedocs.io/en/develop/index.html Troubleshooting \u00b6 If your application does not run, follow this guide to troubleshoot: Problem: application does not run, errorlog shows SystemExit ignored You have an app.run() call in your application file that is not guarded by an if __name__ == '__main__': condition. Either remove that :meth: ~flask.Flask.run call from the file and move it into a separate :file: run.py file or put it into such an if block. Problem: application gives permission errors Probably caused by your application running as the wrong user. Make sure the folders the application needs access to have the proper privileges set and the application runs as the correct user ( user and group parameter to the WSGIDaemonProcess directive) Problem: application dies with an error on print Keep in mind that mod_wsgi disallows doing anything with :data: sys.stdout and :data: sys.stderr . You can disable this protection from the config by setting the WSGIRestrictStdout to off : .. sourcecode :: apache WSGIRestrictStdout Off Alternatively you can also replace the standard out in the . wsgi file with a different stream :: import sys sys . stdout = sys . stderr Problem: accessing resources gives IO errors Your application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package. The reason for this is that for non-installed packages, the module filename is used to locate the resources and for symlinks the wrong filename is picked up. Support for Automatic Reloading \u00b6 To help deployment tools you can activate support for automatic reloading. Whenever something changes the .wsgi file, mod_wsgi will reload all the daemon processes for us. For that, just add the following directive to your Directory section: .. sourcecode:: apache WSGIScriptReloading On Working with Virtual Environments \u00b6 Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your .wsgi file slightly. Add the following lines to the top of your .wsgi file:: activate_this = '/path/to/env/bin/activate_this.py' execfile(activate_this, dict(__file__=activate_this)) For Python 3 add the following lines to the top of your .wsgi file:: activate_this = '/path/to/env/bin/activate_this.py' with open(activate_this) as file_: exec(file_.read(), dict(__file__=activate_this)) This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute.","title":"Mod wsgi"},{"location":"deploying/mod_wsgi/#mod_wsgi-apache","text":"If you are using the Apache webserver, consider using mod_wsgi . .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to mod_wsgi. .. _Apache: https://httpd.apache.org/","title":"mod_wsgi (Apache)"},{"location":"deploying/mod_wsgi/#installing-mod_wsgi","text":"If you don't have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself. The mod wsgi installation instructions cover source installations on UNIX systems. If you are using Ubuntu/Debian you can apt-get it and activate it as follows: .. sourcecode:: text $ apt-get install libapache2-mod-wsgi If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can install it as follows: .. sourcecode:: text $ yum install mod_wsgi On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add: .. sourcecode:: text $ pkg install ap22-mod_wsgi2 If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package. If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server.","title":"Installing mod_wsgi"},{"location":"deploying/mod_wsgi/#creating-a-wsgi-file","text":"To run your application you need a :file: yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application. For most applications the following file should be sufficient:: from yourapplication import app as application If a factory function is used in a :file: __init__.py file, then the function should be imported:: from yourapplication import create_app application = create_app () If you don't have a factory function for application creation but a singleton instance you can directly import that one as application . Store that file somewhere that you will find it again (e.g.: :file: /var/www/yourapplication ) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don't want to install it system wide consider using a virtual python _ instance. Keep in mind that you will have to actually install your application into the virtualenv as well. Alternatively there is the option to just patch the path in the .wsgi file before the import:: import sys sys . path . insert ( 0 , '/path/to/the/application' )","title":"Creating a .wsgi file"},{"location":"deploying/mod_wsgi/#configuring-apache","text":"The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons: .. sourcecode:: apache &lt;VirtualHost *&gt; ServerName example.com WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5 WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi &lt;Directory /var/www/yourapplication&gt; WSGIProcessGroup yourapplication WSGIApplicationGroup %{GLOBAL} Order deny,allow Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; Note: WSGIDaemonProcess isn't implemented in Windows and Apache will refuse to run with the above configuration. On a Windows system, eliminate those lines: .. sourcecode:: apache & lt ; VirtualHost *& gt ; ServerName example . com WSGIScriptAlias / C : \\ yourdir \\ yourapp . wsgi & lt ; Directory C : \\ yourdir & gt ; Order deny , allow Allow from all & lt ;/ Directory & gt ; & lt ;/ VirtualHost & gt ; Note: There have been some changes in access control configuration for Apache 2.4 _. .. _Apache 2.4: https://httpd.apache.org/docs/trunk/upgrading.html Most notably, the syntax for directory permissions has changed from httpd 2.2 .. sourcecode:: apache Order allow,deny Allow from all to httpd 2.4 syntax .. sourcecode:: apache Require all granted For more information consult the mod_wsgi documentation _. .. _mod_wsgi: https://github.com/GrahamDumpleton/mod_wsgi .. _installation instructions: https://modwsgi.readthedocs.io/en/develop/installation.html .. _virtual python: https://pypi.org/project/virtualenv/ .. _mod_wsgi documentation: https://modwsgi.readthedocs.io/en/develop/index.html","title":"Configuring Apache"},{"location":"deploying/mod_wsgi/#troubleshooting","text":"If your application does not run, follow this guide to troubleshoot: Problem: application does not run, errorlog shows SystemExit ignored You have an app.run() call in your application file that is not guarded by an if __name__ == '__main__': condition. Either remove that :meth: ~flask.Flask.run call from the file and move it into a separate :file: run.py file or put it into such an if block. Problem: application gives permission errors Probably caused by your application running as the wrong user. Make sure the folders the application needs access to have the proper privileges set and the application runs as the correct user ( user and group parameter to the WSGIDaemonProcess directive) Problem: application dies with an error on print Keep in mind that mod_wsgi disallows doing anything with :data: sys.stdout and :data: sys.stderr . You can disable this protection from the config by setting the WSGIRestrictStdout to off : .. sourcecode :: apache WSGIRestrictStdout Off Alternatively you can also replace the standard out in the . wsgi file with a different stream :: import sys sys . stdout = sys . stderr Problem: accessing resources gives IO errors Your application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package. The reason for this is that for non-installed packages, the module filename is used to locate the resources and for symlinks the wrong filename is picked up.","title":"Troubleshooting"},{"location":"deploying/mod_wsgi/#support-for-automatic-reloading","text":"To help deployment tools you can activate support for automatic reloading. Whenever something changes the .wsgi file, mod_wsgi will reload all the daemon processes for us. For that, just add the following directive to your Directory section: .. sourcecode:: apache WSGIScriptReloading On","title":"Support for Automatic Reloading"},{"location":"deploying/mod_wsgi/#working-with-virtual-environments","text":"Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your .wsgi file slightly. Add the following lines to the top of your .wsgi file:: activate_this = '/path/to/env/bin/activate_this.py' execfile(activate_this, dict(__file__=activate_this)) For Python 3 add the following lines to the top of your .wsgi file:: activate_this = '/path/to/env/bin/activate_this.py' with open(activate_this) as file_: exec(file_.read(), dict(__file__=activate_this)) This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute.","title":"Working with Virtual Environments"},{"location":"deploying/uwsgi/","text":".. _deploying-uwsgi: uWSGI \u00b6 uWSGI is a deployment option on servers like nginx , lighttpd , and cherokee _; see :doc: fastcgi and :doc: wsgi-standalone for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols. The most popular uWSGI server is uwsgi _, which we will use for this guide. Make sure to have it installed to follow along. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to uWSGI. Starting your app with uwsgi \u00b6 uwsgi is designed to operate on WSGI callables found in python modules. Given a flask application in myapp.py, use the following command: .. sourcecode:: text $ uwsgi -s /tmp/yourapplication.sock --manage-script-name --mount /yourapplication = myapp:app The --manage-script-name will move the handling of SCRIPT_NAME to uwsgi, since it is smarter about that. It is used together with the --mount directive which will make requests to /yourapplication be directed to myapp:app . If your application is accessible at root level, you can use a single / instead of /yourapplication . myapp refers to the name of the file of your flask application (without extension) or the module which provides app . app is the callable inside of your application (usually the line reads app = Flask(__name__) . If you want to deploy your flask application inside of a virtual environment, you need to also add --virtualenv /path/to/virtual/environment . You might also need to add --plugin python or --plugin python3 depending on which python version you use for your project. Configuring nginx \u00b6 A basic flask nginx configuration looks like this:: location = / yourapplication { rewrite ^ /yourapplication/ ; } location / yourapplication { try_files $uri @yourapplication ; } location @ yourapplication { include uwsgi_params ; uwsgi_pass unix :/ tmp / yourapplication . sock ; } This configuration binds the application to /yourapplication . If you want to have it in the URL root its a bit simpler:: location / { try_files $uri @yourapplication ; } location @ yourapplication { include uwsgi_params ; uwsgi_pass unix :/ tmp / yourapplication . sock ; } .. _nginx: https://nginx.org/ .. _lighttpd: https://www.lighttpd.net/ .. _cherokee: http://cherokee-project.com/ .. _uwsgi: https://uwsgi-docs.readthedocs.io/","title":"Uwsgi"},{"location":"deploying/uwsgi/#uwsgi","text":"uWSGI is a deployment option on servers like nginx , lighttpd , and cherokee _; see :doc: fastcgi and :doc: wsgi-standalone for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols. The most popular uWSGI server is uwsgi _, which we will use for this guide. Make sure to have it installed to follow along. .. admonition:: Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ == '__main__': block or moved to a separate file. Just make sure it's not called because this will always start a local WSGI server which we do not want if we deploy that application to uWSGI.","title":"uWSGI"},{"location":"deploying/uwsgi/#starting-your-app-with-uwsgi","text":"uwsgi is designed to operate on WSGI callables found in python modules. Given a flask application in myapp.py, use the following command: .. sourcecode:: text $ uwsgi -s /tmp/yourapplication.sock --manage-script-name --mount /yourapplication = myapp:app The --manage-script-name will move the handling of SCRIPT_NAME to uwsgi, since it is smarter about that. It is used together with the --mount directive which will make requests to /yourapplication be directed to myapp:app . If your application is accessible at root level, you can use a single / instead of /yourapplication . myapp refers to the name of the file of your flask application (without extension) or the module which provides app . app is the callable inside of your application (usually the line reads app = Flask(__name__) . If you want to deploy your flask application inside of a virtual environment, you need to also add --virtualenv /path/to/virtual/environment . You might also need to add --plugin python or --plugin python3 depending on which python version you use for your project.","title":"Starting your app with uwsgi"},{"location":"deploying/uwsgi/#configuring-nginx","text":"A basic flask nginx configuration looks like this:: location = / yourapplication { rewrite ^ /yourapplication/ ; } location / yourapplication { try_files $uri @yourapplication ; } location @ yourapplication { include uwsgi_params ; uwsgi_pass unix :/ tmp / yourapplication . sock ; } This configuration binds the application to /yourapplication . If you want to have it in the URL root its a bit simpler:: location / { try_files $uri @yourapplication ; } location @ yourapplication { include uwsgi_params ; uwsgi_pass unix :/ tmp / yourapplication . sock ; } .. _nginx: https://nginx.org/ .. _lighttpd: https://www.lighttpd.net/ .. _cherokee: http://cherokee-project.com/ .. _uwsgi: https://uwsgi-docs.readthedocs.io/","title":"Configuring nginx"},{"location":"deploying/wsgi-standalone/","text":".. _deploying-wsgi-standalone: Standalone WSGI Containers \u00b6 There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on :ref: deploying-proxy-setups if you run into issues. Gunicorn \u00b6 Gunicorn 'Green Unicorn' is a WSGI HTTP Server for UNIX. It's a pre-fork worker model ported from Ruby's Unicorn project. It supports both eventlet and greenlet _. Running a Flask application on this server is quite simple:: $ gunicorn myproject:app Gunicorn _ provides many command-line options -- see gunicorn -h . For example, to run a Flask application with 4 worker processes ( -w 4 ) binding to localhost port 4000 ( -b 127.0.0.1:4000 ):: $ gunicorn -w 4 -b 127 .0.0.1:4000 myproject:app .. _Gunicorn: https://gunicorn.org/ .. _eventlet: https://eventlet.net/ .. _greenlet: https://greenlet.readthedocs.io/en/latest/ uWSGI \u00b6 uWSGI _ is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. Running uWSGI HTTP Router _:: $ uwsgi --http 127 .0.0.1:5000 --module myproject:app For a more optimized setup, see :doc: configuring uWSGI and NGINX <uwsgi> . .. _uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/ .. _uWSGI HTTP Router: https://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#the-uwsgi-http-https-router Gevent \u00b6 Gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of libev _ event loop:: from gevent.pywsgi import WSGIServer from yourapplication import app http_server = WSGIServer (( '' , 5000 ), app ) http_server . serve_forever () .. _Gevent: http://www.gevent.org/ .. _greenlet: https://greenlet.readthedocs.io/en/latest/ .. _libev: http://software.schmorp.de/pkg/libev.html Twisted Web \u00b6 Twisted Web is the web server shipped with Twisted , a mature, non-blocking event-driven networking library. Twisted Web comes with a standard WSGI container which can be controlled from the command line using the twistd utility:: $ twistd web --wsgi myproject.app This example will run a Flask application called app from a module named myproject . Twisted Web supports many flags and options, and the twistd utility does as well; see twistd -h and twistd web -h for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from myproject :: $ twistd -n web --port tcp:8080 --wsgi myproject.app .. _Twisted: https://twistedmatrix.com/ .. _Twisted Web: https://twistedmatrix.com/trac/wiki/TwistedWeb .. _deploying-proxy-setups: Proxy Setups \u00b6 If you deploy your application using one of these servers behind an HTTP proxy you will need to rewrite a few headers in order for the application to work. The two problematic values in the WSGI environment usually are REMOTE_ADDR and HTTP_HOST . You can configure your httpd to pass these headers, or you can fix them in middleware. Werkzeug ships a fixer that will solve some common setups, but you might want to write your own WSGI middleware for specific setups. Here's a simple nginx configuration which proxies to an application served on localhost at port 8000, setting appropriate headers: .. sourcecode:: nginx server { listen 80 ; server_name _ ; access_log /var/log/nginx/access.log ; error_log /var/log/nginx/error.log ; location / { proxy_pass http : // 127.0.0.1 : 8000 / ; proxy_redirect off ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header X-Forwarded-Proto $scheme ; } } If your httpd is not providing these headers, the most common setup invokes the host being set from X-Forwarded-Host and the remote address from X-Forwarded-For :: from werkzeug.contrib.fixers import ProxyFix app . wsgi_app = ProxyFix ( app . wsgi_app ) .. admonition:: Trusting Headers Please keep in mind that it is a security issue to use such a middleware in a non-proxy setup because it will blindly trust the incoming headers which might be forged by malicious clients. If you want to rewrite the headers from another header, you might want to use a fixer like this:: class CustomProxyFix ( object ) : def __init__ ( self , app ) : self . app = app def __call__ ( self , environ , start_response ) : host = environ . get ( 'HTTP_X_FHOST' , '' ) if host : environ [ 'HTTP_HOST' ] = host return self . app ( environ , start_response ) app . wsgi_app = CustomProxyFix ( app . wsgi_app )","title":"Wsgi standalone"},{"location":"deploying/wsgi-standalone/#standalone-wsgi-containers","text":"There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on :ref: deploying-proxy-setups if you run into issues.","title":"Standalone WSGI Containers"},{"location":"deploying/wsgi-standalone/#gunicorn","text":"Gunicorn 'Green Unicorn' is a WSGI HTTP Server for UNIX. It's a pre-fork worker model ported from Ruby's Unicorn project. It supports both eventlet and greenlet _. Running a Flask application on this server is quite simple:: $ gunicorn myproject:app Gunicorn _ provides many command-line options -- see gunicorn -h . For example, to run a Flask application with 4 worker processes ( -w 4 ) binding to localhost port 4000 ( -b 127.0.0.1:4000 ):: $ gunicorn -w 4 -b 127 .0.0.1:4000 myproject:app .. _Gunicorn: https://gunicorn.org/ .. _eventlet: https://eventlet.net/ .. _greenlet: https://greenlet.readthedocs.io/en/latest/","title":"Gunicorn"},{"location":"deploying/wsgi-standalone/#uwsgi","text":"uWSGI _ is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. Running uWSGI HTTP Router _:: $ uwsgi --http 127 .0.0.1:5000 --module myproject:app For a more optimized setup, see :doc: configuring uWSGI and NGINX <uwsgi> . .. _uWSGI: https://uwsgi-docs.readthedocs.io/en/latest/ .. _uWSGI HTTP Router: https://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#the-uwsgi-http-https-router","title":"uWSGI"},{"location":"deploying/wsgi-standalone/#gevent","text":"Gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of libev _ event loop:: from gevent.pywsgi import WSGIServer from yourapplication import app http_server = WSGIServer (( '' , 5000 ), app ) http_server . serve_forever () .. _Gevent: http://www.gevent.org/ .. _greenlet: https://greenlet.readthedocs.io/en/latest/ .. _libev: http://software.schmorp.de/pkg/libev.html","title":"Gevent"},{"location":"deploying/wsgi-standalone/#twisted-web","text":"Twisted Web is the web server shipped with Twisted , a mature, non-blocking event-driven networking library. Twisted Web comes with a standard WSGI container which can be controlled from the command line using the twistd utility:: $ twistd web --wsgi myproject.app This example will run a Flask application called app from a module named myproject . Twisted Web supports many flags and options, and the twistd utility does as well; see twistd -h and twistd web -h for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from myproject :: $ twistd -n web --port tcp:8080 --wsgi myproject.app .. _Twisted: https://twistedmatrix.com/ .. _Twisted Web: https://twistedmatrix.com/trac/wiki/TwistedWeb .. _deploying-proxy-setups:","title":"Twisted Web"},{"location":"deploying/wsgi-standalone/#proxy-setups","text":"If you deploy your application using one of these servers behind an HTTP proxy you will need to rewrite a few headers in order for the application to work. The two problematic values in the WSGI environment usually are REMOTE_ADDR and HTTP_HOST . You can configure your httpd to pass these headers, or you can fix them in middleware. Werkzeug ships a fixer that will solve some common setups, but you might want to write your own WSGI middleware for specific setups. Here's a simple nginx configuration which proxies to an application served on localhost at port 8000, setting appropriate headers: .. sourcecode:: nginx server { listen 80 ; server_name _ ; access_log /var/log/nginx/access.log ; error_log /var/log/nginx/error.log ; location / { proxy_pass http : // 127.0.0.1 : 8000 / ; proxy_redirect off ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header X-Forwarded-Proto $scheme ; } } If your httpd is not providing these headers, the most common setup invokes the host being set from X-Forwarded-Host and the remote address from X-Forwarded-For :: from werkzeug.contrib.fixers import ProxyFix app . wsgi_app = ProxyFix ( app . wsgi_app ) .. admonition:: Trusting Headers Please keep in mind that it is a security issue to use such a middleware in a non-proxy setup because it will blindly trust the incoming headers which might be forged by malicious clients. If you want to rewrite the headers from another header, you might want to use a fixer like this:: class CustomProxyFix ( object ) : def __init__ ( self , app ) : self . app = app def __call__ ( self , environ , start_response ) : host = environ . get ( 'HTTP_X_FHOST' , '' ) if host : environ [ 'HTTP_HOST' ] = host return self . app ( environ , start_response ) app . wsgi_app = CustomProxyFix ( app . wsgi_app )","title":"Proxy Setups"},{"location":"patterns/","text":".. _patterns: Patterns for Flask \u00b6 Certain things are common enough that the chances are high you will find them in most web applications. For example quite a lot of applications are using relational databases and user authentication. In that case, chances are they will open a database connection at the beginning of the request and get the information of the currently logged in user. At the end of the request, the database connection is closed again. There are more user contributed snippets and patterns in the Flask Snippet Archives <http://flask.pocoo.org/snippets/> _. .. toctree:: :maxdepth: 2 packages appfactories appdispatch apierrors urlprocessors distribute fabric sqlite3 sqlalchemy fileuploads caching viewdecorators wtforms templateinheritance flashing jquery errorpages lazyloading mongoengine favicon streaming deferredcallbacks methodoverrides requestchecksum celery subclassing singlepageapplications","title":"Index"},{"location":"patterns/#patterns-for-flask","text":"Certain things are common enough that the chances are high you will find them in most web applications. For example quite a lot of applications are using relational databases and user authentication. In that case, chances are they will open a database connection at the beginning of the request and get the information of the currently logged in user. At the end of the request, the database connection is closed again. There are more user contributed snippets and patterns in the Flask Snippet Archives <http://flask.pocoo.org/snippets/> _. .. toctree:: :maxdepth: 2 packages appfactories appdispatch apierrors urlprocessors distribute fabric sqlite3 sqlalchemy fileuploads caching viewdecorators wtforms templateinheritance flashing jquery errorpages lazyloading mongoengine favicon streaming deferredcallbacks methodoverrides requestchecksum celery subclassing singlepageapplications","title":"Patterns for Flask"},{"location":"patterns/apierrors/","text":"Implementing API Exceptions \u00b6 It's very common to implement RESTful APIs on top of Flask. One of the first things that developers run into is the realization that the builtin exceptions are not expressive enough for APIs and that the content type of :mimetype: text/html they are emitting is not very useful for API consumers. The better solution than using abort to signal errors for invalid API usage is to implement your own exception type and install an error handler for it that produces the errors in the format the user is expecting. Simple Exception Class \u00b6 The basic idea is to introduce a new exception that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error. This is a simple example:: from flask import jsonify class InvalidUsage ( Exception ): status_code = 400 def __init__ ( self , message , status_code = None , payload = None ): Exception . __init__ ( self ) self . message = message if status_code is not None : self . status_code = status_code self . payload = payload def to_dict ( self ): rv = dict ( self . payload or ()) rv [ 'message' ] = self . message return rv A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the payload parameter. Registering an Error Handler \u00b6 At that point views can raise that error, but it would immediately result in an internal server error. The reason for this is that there is no handler registered for this error class. That however is easy to add:: @app.errorhandler(InvalidUsage) def handle_invalid_usage(error): response = jsonify(error.to_dict()) response.status_code = error.status_code return response Usage in Views \u00b6 Here is how a view can use that functionality:: @app.route('/foo') def get_foo(): raise InvalidUsage('This view is gone', status_code=410)","title":"Implementing API Exceptions"},{"location":"patterns/apierrors/#implementing-api-exceptions","text":"It's very common to implement RESTful APIs on top of Flask. One of the first things that developers run into is the realization that the builtin exceptions are not expressive enough for APIs and that the content type of :mimetype: text/html they are emitting is not very useful for API consumers. The better solution than using abort to signal errors for invalid API usage is to implement your own exception type and install an error handler for it that produces the errors in the format the user is expecting.","title":"Implementing API Exceptions"},{"location":"patterns/apierrors/#simple-exception-class","text":"The basic idea is to introduce a new exception that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error. This is a simple example:: from flask import jsonify class InvalidUsage ( Exception ): status_code = 400 def __init__ ( self , message , status_code = None , payload = None ): Exception . __init__ ( self ) self . message = message if status_code is not None : self . status_code = status_code self . payload = payload def to_dict ( self ): rv = dict ( self . payload or ()) rv [ 'message' ] = self . message return rv A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the payload parameter.","title":"Simple Exception Class"},{"location":"patterns/apierrors/#registering-an-error-handler","text":"At that point views can raise that error, but it would immediately result in an internal server error. The reason for this is that there is no handler registered for this error class. That however is easy to add:: @app.errorhandler(InvalidUsage) def handle_invalid_usage(error): response = jsonify(error.to_dict()) response.status_code = error.status_code return response","title":"Registering an Error Handler"},{"location":"patterns/apierrors/#usage-in-views","text":"Here is how a view can use that functionality:: @app.route('/foo') def get_foo(): raise InvalidUsage('This view is gone', status_code=410)","title":"Usage in Views"},{"location":"patterns/appdispatch/","text":".. _app-dispatch: Application Dispatching \u00b6 Application dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally. The fundamental difference from the :ref: module approach <larger-applications> is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level. Working with this Document \u00b6 Each of the techniques and examples below results in an application object that can be run with any WSGI server. For production, see :ref: deployment . For development, Werkzeug provides a builtin server for development available at :func: werkzeug.serving.run_simple :: from werkzeug.serving import run_simple run_simple ( 'localhost' , 5000 , application , use_reloader = True ) Note that :func: run_simple <werkzeug.serving.run_simple> is not intended for use in production. Use a :ref: full-blown WSGI server <deployment> . In order to use the interactive debugger, debugging must be enabled both on the application and the simple server. Here is the \"hello world\" example with debugging and :func: run_simple <werkzeug.serving.run_simple> :: from flask import Flask from werkzeug.serving import run_simple app = Flask ( __name__ ) app . debug = True @app.route ( '/' ) def hello_world (): return 'Hello World!' if __name__ == '__main__' : run_simple ( 'localhost' , 5000 , app , use_reloader = True , use_debugger = True , use_evalex = True ) Combining Applications \u00b6 If you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the :class: werkzeug.wsgi.DispatcherMiddleware . The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix. For example you could have your main application run on / and your backend interface on /backend :: from werkzeug.wsgi import DispatcherMiddleware from frontend_app import application as frontend from backend_app import application as backend application = DispatcherMiddleware ( frontend , { '/backend' : backend }) Dispatch by Subdomain \u00b6 Sometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the :ref: app-factories pattern. A very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation. The perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered:: from threading import Lock class SubdomainDispatcher ( object ) : def __ init__ ( self , domain , create_app ) : self . domain = domain self . create_app = create_app self . lock = Lock () self . instances = {} def get_application ( self , host ) : host = host . split ( ':' )[ 0 ] assert host . endswith ( self . domain ), 'Configuration error' subdomain = host [:- len ( self . domain )]. rstrip ( '.' ) with self . lock : app = self . instances . get ( subdomain ) if app is None : app = self . create_app ( subdomain ) self . instances [ subdomain ] = app return app def __ call__ ( self , environ , start_response ) : app = self . get_application ( environ [ 'HTTP_HOST' ]) return app ( environ , start_response ) This dispatcher can then be used like this:: from myapplication import create_app , get_user_for_subdomain from werkzeug.exceptions import NotFound def make_app ( subdomain ): user = get_user_for_subdomain ( subdomain ) if user is None : # if there is no user for that subdomain we still have # to return a WSGI application that handles that request. # We can then just return the NotFound() exception as # application which will render a default 404 page. # You might also redirect the user to the main page then return NotFound () # otherwise create the application for the specific user return create_app ( user ) application = SubdomainDispatcher ( 'example.com' , make_app ) Dispatch by Path \u00b6 Dispatching by a path on the URL is very similar. Instead of looking at the Host header to figure out the subdomain one simply looks at the request path up to the first slash:: from threading import Lock from werkzeug.wsgi import pop_path_info , peek_path_info class PathDispatcher ( object ): def __init__ ( self , default_app , create_app ): self . default_app = default_app self . create_app = create_app self . lock = Lock () self . instances = {} def get_application ( self , prefix ): with self . lock : app = self . instances . get ( prefix ) if app is None : app = self . create_app ( prefix ) if app is not None : self . instances [ prefix ] = app return app def __call__ ( self , environ , start_response ): app = self . get_application ( peek_path_info ( environ )) if app is not None : pop_path_info ( environ ) else : app = self . default_app return app ( environ , start_response ) The big difference between this and the subdomain one is that this one falls back to another application if the creator function returns None :: from myapplication import create_app , default_app , get_user_for_prefix def make_app ( prefix ): user = get_user_for_prefix ( prefix ) if user is not None : return create_app ( user ) application = PathDispatcher ( default_app , make_app )","title":"Appdispatch"},{"location":"patterns/appdispatch/#application-dispatching","text":"Application dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally. The fundamental difference from the :ref: module approach <larger-applications> is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level.","title":"Application Dispatching"},{"location":"patterns/appdispatch/#working-with-this-document","text":"Each of the techniques and examples below results in an application object that can be run with any WSGI server. For production, see :ref: deployment . For development, Werkzeug provides a builtin server for development available at :func: werkzeug.serving.run_simple :: from werkzeug.serving import run_simple run_simple ( 'localhost' , 5000 , application , use_reloader = True ) Note that :func: run_simple <werkzeug.serving.run_simple> is not intended for use in production. Use a :ref: full-blown WSGI server <deployment> . In order to use the interactive debugger, debugging must be enabled both on the application and the simple server. Here is the \"hello world\" example with debugging and :func: run_simple <werkzeug.serving.run_simple> :: from flask import Flask from werkzeug.serving import run_simple app = Flask ( __name__ ) app . debug = True @app.route ( '/' ) def hello_world (): return 'Hello World!' if __name__ == '__main__' : run_simple ( 'localhost' , 5000 , app , use_reloader = True , use_debugger = True , use_evalex = True )","title":"Working with this Document"},{"location":"patterns/appdispatch/#combining-applications","text":"If you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the :class: werkzeug.wsgi.DispatcherMiddleware . The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix. For example you could have your main application run on / and your backend interface on /backend :: from werkzeug.wsgi import DispatcherMiddleware from frontend_app import application as frontend from backend_app import application as backend application = DispatcherMiddleware ( frontend , { '/backend' : backend })","title":"Combining Applications"},{"location":"patterns/appdispatch/#dispatch-by-subdomain","text":"Sometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the :ref: app-factories pattern. A very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation. The perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered:: from threading import Lock class SubdomainDispatcher ( object ) : def __ init__ ( self , domain , create_app ) : self . domain = domain self . create_app = create_app self . lock = Lock () self . instances = {} def get_application ( self , host ) : host = host . split ( ':' )[ 0 ] assert host . endswith ( self . domain ), 'Configuration error' subdomain = host [:- len ( self . domain )]. rstrip ( '.' ) with self . lock : app = self . instances . get ( subdomain ) if app is None : app = self . create_app ( subdomain ) self . instances [ subdomain ] = app return app def __ call__ ( self , environ , start_response ) : app = self . get_application ( environ [ 'HTTP_HOST' ]) return app ( environ , start_response ) This dispatcher can then be used like this:: from myapplication import create_app , get_user_for_subdomain from werkzeug.exceptions import NotFound def make_app ( subdomain ): user = get_user_for_subdomain ( subdomain ) if user is None : # if there is no user for that subdomain we still have # to return a WSGI application that handles that request. # We can then just return the NotFound() exception as # application which will render a default 404 page. # You might also redirect the user to the main page then return NotFound () # otherwise create the application for the specific user return create_app ( user ) application = SubdomainDispatcher ( 'example.com' , make_app )","title":"Dispatch by Subdomain"},{"location":"patterns/appdispatch/#dispatch-by-path","text":"Dispatching by a path on the URL is very similar. Instead of looking at the Host header to figure out the subdomain one simply looks at the request path up to the first slash:: from threading import Lock from werkzeug.wsgi import pop_path_info , peek_path_info class PathDispatcher ( object ): def __init__ ( self , default_app , create_app ): self . default_app = default_app self . create_app = create_app self . lock = Lock () self . instances = {} def get_application ( self , prefix ): with self . lock : app = self . instances . get ( prefix ) if app is None : app = self . create_app ( prefix ) if app is not None : self . instances [ prefix ] = app return app def __call__ ( self , environ , start_response ): app = self . get_application ( peek_path_info ( environ )) if app is not None : pop_path_info ( environ ) else : app = self . default_app return app ( environ , start_response ) The big difference between this and the subdomain one is that this one falls back to another application if the creator function returns None :: from myapplication import create_app , default_app , get_user_for_prefix def make_app ( prefix ): user = get_user_for_prefix ( prefix ) if user is not None : return create_app ( user ) application = PathDispatcher ( default_app , make_app )","title":"Dispatch by Path"},{"location":"patterns/appfactories/","text":".. _app-factories: Application Factories \u00b6 If you are already using packages and blueprints for your application (:ref: blueprints ) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later. So why would you want to do this? Testing. You can have instances of the application with different settings to test every case. Multiple instances. Imagine you want to run different versions of the same application. Of course you could have multiple instances with different configs set up in your webserver, but if you use factories, you can have multiple instances of the same application running in the same application process which can be handy. So how would you then actually implement that? Basic Factories \u00b6 The idea is to set up the application in a function. Like this:: def create_app ( config_filename ): app = Flask ( __name__ ) app . config . from_pyfile ( config_filename ) from yourapplication.model import db db . init_app ( app ) from yourapplication.views.admin import admin from yourapplication.views.frontend import frontend app . register_blueprint ( admin ) app . register_blueprint ( frontend ) return app The downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use :data: ~flask.current_app :: from flask import current_app , Blueprint , render_template admin = Blueprint ( 'admin' , __name__ , url_prefix = '/admin' ) @admin.route ( '/' ) def index (): return render_template ( current_app . config [ 'INDEX_TEMPLATE' ]) Here we look up the name of a template in the config. Factories & Extensions \u00b6 It's preferable to create your extensions and app factories so that the extension object does not initially get bound to the application. Using Flask-SQLAlchemy <http://flask-sqlalchemy.pocoo.org/> _, as an example, you should not do something along those lines:: def create_app(config_filename): app = Flask(__name__) app.config.from_pyfile(config_filename) db = SQLAlchemy(app) But, rather, in model.py (or equivalent):: db = SQLAlchemy() and in your application.py (or equivalent):: def create_app ( config_filename ): app = Flask ( __name__ ) app . config . from_pyfile ( config_filename ) from yourapplication.model import db db . init_app ( app ) Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to :doc: /extensiondev . Using Applications \u00b6 To run such an application, you can use the :command: flask command:: $ export FLASK_APP = myapp $ flask run Flask will automatically detect the factory ( create_app or make_app ) in myapp . You can also pass arguments to the factory like this:: $ export FLASK_APP = \"myapp:create_app('dev')\" $ flask run Then the create_app factory in myapp is called with the string 'dev' as the argument. See :doc: /cli for more detail. Factory Improvements \u00b6 The factory function above is not very clever, but you can improve it. The following changes are straightforward to implement: Make it possible to pass in configuration values for unit tests so that you don't have to create config files on the filesystem. Call a function from a blueprint when the application is setting up so that you have a place to modify attributes of the application (like hooking in before/after request handlers etc.) Add in WSGI middlewares when the application is being created if necessary.","title":"Appfactories"},{"location":"patterns/appfactories/#application-factories","text":"If you are already using packages and blueprints for your application (:ref: blueprints ) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later. So why would you want to do this? Testing. You can have instances of the application with different settings to test every case. Multiple instances. Imagine you want to run different versions of the same application. Of course you could have multiple instances with different configs set up in your webserver, but if you use factories, you can have multiple instances of the same application running in the same application process which can be handy. So how would you then actually implement that?","title":"Application Factories"},{"location":"patterns/appfactories/#basic-factories","text":"The idea is to set up the application in a function. Like this:: def create_app ( config_filename ): app = Flask ( __name__ ) app . config . from_pyfile ( config_filename ) from yourapplication.model import db db . init_app ( app ) from yourapplication.views.admin import admin from yourapplication.views.frontend import frontend app . register_blueprint ( admin ) app . register_blueprint ( frontend ) return app The downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use :data: ~flask.current_app :: from flask import current_app , Blueprint , render_template admin = Blueprint ( 'admin' , __name__ , url_prefix = '/admin' ) @admin.route ( '/' ) def index (): return render_template ( current_app . config [ 'INDEX_TEMPLATE' ]) Here we look up the name of a template in the config.","title":"Basic Factories"},{"location":"patterns/appfactories/#factories-extensions","text":"It's preferable to create your extensions and app factories so that the extension object does not initially get bound to the application. Using Flask-SQLAlchemy <http://flask-sqlalchemy.pocoo.org/> _, as an example, you should not do something along those lines:: def create_app(config_filename): app = Flask(__name__) app.config.from_pyfile(config_filename) db = SQLAlchemy(app) But, rather, in model.py (or equivalent):: db = SQLAlchemy() and in your application.py (or equivalent):: def create_app ( config_filename ): app = Flask ( __name__ ) app . config . from_pyfile ( config_filename ) from yourapplication.model import db db . init_app ( app ) Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to :doc: /extensiondev .","title":"Factories &amp; Extensions"},{"location":"patterns/appfactories/#using-applications","text":"To run such an application, you can use the :command: flask command:: $ export FLASK_APP = myapp $ flask run Flask will automatically detect the factory ( create_app or make_app ) in myapp . You can also pass arguments to the factory like this:: $ export FLASK_APP = \"myapp:create_app('dev')\" $ flask run Then the create_app factory in myapp is called with the string 'dev' as the argument. See :doc: /cli for more detail.","title":"Using Applications"},{"location":"patterns/appfactories/#factory-improvements","text":"The factory function above is not very clever, but you can improve it. The following changes are straightforward to implement: Make it possible to pass in configuration values for unit tests so that you don't have to create config files on the filesystem. Call a function from a blueprint when the application is setting up so that you have a place to modify attributes of the application (like hooking in before/after request handlers etc.) Add in WSGI middlewares when the application is being created if necessary.","title":"Factory Improvements"},{"location":"patterns/caching/","text":".. _caching-pattern: Caching \u00b6 When your application runs slow, throw some caches in. Well, at least it's the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time. Flask itself does not provide caching for you, but Flask-Caching _, an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend. .. _Flask-Caching: https://flask-caching.readthedocs.io/en/latest/","title":"Caching"},{"location":"patterns/caching/#caching","text":"When your application runs slow, throw some caches in. Well, at least it's the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time. Flask itself does not provide caching for you, but Flask-Caching _, an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend. .. _Flask-Caching: https://flask-caching.readthedocs.io/en/latest/","title":"Caching"},{"location":"patterns/celery/","text":"Celery Background Tasks \u00b6 If your application has a long running task, such as processing some uploaded data or sending email, you don't want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately. Celery is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask, but assumes you've already read the First Steps with Celery <https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html> _ guide in the Celery documentation. Install \u00b6 Celery is a separate Python package. Install it from PyPI using pip:: $ pip install celery Configure \u00b6 The first thing you need is a Celery instance, this is called the celery application. It serves the same purpose as the :class: ~flask.Flask object in Flask, just for Celery. Since this instance is used as the entry-point for everything you want to do in Celery, like creating tasks and managing workers, it must be possible for other modules to import it. For instance you can place this in a tasks module. While you can use Celery without any reconfiguration with Flask, it becomes a bit nicer by subclassing tasks and adding support for Flask's application contexts and hooking it up with the Flask configuration. This is all that is necessary to properly integrate Celery with Flask:: from celery import Celery def make_celery ( app ): celery = Celery ( app . import_name , backend = app . config [ 'CELERY_RESULT_BACKEND' ], broker = app . config [ 'CELERY_BROKER_URL' ] ) celery . conf . update ( app . config ) class ContextTask ( celery . Task ): def __call__ ( self , * args , ** kwargs ): with app . app_context (): return self . run ( * args , ** kwargs ) celery . Task = ContextTask return celery The function creates a new Celery object, configures it with the broker from the application config, updates the rest of the Celery config from the Flask config and then creates a subclass of the task that wraps the task execution in an application context. An example task \u00b6 Let's write a task that adds two numbers together and returns the result. We configure Celery's broker and backend to use Redis, create a celery application using the factor from above, and then use it to define the task. :: from flask import Flask flask_app = Flask ( __name__ ) flask_app . config . update ( CELERY_BROKER_URL = 'redis://localhost:6379' , CELERY_RESULT_BACKEND = 'redis://localhost:6379' ) celery = make_celery ( flask_app ) @celery.task () def add_together ( a , b ): return a + b This task can now be called in the background:: result = add_together.delay(23, 42) result.wait() # 65 Run a worker \u00b6 If you jumped in and already executed the above code you will be disappointed to learn that .wait() will never actually return. That's because you also need to run a Celery worker to receive and execute the task. :: $ celery -A your_application.celery worker The your_application string has to point to your application's package or module that creates the celery object. Now that the worker is running, wait will return the result once the task is finished.","title":"Celery Background Tasks"},{"location":"patterns/celery/#celery-background-tasks","text":"If your application has a long running task, such as processing some uploaded data or sending email, you don't want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately. Celery is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask, but assumes you've already read the First Steps with Celery <https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html> _ guide in the Celery documentation.","title":"Celery Background Tasks"},{"location":"patterns/celery/#install","text":"Celery is a separate Python package. Install it from PyPI using pip:: $ pip install celery","title":"Install"},{"location":"patterns/celery/#configure","text":"The first thing you need is a Celery instance, this is called the celery application. It serves the same purpose as the :class: ~flask.Flask object in Flask, just for Celery. Since this instance is used as the entry-point for everything you want to do in Celery, like creating tasks and managing workers, it must be possible for other modules to import it. For instance you can place this in a tasks module. While you can use Celery without any reconfiguration with Flask, it becomes a bit nicer by subclassing tasks and adding support for Flask's application contexts and hooking it up with the Flask configuration. This is all that is necessary to properly integrate Celery with Flask:: from celery import Celery def make_celery ( app ): celery = Celery ( app . import_name , backend = app . config [ 'CELERY_RESULT_BACKEND' ], broker = app . config [ 'CELERY_BROKER_URL' ] ) celery . conf . update ( app . config ) class ContextTask ( celery . Task ): def __call__ ( self , * args , ** kwargs ): with app . app_context (): return self . run ( * args , ** kwargs ) celery . Task = ContextTask return celery The function creates a new Celery object, configures it with the broker from the application config, updates the rest of the Celery config from the Flask config and then creates a subclass of the task that wraps the task execution in an application context.","title":"Configure"},{"location":"patterns/celery/#an-example-task","text":"Let's write a task that adds two numbers together and returns the result. We configure Celery's broker and backend to use Redis, create a celery application using the factor from above, and then use it to define the task. :: from flask import Flask flask_app = Flask ( __name__ ) flask_app . config . update ( CELERY_BROKER_URL = 'redis://localhost:6379' , CELERY_RESULT_BACKEND = 'redis://localhost:6379' ) celery = make_celery ( flask_app ) @celery.task () def add_together ( a , b ): return a + b This task can now be called in the background:: result = add_together.delay(23, 42) result.wait() # 65","title":"An example task"},{"location":"patterns/celery/#run-a-worker","text":"If you jumped in and already executed the above code you will be disappointed to learn that .wait() will never actually return. That's because you also need to run a Celery worker to receive and execute the task. :: $ celery -A your_application.celery worker The your_application string has to point to your application's package or module that creates the celery object. Now that the worker is running, wait will return the result once the task is finished.","title":"Run a worker"},{"location":"patterns/deferredcallbacks/","text":".. _deferred-callbacks: Deferred Request Callbacks \u00b6 One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system. What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a :meth: ~flask.Flask.before_request callback that wants to set a cookie on the response object. One way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a :meth: ~flask.Flask.after_request callback instead. However, sometimes moving code there makes it more more complicated or awkward to reason about. As an alternative, you can use :func: ~flask.after_this_request to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request. At any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a :meth: ~flask.Flask.before_request callback:: from flask import request , after_this_request @app.before_request def detect_user_language (): language = request . cookies . get ( 'user_lang' ) if language is None : language = guess_language_from_request () # when the response exists, set a cookie with the language @after_this_request def remember_language ( response ): response . set_cookie ( 'user_lang' , language ) return response g . language = language","title":"Deferredcallbacks"},{"location":"patterns/deferredcallbacks/#deferred-request-callbacks","text":"One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system. What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a :meth: ~flask.Flask.before_request callback that wants to set a cookie on the response object. One way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a :meth: ~flask.Flask.after_request callback instead. However, sometimes moving code there makes it more more complicated or awkward to reason about. As an alternative, you can use :func: ~flask.after_this_request to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request. At any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a :meth: ~flask.Flask.before_request callback:: from flask import request , after_this_request @app.before_request def detect_user_language (): language = request . cookies . get ( 'user_lang' ) if language is None : language = guess_language_from_request () # when the response exists, set a cookie with the language @after_this_request def remember_language ( response ): response . set_cookie ( 'user_lang' , language ) return response g . language = language","title":"Deferred Request Callbacks"},{"location":"patterns/distribute/","text":".. _distribute-deployment: Deploying with Setuptools \u00b6 Setuptools _, is an extension library that is commonly used to distribute Python libraries and extensions. It extends distutils, a basic module installation system shipped with Python to also support various more complex constructs that make larger applications easier to distribute: support for dependencies : a library or application can declare a list of other libraries it depends on which will be installed automatically for you. package registry : setuptools registers your package with your Python installation. This makes it possible to query information provided by one package from another package. The best known feature of this system is the entry point support which allows one package to declare an \"entry point\" that another package can hook into to extend the other package. installation manager : :command: pip can install other libraries for you. If you have Python 2 (>=2.7.9) or Python 3 (>=3.4) installed from python.org, you will already have pip and setuptools on your system. Otherwise, you will need to install them yourself. Flask itself, and all the libraries you can find on PyPI are distributed with either setuptools or distutils. In this case we assume your application is called :file: yourapplication.py and you are not using a module, but a :ref: package <larger-applications> . If you have not yet converted your application into a package, head over to the :ref: larger-applications pattern to see how this can be done. A working deployment with setuptools is the first step into more complex and more automated deployment scenarios. If you want to fully automate the process, also read the :ref: fabric-deployment chapter. Basic Setup Script \u00b6 Because you have Flask installed, you have setuptools available on your system. Flask already depends upon setuptools. Standard disclaimer applies: :ref: you better use a virtualenv <virtualenv> . Your setup code always goes into a file named :file: setup.py next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it. A basic :file: setup.py file for a Flask application looks like this:: from setuptools import setup setup ( name = 'Your Application' , version = '1.0' , long_description = __doc__ , packages = [ 'yourapplication' ], include_package_data = True , zip_safe = False , install_requires = [ 'Flask' ] ) Please keep in mind that you have to list subpackages explicitly. If you want setuptools to lookup the packages for you automatically, you can use the find_packages function:: from setuptools import setup , find_packages setup ( ... packages = find_packages () ) Most parameters to the setup function should be self explanatory, include_package_data and zip_safe might not be. include_package_data tells setuptools to look for a :file: MANIFEST.in file and install all the entries that match as package data. We will use this to distribute the static files and templates along with the Python module (see :ref: distributing-resources ). The zip_safe flag can be used to force or prevent zip Archive creation. In general you probably don't want your packages to be installed as zip files because some tools do not support them and they make debugging a lot harder. Tagging Builds \u00b6 It is useful to distinguish between release and development builds. Add a :file: setup.cfg file to configure these options. :: [egg_info] tag_build = .dev tag_date = 1 [aliases] release = egg_info -Db '' Running python setup.py sdist will create a development package with \".dev\" and the current date appended: flaskr-1.0.dev20160314.tar.gz . Running python setup.py release sdist will create a release package with only the version: flaskr-1.0.tar.gz . .. _distributing-resources: Distributing Resources \u00b6 If you try to install the package you just created, you will notice that folders like :file: static or :file: templates are not installed for you. The reason for this is that setuptools does not know which files to add for you. What you should do, is to create a :file: MANIFEST.in file next to your :file: setup.py file. This file lists all the files that should be added to your tarball:: recursive-include yourapplication/templates * recursive-include yourapplication/static * Don't forget that even if you enlist them in your :file: MANIFEST.in file, they won't be installed for you unless you set the include_package_data parameter of the setup function to True ! Declaring Dependencies \u00b6 Dependencies are declared in the install_requires parameter as a list. Each item in that list is the name of a package that should be pulled from PyPI on installation. By default it will always use the most recent version, but you can also provide minimum and maximum version requirements. Here some examples:: install_requires=[ 'Flask&gt;=0.2', 'SQLAlchemy&gt;=0.6', 'BrokenPackage&gt;=0.7,&lt;=1.0' ] As mentioned earlier, dependencies are pulled from PyPI. What if you want to depend on a package that cannot be found on PyPI and won't be because it is an internal package you don't want to share with anyone? Just do it as if there was a PyPI entry and provide a list of alternative locations where setuptools should look for tarballs:: dependency_links=['http://example.com/yourfiles'] Make sure that page has a directory listing and the links on the page are pointing to the actual tarballs with their correct filenames as this is how setuptools will find the files. If you have an internal company server that contains the packages, provide the URL to that server. Installing / Developing \u00b6 To install your application (ideally into a virtualenv) just run the :file: setup.py script with the install parameter. It will install your application into the virtualenv's site-packages folder and also download and install all dependencies:: $ python setup.py install If you are developing on the package and also want the requirements to be installed, you can use the develop command instead:: $ python setup.py develop This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run install again after each change. .. _pip: https://pypi.org/project/pip/ .. _Setuptools: https://pypi.org/project/setuptools/","title":"Distribute"},{"location":"patterns/distribute/#deploying-with-setuptools","text":"Setuptools _, is an extension library that is commonly used to distribute Python libraries and extensions. It extends distutils, a basic module installation system shipped with Python to also support various more complex constructs that make larger applications easier to distribute: support for dependencies : a library or application can declare a list of other libraries it depends on which will be installed automatically for you. package registry : setuptools registers your package with your Python installation. This makes it possible to query information provided by one package from another package. The best known feature of this system is the entry point support which allows one package to declare an \"entry point\" that another package can hook into to extend the other package. installation manager : :command: pip can install other libraries for you. If you have Python 2 (>=2.7.9) or Python 3 (>=3.4) installed from python.org, you will already have pip and setuptools on your system. Otherwise, you will need to install them yourself. Flask itself, and all the libraries you can find on PyPI are distributed with either setuptools or distutils. In this case we assume your application is called :file: yourapplication.py and you are not using a module, but a :ref: package <larger-applications> . If you have not yet converted your application into a package, head over to the :ref: larger-applications pattern to see how this can be done. A working deployment with setuptools is the first step into more complex and more automated deployment scenarios. If you want to fully automate the process, also read the :ref: fabric-deployment chapter.","title":"Deploying with Setuptools"},{"location":"patterns/distribute/#basic-setup-script","text":"Because you have Flask installed, you have setuptools available on your system. Flask already depends upon setuptools. Standard disclaimer applies: :ref: you better use a virtualenv <virtualenv> . Your setup code always goes into a file named :file: setup.py next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it. A basic :file: setup.py file for a Flask application looks like this:: from setuptools import setup setup ( name = 'Your Application' , version = '1.0' , long_description = __doc__ , packages = [ 'yourapplication' ], include_package_data = True , zip_safe = False , install_requires = [ 'Flask' ] ) Please keep in mind that you have to list subpackages explicitly. If you want setuptools to lookup the packages for you automatically, you can use the find_packages function:: from setuptools import setup , find_packages setup ( ... packages = find_packages () ) Most parameters to the setup function should be self explanatory, include_package_data and zip_safe might not be. include_package_data tells setuptools to look for a :file: MANIFEST.in file and install all the entries that match as package data. We will use this to distribute the static files and templates along with the Python module (see :ref: distributing-resources ). The zip_safe flag can be used to force or prevent zip Archive creation. In general you probably don't want your packages to be installed as zip files because some tools do not support them and they make debugging a lot harder.","title":"Basic Setup Script"},{"location":"patterns/distribute/#tagging-builds","text":"It is useful to distinguish between release and development builds. Add a :file: setup.cfg file to configure these options. :: [egg_info] tag_build = .dev tag_date = 1 [aliases] release = egg_info -Db '' Running python setup.py sdist will create a development package with \".dev\" and the current date appended: flaskr-1.0.dev20160314.tar.gz . Running python setup.py release sdist will create a release package with only the version: flaskr-1.0.tar.gz . .. _distributing-resources:","title":"Tagging Builds"},{"location":"patterns/distribute/#distributing-resources","text":"If you try to install the package you just created, you will notice that folders like :file: static or :file: templates are not installed for you. The reason for this is that setuptools does not know which files to add for you. What you should do, is to create a :file: MANIFEST.in file next to your :file: setup.py file. This file lists all the files that should be added to your tarball:: recursive-include yourapplication/templates * recursive-include yourapplication/static * Don't forget that even if you enlist them in your :file: MANIFEST.in file, they won't be installed for you unless you set the include_package_data parameter of the setup function to True !","title":"Distributing Resources"},{"location":"patterns/distribute/#declaring-dependencies","text":"Dependencies are declared in the install_requires parameter as a list. Each item in that list is the name of a package that should be pulled from PyPI on installation. By default it will always use the most recent version, but you can also provide minimum and maximum version requirements. Here some examples:: install_requires=[ 'Flask&gt;=0.2', 'SQLAlchemy&gt;=0.6', 'BrokenPackage&gt;=0.7,&lt;=1.0' ] As mentioned earlier, dependencies are pulled from PyPI. What if you want to depend on a package that cannot be found on PyPI and won't be because it is an internal package you don't want to share with anyone? Just do it as if there was a PyPI entry and provide a list of alternative locations where setuptools should look for tarballs:: dependency_links=['http://example.com/yourfiles'] Make sure that page has a directory listing and the links on the page are pointing to the actual tarballs with their correct filenames as this is how setuptools will find the files. If you have an internal company server that contains the packages, provide the URL to that server.","title":"Declaring Dependencies"},{"location":"patterns/distribute/#installing-developing","text":"To install your application (ideally into a virtualenv) just run the :file: setup.py script with the install parameter. It will install your application into the virtualenv's site-packages folder and also download and install all dependencies:: $ python setup.py install If you are developing on the package and also want the requirements to be installed, you can use the develop command instead:: $ python setup.py develop This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run install again after each change. .. _pip: https://pypi.org/project/pip/ .. _Setuptools: https://pypi.org/project/setuptools/","title":"Installing / Developing"},{"location":"patterns/errorpages/","text":".. _errorpages: Custom Error Pages \u00b6 Flask comes with a handy :func: ~flask.abort function that aborts a request with an HTTP error code early. It will also provide a plain black and white error page for you with a basic description, but nothing fancy. Depending on the error code it is less or more likely for the user to actually see such an error. Common Error Codes \u00b6 The following error codes are some that are often displayed to the user, even if the application behaves correctly: 404 Not Found The good old \"chap, you made a mistake typing that URL\" message. So common that even novices to the internet know that 404 means: damn, the thing I was looking for is not there. It's a very good idea to make sure there is actually something useful on a 404 page, at least a link back to the index. 403 Forbidden If you have some kind of access control on your website, you will have to send a 403 code for disallowed resources. So make sure the user is not lost when they try to access a forbidden resource. 410 Gone Did you know that there the \"404 Not Found\" has a brother named \"410 Gone\"? Few people actually implement that, but the idea is that resources that previously existed and got deleted answer with 410 instead of 404. If you are not deleting documents permanently from the database but just mark them as deleted, do the user a favour and use the 410 code instead and display a message that what they were looking for was deleted for all eternity. 500 Internal Server Error Usually happens on programming errors or if the server is overloaded. A terribly good idea is to have a nice page there, because your application will fail sooner or later (see also: :ref: application-errors ). Error Handlers \u00b6 An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a :exc: ~werkzeug.exceptions.HTTPException . An error handler for \"500 Internal Server Error\" will be passed uncaught exceptions in addition to explicit 500 errors. An error handler is registered with the :meth: ~flask.Flask.errorhandler decorator or the :meth: ~flask.Flask.register_error_handler method. A handler can be registered for a status code, like 404, or for an exception class. The status code of the response will not be set to the handler's code. Make sure to provide the appropriate HTTP status code when returning a response from a handler. A handler for \"500 Internal Server Error\" will not be used when running in debug mode. Instead, the interactive debugger will be shown. Here is an example implementation for a \"404 Page Not Found\" exception:: from flask import render_template @app.errorhandler ( 404 ) def page_not_found ( e ): # note that we set the 404 status explicitly return render_template ( '404.html' ), 404 When using the :ref: application factory pattern <app-factories> :: from flask import Flask , render_template def page_not_found ( e ): return render_template ( '404.html' ), 404 def create_app ( config_filename ): app = Flask ( __name__ ) app . register_error_handler ( 404 , page_not_found ) return app An example template might be this: .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block title %} Page Not Found {% endblock %} {% block body %} &lt;h1&gt;Page Not Found&lt;/h1&gt; &lt;p&gt;What you were looking for is just not there. &lt;p&gt;&lt;a href=\" {{ url_for ( 'index' ) }} \"&gt;go somewhere nice&lt;/a&gt; {% endblock %}","title":"Errorpages"},{"location":"patterns/errorpages/#custom-error-pages","text":"Flask comes with a handy :func: ~flask.abort function that aborts a request with an HTTP error code early. It will also provide a plain black and white error page for you with a basic description, but nothing fancy. Depending on the error code it is less or more likely for the user to actually see such an error.","title":"Custom Error Pages"},{"location":"patterns/errorpages/#common-error-codes","text":"The following error codes are some that are often displayed to the user, even if the application behaves correctly: 404 Not Found The good old \"chap, you made a mistake typing that URL\" message. So common that even novices to the internet know that 404 means: damn, the thing I was looking for is not there. It's a very good idea to make sure there is actually something useful on a 404 page, at least a link back to the index. 403 Forbidden If you have some kind of access control on your website, you will have to send a 403 code for disallowed resources. So make sure the user is not lost when they try to access a forbidden resource. 410 Gone Did you know that there the \"404 Not Found\" has a brother named \"410 Gone\"? Few people actually implement that, but the idea is that resources that previously existed and got deleted answer with 410 instead of 404. If you are not deleting documents permanently from the database but just mark them as deleted, do the user a favour and use the 410 code instead and display a message that what they were looking for was deleted for all eternity. 500 Internal Server Error Usually happens on programming errors or if the server is overloaded. A terribly good idea is to have a nice page there, because your application will fail sooner or later (see also: :ref: application-errors ).","title":"Common Error Codes"},{"location":"patterns/errorpages/#error-handlers","text":"An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a :exc: ~werkzeug.exceptions.HTTPException . An error handler for \"500 Internal Server Error\" will be passed uncaught exceptions in addition to explicit 500 errors. An error handler is registered with the :meth: ~flask.Flask.errorhandler decorator or the :meth: ~flask.Flask.register_error_handler method. A handler can be registered for a status code, like 404, or for an exception class. The status code of the response will not be set to the handler's code. Make sure to provide the appropriate HTTP status code when returning a response from a handler. A handler for \"500 Internal Server Error\" will not be used when running in debug mode. Instead, the interactive debugger will be shown. Here is an example implementation for a \"404 Page Not Found\" exception:: from flask import render_template @app.errorhandler ( 404 ) def page_not_found ( e ): # note that we set the 404 status explicitly return render_template ( '404.html' ), 404 When using the :ref: application factory pattern <app-factories> :: from flask import Flask , render_template def page_not_found ( e ): return render_template ( '404.html' ), 404 def create_app ( config_filename ): app = Flask ( __name__ ) app . register_error_handler ( 404 , page_not_found ) return app An example template might be this: .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block title %} Page Not Found {% endblock %} {% block body %} &lt;h1&gt;Page Not Found&lt;/h1&gt; &lt;p&gt;What you were looking for is just not there. &lt;p&gt;&lt;a href=\" {{ url_for ( 'index' ) }} \"&gt;go somewhere nice&lt;/a&gt; {% endblock %}","title":"Error Handlers"},{"location":"patterns/fabric/","text":".. _fabric-deployment: Deploying with Fabric \u00b6 Fabric _ is a tool for Python similar to Makefiles but with the ability to execute commands on a remote server. In combination with a properly set up Python package (:ref: larger-applications ) and a good concept for configurations (:ref: config ) it is very easy to deploy Flask applications to external servers. Before we get started, here a quick checklist of things we have to ensure upfront: Fabric 1.0 has to be installed locally. This tutorial assumes the latest version of Fabric. The application already has to be a package and requires a working :file: setup.py file (:ref: distribute-deployment ). In the following example we are using mod_wsgi for the remote servers. You can of course use your own favourite server there, but for this example we chose Apache + mod_wsgi because it's very easy to setup and has a simple way to reload applications without root access. Creating the first Fabfile \u00b6 A fabfile is what controls what Fabric executes. It is named :file: fabfile.py and executed by the fab command. All the functions defined in that file will show up as fab subcommands. They are executed on one or more hosts. These hosts can be defined either in the fabfile or on the command line. In this case we will add them to the fabfile. This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment:: from fabric.api import * # the user to use for the remote commands env . user = 'appuser' # the servers where the commands are executed env . hosts = [ 'server1.example.com' , 'server2.example.com' ] def pack (): # build the package local ( 'python setup.py sdist --formats=gztar' , capture = False ) def deploy (): # figure out the package name and version dist = local ( 'python setup.py --fullname' , capture = True ) . strip () filename = ' %s .tar.gz' % dist # upload the package to the temporary folder on the server put ( 'dist/ %s ' % filename , '/tmp/ %s ' % filename ) # install the package in the application's virtualenv with pip run ( '/var/www/yourapplication/env/bin/pip install /tmp/ %s ' % filename ) # remove the uploaded package run ( 'rm -r /tmp/ %s ' % filename ) # touch the .wsgi file to trigger a reload in mod_wsgi run ( 'touch /var/www/yourapplication.wsgi' ) Running Fabfiles \u00b6 Now how do you execute that fabfile? You use the fab command. To deploy the current version of the code on the remote server you would use this command:: $ fab pack deploy However this requires that our server already has the :file: /var/www/yourapplication folder created and :file: /var/www/yourapplication/env to be a virtual environment. Furthermore are we not creating the configuration or .wsgi file on the server. So how do we bootstrap a new server into our infrastructure? This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it setup or bootstrap and then pass the servername explicitly on the command line:: $ fab -H newserver.example.com bootstrap To setup a new server you would roughly do these steps: Create the directory structure in :file: /var/www :: $ mkdir /var/www/yourapplication $ cd /var/www/yourapplication $ virtualenv --distribute env Upload a new :file: application.wsgi file to the server and the configuration file for the application (eg: :file: application.cfg ) Create a new Apache config for yourapplication and activate it. Make sure to activate watching for changes of the .wsgi file so that we can automatically reload the application by touching it. (See :ref: mod_wsgi-deployment for more information) So now the question is, where do the :file: application.wsgi and :file: application.cfg files come from? The WSGI File \u00b6 The WSGI file has to import the application and also to set an environment variable so that the application knows where to look for the config. This is a short example that does exactly that:: import os os . environ [ 'YOURAPPLICATION_CONFIG' ] = '/var/www/yourapplication/application.cfg' from yourapplication import app The application itself then has to initialize itself like this to look for the config at that environment variable:: app = Flask(__name__) app.config.from_object('yourapplication.default_config') app.config.from_envvar('YOURAPPLICATION_CONFIG') This approach is explained in detail in the :ref: config section of the documentation. The Configuration File \u00b6 Now as mentioned above, the application will find the correct configuration file by looking up the YOURAPPLICATION_CONFIG environment variable. So we have to put the configuration in a place where the application will able to find it. Configuration files have the unfriendly quality of being different on all computers, so you do not version them usually. A popular approach is to store configuration files for different servers in a separate version control repository and check them out on all servers. Then symlink the file that is active for the server into the location where it's expected (eg: :file: /var/www/yourapplication ). Either way, in our case here we only expect one or two servers and we can upload them ahead of time by hand. First Deployment \u00b6 Now we can do our first deployment. We have set up the servers so that they have their virtual environments and activated apache configs. Now we can pack up the application and deploy it:: $ fab pack deploy Fabric will now connect to all servers and run the commands as written down in the fabfile. First it will execute pack so that we have our tarball ready and then it will execute deploy and upload the source code to all servers and install it there. Thanks to the :file: setup.py file we will automatically pull in the required libraries into our virtual environment. Next Steps \u00b6 From that point onwards there is so much that can be done to make deployment actually fun: Create a bootstrap command that initializes new servers. It could initialize a new virtual environment, setup apache appropriately etc. Put configuration files into a separate version control repository and symlink the active configs into place. You could also put your application code into a repository and check out the latest version on the server and then install. That way you can also easily go back to older versions. hook in testing functionality so that you can deploy to an external server and run the test suite. Working with Fabric is fun and you will notice that it's quite magical to type fab deploy and see your application being deployed automatically to one or more remote servers. .. _Fabric: https://www.fabfile.org/","title":"Fabric"},{"location":"patterns/fabric/#deploying-with-fabric","text":"Fabric _ is a tool for Python similar to Makefiles but with the ability to execute commands on a remote server. In combination with a properly set up Python package (:ref: larger-applications ) and a good concept for configurations (:ref: config ) it is very easy to deploy Flask applications to external servers. Before we get started, here a quick checklist of things we have to ensure upfront: Fabric 1.0 has to be installed locally. This tutorial assumes the latest version of Fabric. The application already has to be a package and requires a working :file: setup.py file (:ref: distribute-deployment ). In the following example we are using mod_wsgi for the remote servers. You can of course use your own favourite server there, but for this example we chose Apache + mod_wsgi because it's very easy to setup and has a simple way to reload applications without root access.","title":"Deploying with Fabric"},{"location":"patterns/fabric/#creating-the-first-fabfile","text":"A fabfile is what controls what Fabric executes. It is named :file: fabfile.py and executed by the fab command. All the functions defined in that file will show up as fab subcommands. They are executed on one or more hosts. These hosts can be defined either in the fabfile or on the command line. In this case we will add them to the fabfile. This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment:: from fabric.api import * # the user to use for the remote commands env . user = 'appuser' # the servers where the commands are executed env . hosts = [ 'server1.example.com' , 'server2.example.com' ] def pack (): # build the package local ( 'python setup.py sdist --formats=gztar' , capture = False ) def deploy (): # figure out the package name and version dist = local ( 'python setup.py --fullname' , capture = True ) . strip () filename = ' %s .tar.gz' % dist # upload the package to the temporary folder on the server put ( 'dist/ %s ' % filename , '/tmp/ %s ' % filename ) # install the package in the application's virtualenv with pip run ( '/var/www/yourapplication/env/bin/pip install /tmp/ %s ' % filename ) # remove the uploaded package run ( 'rm -r /tmp/ %s ' % filename ) # touch the .wsgi file to trigger a reload in mod_wsgi run ( 'touch /var/www/yourapplication.wsgi' )","title":"Creating the first Fabfile"},{"location":"patterns/fabric/#running-fabfiles","text":"Now how do you execute that fabfile? You use the fab command. To deploy the current version of the code on the remote server you would use this command:: $ fab pack deploy However this requires that our server already has the :file: /var/www/yourapplication folder created and :file: /var/www/yourapplication/env to be a virtual environment. Furthermore are we not creating the configuration or .wsgi file on the server. So how do we bootstrap a new server into our infrastructure? This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it setup or bootstrap and then pass the servername explicitly on the command line:: $ fab -H newserver.example.com bootstrap To setup a new server you would roughly do these steps: Create the directory structure in :file: /var/www :: $ mkdir /var/www/yourapplication $ cd /var/www/yourapplication $ virtualenv --distribute env Upload a new :file: application.wsgi file to the server and the configuration file for the application (eg: :file: application.cfg ) Create a new Apache config for yourapplication and activate it. Make sure to activate watching for changes of the .wsgi file so that we can automatically reload the application by touching it. (See :ref: mod_wsgi-deployment for more information) So now the question is, where do the :file: application.wsgi and :file: application.cfg files come from?","title":"Running Fabfiles"},{"location":"patterns/fabric/#the-wsgi-file","text":"The WSGI file has to import the application and also to set an environment variable so that the application knows where to look for the config. This is a short example that does exactly that:: import os os . environ [ 'YOURAPPLICATION_CONFIG' ] = '/var/www/yourapplication/application.cfg' from yourapplication import app The application itself then has to initialize itself like this to look for the config at that environment variable:: app = Flask(__name__) app.config.from_object('yourapplication.default_config') app.config.from_envvar('YOURAPPLICATION_CONFIG') This approach is explained in detail in the :ref: config section of the documentation.","title":"The WSGI File"},{"location":"patterns/fabric/#the-configuration-file","text":"Now as mentioned above, the application will find the correct configuration file by looking up the YOURAPPLICATION_CONFIG environment variable. So we have to put the configuration in a place where the application will able to find it. Configuration files have the unfriendly quality of being different on all computers, so you do not version them usually. A popular approach is to store configuration files for different servers in a separate version control repository and check them out on all servers. Then symlink the file that is active for the server into the location where it's expected (eg: :file: /var/www/yourapplication ). Either way, in our case here we only expect one or two servers and we can upload them ahead of time by hand.","title":"The Configuration File"},{"location":"patterns/fabric/#first-deployment","text":"Now we can do our first deployment. We have set up the servers so that they have their virtual environments and activated apache configs. Now we can pack up the application and deploy it:: $ fab pack deploy Fabric will now connect to all servers and run the commands as written down in the fabfile. First it will execute pack so that we have our tarball ready and then it will execute deploy and upload the source code to all servers and install it there. Thanks to the :file: setup.py file we will automatically pull in the required libraries into our virtual environment.","title":"First Deployment"},{"location":"patterns/fabric/#next-steps","text":"From that point onwards there is so much that can be done to make deployment actually fun: Create a bootstrap command that initializes new servers. It could initialize a new virtual environment, setup apache appropriately etc. Put configuration files into a separate version control repository and symlink the active configs into place. You could also put your application code into a repository and check out the latest version on the server and then install. That way you can also easily go back to older versions. hook in testing functionality so that you can deploy to an external server and run the test suite. Working with Fabric is fun and you will notice that it's quite magical to type fab deploy and see your application being deployed automatically to one or more remote servers. .. _Fabric: https://www.fabfile.org/","title":"Next Steps"},{"location":"patterns/favicon/","text":"Adding a favicon \u00b6 A \"favicon\" is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand. A common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 \u00d7 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as :file: favicon.ico . Now, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example: .. sourcecode:: html+jinja &lt;link rel=\"shortcut icon\" href=\" {{ url_for ( 'static' , filename = 'favicon.ico' ) }} \"&gt; That's all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can't do that you're out of luck. If however your application is the root you can simply route a redirect:: app.add_url_rule('/favicon.ico', redirect_to=url_for('static', filename='favicon.ico')) If you want to save the extra redirect request you can also write a view using :func: ~flask.send_from_directory :: import os from flask import send_from_directory @app.route ( '/favicon.ico' ) def favicon (): return send_from_directory ( os . path . join ( app . root_path , 'static' ), 'favicon.ico' , mimetype = 'image/vnd.microsoft.icon' ) We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same. The above will serve the icon via your application and if possible it's better to configure your dedicated web server to serve it; refer to the web server's documentation. See also \u00b6 The Favicon <https://en.wikipedia.org/wiki/Favicon> _ article on Wikipedia","title":"Adding a favicon"},{"location":"patterns/favicon/#adding-a-favicon","text":"A \"favicon\" is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand. A common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 \u00d7 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as :file: favicon.ico . Now, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example: .. sourcecode:: html+jinja &lt;link rel=\"shortcut icon\" href=\" {{ url_for ( 'static' , filename = 'favicon.ico' ) }} \"&gt; That's all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can't do that you're out of luck. If however your application is the root you can simply route a redirect:: app.add_url_rule('/favicon.ico', redirect_to=url_for('static', filename='favicon.ico')) If you want to save the extra redirect request you can also write a view using :func: ~flask.send_from_directory :: import os from flask import send_from_directory @app.route ( '/favicon.ico' ) def favicon (): return send_from_directory ( os . path . join ( app . root_path , 'static' ), 'favicon.ico' , mimetype = 'image/vnd.microsoft.icon' ) We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same. The above will serve the icon via your application and if possible it's better to configure your dedicated web server to serve it; refer to the web server's documentation.","title":"Adding a favicon"},{"location":"patterns/favicon/#see-also","text":"The Favicon <https://en.wikipedia.org/wiki/Favicon> _ article on Wikipedia","title":"See also"},{"location":"patterns/fileuploads/","text":".. _uploading-files: Uploading Files \u00b6 Ah yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this: A <form> tag is marked with enctype=multipart/form-data and an <input type=file> is placed in that form. The application accesses the file from the :attr: ~flask.request.files dictionary on the request object. use the :meth: ~werkzeug.datastructures.FileStorage.save method of the file to save the file permanently somewhere on the filesystem. A Gentle Introduction \u00b6 Let's start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let's look at the bootstrapping code for our application:: import os from flask import Flask , flash , request , redirect , url_for from werkzeug.utils import secure_filename UPLOAD_FOLDER = '/path/to/the/uploads' ALLOWED_EXTENSIONS = { 'txt' , 'pdf' , 'png' , 'jpg' , 'jpeg' , 'gif' } app = Flask ( __name__ ) app . config [ 'UPLOAD_FOLDER' ] = UPLOAD_FOLDER So first we need a couple of imports. Most should be straightforward, the :func: werkzeug.secure_filename is explained a little bit later. The UPLOAD_FOLDER is where we will store the uploaded files and the ALLOWED_EXTENSIONS is the set of allowed file extensions. Why do we limit the extensions that are allowed? You probably don't want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see :ref: xss ). Also make sure to disallow .php files if the server executes them, but who has PHP installed on their server, right? :) Next the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file:: def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS @app.route('/', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': # check if the post request has the file part if 'file' not in request.files: flash('No file part') return redirect(request.url) file = request.files['file'] # if user does not select file, browser also # submit an empty part without filename if file.filename == '': flash('No selected file') return redirect(request.url) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return redirect(url_for('uploaded_file', filename=filename)) return ''' &lt;!doctype html&gt; &lt;title&gt;Upload new File&lt;/title&gt; &lt;h1&gt;Upload new File&lt;/h1&gt; &lt;form method=post enctype=multipart/form-data&gt; &lt;input type=file name=file&gt; &lt;input type=submit value=Upload&gt; &lt;/form&gt; ''' So what does that :func: ~werkzeug.utils.secure_filename function actually do? Now the problem is that there is that principle called \"never trust user input\". This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem. .. admonition:: Information for the Pros So you're interested in what that :func: ~werkzeug.utils.secure_filename function does and what the problem is if you're not using it? So just imagine someone would send the following information as filename to your application:: filename = \"../../../../home/username/.bashrc\" Assuming the number of ../ is correct and you would join this with the UPLOAD_FOLDER the user might have the ability to modify a file on the server's filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :) Now let's look how that function works: secure filename('../../../../home/username/.bashrc') 'home_username .bashrc' Now one last thing is missing: the serving of the uploaded files. In the :func: upload_file() we redirect the user to url_for('uploaded_file', filename=filename) , that is, /uploads/filename . So we write the :func: uploaded_file function to return the file of that name. As of Flask 0.5 we can use a function that does that for us:: from flask import send_from_directory @app.route ( '/uploads/&lt;filename&gt;' ) def uploaded_file ( filename ): return send_from_directory ( app . config [ 'UPLOAD_FOLDER' ], filename ) Alternatively you can register uploaded_file as build_only rule and use the :class: ~werkzeug.wsgi.SharedDataMiddleware . This also works with older versions of Flask:: from werkzeug import SharedDataMiddleware app . add_url_rule ( '/uploads/&lt;filename&gt;' , 'uploaded_file' , build_only = True ) app . wsgi_app = SharedDataMiddleware ( app . wsgi_app , { '/uploads' : app . config [ 'UPLOAD_FOLDER' ] }) If you now run the application everything should work as expected. Improving Uploads \u00b6 .. versionadded:: 0.6 So how exactly does Flask handle uploads? Well it will store them in the webserver's memory if the files are reasonable small otherwise in a temporary location (as returned by :func: tempfile.gettempdir ). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads to an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:: from flask import Flask , Request app = Flask ( __name__ ) app . config [ 'MAX_CONTENT_LENGTH' ] = 16 * 1024 * 1024 The code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a :exc: ~werkzeug.exceptions.RequestEntityTooLarge exception. .. admonition:: Connection Reset Issue When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server. This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling. Upload Progress Bars \u00b6 A while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. Long story short: the client asks the server every 5 seconds how much it has transmitted already. Do you realize the irony? The client is asking for something it should already know. An Easier Solution \u00b6 Now there are better solutions that work faster and are more reliable. There are JavaScript libraries like jQuery_ that have form plugins to ease the construction of progress bar. Because the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there is also a Flask extension called Flask-Uploads _ that implements a full fledged upload mechanism with white and blacklisting of extensions and more. .. _jQuery: https://jquery.com/ .. _Flask-Uploads: https://pythonhosted.org/Flask-Uploads/","title":"Fileuploads"},{"location":"patterns/fileuploads/#uploading-files","text":"Ah yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this: A <form> tag is marked with enctype=multipart/form-data and an <input type=file> is placed in that form. The application accesses the file from the :attr: ~flask.request.files dictionary on the request object. use the :meth: ~werkzeug.datastructures.FileStorage.save method of the file to save the file permanently somewhere on the filesystem.","title":"Uploading Files"},{"location":"patterns/fileuploads/#a-gentle-introduction","text":"Let's start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let's look at the bootstrapping code for our application:: import os from flask import Flask , flash , request , redirect , url_for from werkzeug.utils import secure_filename UPLOAD_FOLDER = '/path/to/the/uploads' ALLOWED_EXTENSIONS = { 'txt' , 'pdf' , 'png' , 'jpg' , 'jpeg' , 'gif' } app = Flask ( __name__ ) app . config [ 'UPLOAD_FOLDER' ] = UPLOAD_FOLDER So first we need a couple of imports. Most should be straightforward, the :func: werkzeug.secure_filename is explained a little bit later. The UPLOAD_FOLDER is where we will store the uploaded files and the ALLOWED_EXTENSIONS is the set of allowed file extensions. Why do we limit the extensions that are allowed? You probably don't want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see :ref: xss ). Also make sure to disallow .php files if the server executes them, but who has PHP installed on their server, right? :) Next the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file:: def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS @app.route('/', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': # check if the post request has the file part if 'file' not in request.files: flash('No file part') return redirect(request.url) file = request.files['file'] # if user does not select file, browser also # submit an empty part without filename if file.filename == '': flash('No selected file') return redirect(request.url) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return redirect(url_for('uploaded_file', filename=filename)) return ''' &lt;!doctype html&gt; &lt;title&gt;Upload new File&lt;/title&gt; &lt;h1&gt;Upload new File&lt;/h1&gt; &lt;form method=post enctype=multipart/form-data&gt; &lt;input type=file name=file&gt; &lt;input type=submit value=Upload&gt; &lt;/form&gt; ''' So what does that :func: ~werkzeug.utils.secure_filename function actually do? Now the problem is that there is that principle called \"never trust user input\". This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem. .. admonition:: Information for the Pros So you're interested in what that :func: ~werkzeug.utils.secure_filename function does and what the problem is if you're not using it? So just imagine someone would send the following information as filename to your application:: filename = \"../../../../home/username/.bashrc\" Assuming the number of ../ is correct and you would join this with the UPLOAD_FOLDER the user might have the ability to modify a file on the server's filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :) Now let's look how that function works: secure filename('../../../../home/username/.bashrc') 'home_username .bashrc' Now one last thing is missing: the serving of the uploaded files. In the :func: upload_file() we redirect the user to url_for('uploaded_file', filename=filename) , that is, /uploads/filename . So we write the :func: uploaded_file function to return the file of that name. As of Flask 0.5 we can use a function that does that for us:: from flask import send_from_directory @app.route ( '/uploads/&lt;filename&gt;' ) def uploaded_file ( filename ): return send_from_directory ( app . config [ 'UPLOAD_FOLDER' ], filename ) Alternatively you can register uploaded_file as build_only rule and use the :class: ~werkzeug.wsgi.SharedDataMiddleware . This also works with older versions of Flask:: from werkzeug import SharedDataMiddleware app . add_url_rule ( '/uploads/&lt;filename&gt;' , 'uploaded_file' , build_only = True ) app . wsgi_app = SharedDataMiddleware ( app . wsgi_app , { '/uploads' : app . config [ 'UPLOAD_FOLDER' ] }) If you now run the application everything should work as expected.","title":"A Gentle Introduction"},{"location":"patterns/fileuploads/#improving-uploads","text":".. versionadded:: 0.6 So how exactly does Flask handle uploads? Well it will store them in the webserver's memory if the files are reasonable small otherwise in a temporary location (as returned by :func: tempfile.gettempdir ). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads to an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:: from flask import Flask , Request app = Flask ( __name__ ) app . config [ 'MAX_CONTENT_LENGTH' ] = 16 * 1024 * 1024 The code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a :exc: ~werkzeug.exceptions.RequestEntityTooLarge exception. .. admonition:: Connection Reset Issue When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server. This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling.","title":"Improving Uploads"},{"location":"patterns/fileuploads/#upload-progress-bars","text":"A while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. Long story short: the client asks the server every 5 seconds how much it has transmitted already. Do you realize the irony? The client is asking for something it should already know.","title":"Upload Progress Bars"},{"location":"patterns/fileuploads/#an-easier-solution","text":"Now there are better solutions that work faster and are more reliable. There are JavaScript libraries like jQuery_ that have form plugins to ease the construction of progress bar. Because the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there is also a Flask extension called Flask-Uploads _ that implements a full fledged upload mechanism with white and blacklisting of extensions and more. .. _jQuery: https://jquery.com/ .. _Flask-Uploads: https://pythonhosted.org/Flask-Uploads/","title":"An Easier Solution"},{"location":"patterns/flashing/","text":".. _message-flashing-pattern: Message Flashing \u00b6 Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently. Simple Flashing \u00b6 So here is a full example:: from flask import Flask , flash , redirect , render_template , \\ request , url_for app = Flask ( __name__ ) app . secret_key = b '_5#y2L\"F4Q8z \\n\\xec ]/' @app.route ( '/' ) def index (): return render_template ( 'index.html' ) @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): error = None if request . method == 'POST' : if request . form [ 'username' ] != 'admin' or \\ request . form [ 'password' ] != 'secret' : error = 'Invalid credentials' else : flash ( 'You were successfully logged in' ) return redirect ( url_for ( 'index' )) return render_template ( 'login.html' , error = error ) And here is the :file: layout.html template which does the magic: .. sourcecode:: html+jinja <!doctype html> My Application {% with messages = get_flashed_messages() %} {% if messages %} {% for message in messages %} {{ message }} {% endfor %} {% endif %} {% endwith %} {% block body %}{% endblock %} Here is the :file: index.html template which inherits from :file: layout.html : .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block body %} Overview Do you want to log in? {% endblock %} And here is the :file: login.html template which also inherits from :file: layout.html : .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block body %} Login {% if error %} Error: {{ error }} {% endif %} Username: Password: {% endblock %} Flashing With Categories \u00b6 .. versionadded:: 0.3 It is also possible to provide categories when flashing a message. The default category if nothing is provided is 'message' . Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background. To flash a message with a different category, just use the second argument to the :func: ~flask.flash function:: flash(u'Invalid password provided', 'error') Inside the template you then have to tell the :func: ~flask.get_flashed_messages function to also return the categories. The loop looks slightly different in that situation then: .. sourcecode:: html+jinja {% with messages = get_flashed_messages(with_categories=true) %} {% if messages %} {% for category, message in messages %} {{ message }} {% endfor %} {% endif %} {% endwith %} This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as <strong>Error:</strong> to the message. Filtering Flash Messages \u00b6 .. versionadded:: 0.9 Optionally you can pass a list of categories which filters the results of :func: ~flask.get_flashed_messages . This is useful if you wish to render each category in a separate block. .. sourcecode:: html+jinja {% with errors = get_flashed_messages ( category_filter =[ \"error\" ]) %} {% if errors %} &lt;div class=\"alert-message block-message error\"&gt; &lt;a class=\"close\" href=\"#\"&gt;\u00d7&lt;/a&gt; &lt;ul&gt; {% - for msg in errors %} &lt;li&gt; {{ msg }} &lt;/li&gt; {% endfor - %} &lt;/ul&gt; &lt;/div&gt; {% endif %} {% endwith %}","title":"Flashing"},{"location":"patterns/flashing/#message-flashing","text":"Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently.","title":"Message Flashing"},{"location":"patterns/flashing/#simple-flashing","text":"So here is a full example:: from flask import Flask , flash , redirect , render_template , \\ request , url_for app = Flask ( __name__ ) app . secret_key = b '_5#y2L\"F4Q8z \\n\\xec ]/' @app.route ( '/' ) def index (): return render_template ( 'index.html' ) @app.route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): error = None if request . method == 'POST' : if request . form [ 'username' ] != 'admin' or \\ request . form [ 'password' ] != 'secret' : error = 'Invalid credentials' else : flash ( 'You were successfully logged in' ) return redirect ( url_for ( 'index' )) return render_template ( 'login.html' , error = error ) And here is the :file: layout.html template which does the magic: .. sourcecode:: html+jinja <!doctype html> My Application {% with messages = get_flashed_messages() %} {% if messages %} {% for message in messages %} {{ message }} {% endfor %} {% endif %} {% endwith %} {% block body %}{% endblock %} Here is the :file: index.html template which inherits from :file: layout.html : .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block body %}","title":"Simple Flashing"},{"location":"patterns/flashing/#flashing-with-categories","text":".. versionadded:: 0.3 It is also possible to provide categories when flashing a message. The default category if nothing is provided is 'message' . Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background. To flash a message with a different category, just use the second argument to the :func: ~flask.flash function:: flash(u'Invalid password provided', 'error') Inside the template you then have to tell the :func: ~flask.get_flashed_messages function to also return the categories. The loop looks slightly different in that situation then: .. sourcecode:: html+jinja {% with messages = get_flashed_messages(with_categories=true) %} {% if messages %} {% for category, message in messages %} {{ message }} {% endfor %} {% endif %} {% endwith %} This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as <strong>Error:</strong> to the message.","title":"Flashing With Categories"},{"location":"patterns/flashing/#filtering-flash-messages","text":".. versionadded:: 0.9 Optionally you can pass a list of categories which filters the results of :func: ~flask.get_flashed_messages . This is useful if you wish to render each category in a separate block. .. sourcecode:: html+jinja {% with errors = get_flashed_messages ( category_filter =[ \"error\" ]) %} {% if errors %} &lt;div class=\"alert-message block-message error\"&gt; &lt;a class=\"close\" href=\"#\"&gt;\u00d7&lt;/a&gt; &lt;ul&gt; {% - for msg in errors %} &lt;li&gt; {{ msg }} &lt;/li&gt; {% endfor - %} &lt;/ul&gt; &lt;/div&gt; {% endif %} {% endwith %}","title":"Filtering Flash Messages"},{"location":"patterns/jquery/","text":"AJAX with jQuery \u00b6 jQuery _ is a small JavaScript library commonly used to simplify working with the DOM and JavaScript in general. It is the perfect tool to make web applications more dynamic by exchanging JSON between server and client. JSON itself is a very lightweight transport format, very similar to how Python primitives (numbers, strings, dicts and lists) look like which is widely supported and very easy to parse. It became popular a few years ago and quickly replaced XML as transport format in web applications. .. _jQuery: https://jquery.com/ Loading jQuery \u00b6 In order to use jQuery, you have to download it first and place it in the static folder of your application and then ensure it's loaded. Ideally you have a layout template that is used for all pages where you just have to add a script statement to the bottom of your <body> to load jQuery: .. sourcecode:: html Another method is using Google's AJAX Libraries API <https://developers.google.com/speed/libraries/devguide> _ to load jQuery: .. sourcecode:: html &lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src=\"{{ url_for('static', filename='jquery.js') }}\"&gt;\\x3C/script&gt;')&lt;/script&gt; In this case you have to put jQuery into your static folder as a fallback, but it will first try to load it directly from Google. This has the advantage that your website will probably load faster for users if they went to at least one other website before using the same jQuery version from Google because it will already be in the browser cache. Where is My Site? \u00b6 Do you know where your application is? If you are developing the answer is quite simple: it's on localhost port something and directly on the root of that server. But what if you later decide to move your application to a different location? For example to http://example.com/myapp ? On the server side this never was a problem because we were using the handy :func: ~flask.url_for function that could answer that question for us, but if we are using jQuery we should not hardcode the path to the application but make that dynamic, so how can we do that? A simple method would be to add a script tag to our page that sets a global variable to the prefix to the root of the application. Something like this: .. sourcecode:: html+jinja $SCRIPT_ROOT = {{ request.script_root|tojson|safe }}; The |safe is necessary in Flask before 0.10 so that Jinja does not escape the JSON encoded string with HTML rules. Usually this would be necessary, but we are inside a script block here where different rules apply. .. admonition:: Information for Pros In HTML the script tag is declared CDATA which means that entities will not be parsed. Everything until </script> is handled as script. This also means that there must never be any </ between the script tags. |tojson is kind enough to do the right thing here and escape slashes for you ( {{ \"</script>\"|tojson|safe }} is rendered as \"<\\/script>\" ). In Flask 0.10 it goes a step further and escapes all HTML tags with unicode escapes. This makes it possible for Flask to automatically mark the result as HTML safe. JSON View Functions \u00b6 Now let's create a server side function that accepts two URL arguments of numbers which should be added together and then sent back to the application in a JSON object. This is a really ridiculous example and is something you usually would do on the client side alone, but a simple example that shows how you would use jQuery and Flask nonetheless:: from flask import Flask , jsonify , render_template , request app = Flask ( __name__ ) @app.route ( '/_add_numbers' ) def add_numbers (): a = request . args . get ( 'a' , 0 , type = int ) b = request . args . get ( 'b' , 0 , type = int ) return jsonify ( result = a + b ) @app.route ( '/' ) def index (): return render_template ( 'index.html' ) As you can see I also added an index method here that renders a template. This template will load jQuery as above and have a little form where we can add two numbers and a link to trigger the function on the server side. Note that we are using the :meth: ~werkzeug.datastructures.MultiDict.get method here which will never fail. If the key is missing a default value (here 0 ) is returned. Furthermore it can convert values to a specific type (like in our case int ). This is especially handy for code that is triggered by a script (APIs, JavaScript etc.) because you don't need special error reporting in that case. The HTML \u00b6 Your index.html template either has to extend a :file: layout.html template with jQuery loaded and the $SCRIPT_ROOT variable set, or do that on the top. Here's the HTML code needed for our little application (:file: index.html ). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file: .. sourcecode:: html &lt;script type=text/javascript&gt; $(function() { $('a#calculate').bind('click', function() { $.getJSON($SCRIPT_ROOT + '/_add_numbers', { a: $('input[name=\"a\"]').val(), b: $('input[name=\"b\"]').val() }, function(data) { $(\"#result\").text(data.result); }); return false; }); }); &lt;/script&gt; &lt;h1&gt;jQuery Example&lt;/h1&gt; &lt;p&gt;&lt;input type=text size=5 name=a&gt; + &lt;input type=text size=5 name=b&gt; = &lt;span id=result&gt;?&lt;/span&gt; &lt;p&gt;&lt;a href=# id=calculate&gt;calculate server side&lt;/a&gt; I won't go into detail here about how jQuery works, just a very quick explanation of the little bit of code above: $(function() { ... }) specifies code that should run once the browser is done loading the basic parts of the page. $('selector') selects an element and lets you operate on it. element.bind('event', func) specifies a function that should run when the user clicked on the element. If that function returns false , the default behavior will not kick in (in this case, navigate to the # URL). $.getJSON(url, data, func) sends a GET request to url and will send the contents of the data object as query parameters. Once the data arrived, it will call the given function with the return value as argument. Note that we can use the $SCRIPT_ROOT variable here that we set earlier. Check out the :gh: example source <examples/javascript> for a full application demonstrating the code on this page, as well as the same thing using XMLHttpRequest and fetch .","title":"AJAX with jQuery"},{"location":"patterns/jquery/#ajax-with-jquery","text":"jQuery _ is a small JavaScript library commonly used to simplify working with the DOM and JavaScript in general. It is the perfect tool to make web applications more dynamic by exchanging JSON between server and client. JSON itself is a very lightweight transport format, very similar to how Python primitives (numbers, strings, dicts and lists) look like which is widely supported and very easy to parse. It became popular a few years ago and quickly replaced XML as transport format in web applications. .. _jQuery: https://jquery.com/","title":"AJAX with jQuery"},{"location":"patterns/jquery/#loading-jquery","text":"In order to use jQuery, you have to download it first and place it in the static folder of your application and then ensure it's loaded. Ideally you have a layout template that is used for all pages where you just have to add a script statement to the bottom of your <body> to load jQuery: .. sourcecode:: html Another method is using Google's AJAX Libraries API <https://developers.google.com/speed/libraries/devguide> _ to load jQuery: .. sourcecode:: html &lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src=\"{{ url_for('static', filename='jquery.js') }}\"&gt;\\x3C/script&gt;')&lt;/script&gt; In this case you have to put jQuery into your static folder as a fallback, but it will first try to load it directly from Google. This has the advantage that your website will probably load faster for users if they went to at least one other website before using the same jQuery version from Google because it will already be in the browser cache.","title":"Loading jQuery"},{"location":"patterns/jquery/#where-is-my-site","text":"Do you know where your application is? If you are developing the answer is quite simple: it's on localhost port something and directly on the root of that server. But what if you later decide to move your application to a different location? For example to http://example.com/myapp ? On the server side this never was a problem because we were using the handy :func: ~flask.url_for function that could answer that question for us, but if we are using jQuery we should not hardcode the path to the application but make that dynamic, so how can we do that? A simple method would be to add a script tag to our page that sets a global variable to the prefix to the root of the application. Something like this: .. sourcecode:: html+jinja $SCRIPT_ROOT = {{ request.script_root|tojson|safe }}; The |safe is necessary in Flask before 0.10 so that Jinja does not escape the JSON encoded string with HTML rules. Usually this would be necessary, but we are inside a script block here where different rules apply. .. admonition:: Information for Pros In HTML the script tag is declared CDATA which means that entities will not be parsed. Everything until </script> is handled as script. This also means that there must never be any </ between the script tags. |tojson is kind enough to do the right thing here and escape slashes for you ( {{ \"</script>\"|tojson|safe }} is rendered as \"<\\/script>\" ). In Flask 0.10 it goes a step further and escapes all HTML tags with unicode escapes. This makes it possible for Flask to automatically mark the result as HTML safe.","title":"Where is My Site?"},{"location":"patterns/jquery/#json-view-functions","text":"Now let's create a server side function that accepts two URL arguments of numbers which should be added together and then sent back to the application in a JSON object. This is a really ridiculous example and is something you usually would do on the client side alone, but a simple example that shows how you would use jQuery and Flask nonetheless:: from flask import Flask , jsonify , render_template , request app = Flask ( __name__ ) @app.route ( '/_add_numbers' ) def add_numbers (): a = request . args . get ( 'a' , 0 , type = int ) b = request . args . get ( 'b' , 0 , type = int ) return jsonify ( result = a + b ) @app.route ( '/' ) def index (): return render_template ( 'index.html' ) As you can see I also added an index method here that renders a template. This template will load jQuery as above and have a little form where we can add two numbers and a link to trigger the function on the server side. Note that we are using the :meth: ~werkzeug.datastructures.MultiDict.get method here which will never fail. If the key is missing a default value (here 0 ) is returned. Furthermore it can convert values to a specific type (like in our case int ). This is especially handy for code that is triggered by a script (APIs, JavaScript etc.) because you don't need special error reporting in that case.","title":"JSON View Functions"},{"location":"patterns/jquery/#the-html","text":"Your index.html template either has to extend a :file: layout.html template with jQuery loaded and the $SCRIPT_ROOT variable set, or do that on the top. Here's the HTML code needed for our little application (:file: index.html ). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file: .. sourcecode:: html &lt;script type=text/javascript&gt; $(function() { $('a#calculate').bind('click', function() { $.getJSON($SCRIPT_ROOT + '/_add_numbers', { a: $('input[name=\"a\"]').val(), b: $('input[name=\"b\"]').val() }, function(data) { $(\"#result\").text(data.result); }); return false; }); }); &lt;/script&gt; &lt;h1&gt;jQuery Example&lt;/h1&gt; &lt;p&gt;&lt;input type=text size=5 name=a&gt; + &lt;input type=text size=5 name=b&gt; = &lt;span id=result&gt;?&lt;/span&gt; &lt;p&gt;&lt;a href=# id=calculate&gt;calculate server side&lt;/a&gt; I won't go into detail here about how jQuery works, just a very quick explanation of the little bit of code above: $(function() { ... }) specifies code that should run once the browser is done loading the basic parts of the page. $('selector') selects an element and lets you operate on it. element.bind('event', func) specifies a function that should run when the user clicked on the element. If that function returns false , the default behavior will not kick in (in this case, navigate to the # URL). $.getJSON(url, data, func) sends a GET request to url and will send the contents of the data object as query parameters. Once the data arrived, it will call the given function with the return value as argument. Note that we can use the $SCRIPT_ROOT variable here that we set earlier. Check out the :gh: example source <examples/javascript> for a full application demonstrating the code on this page, as well as the same thing using XMLHttpRequest and fetch .","title":"The HTML"},{"location":"patterns/lazyloading/","text":"Lazily Loading Views \u00b6 Flask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function. This can be a problem if your application has to import quick. It might have to do that on systems like Google's App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping. The system that enables having a central URL map is the :meth: ~flask.Flask.add_url_rule function. Instead of using decorators, you have a file that sets up the application with all URLs. Converting to Centralized URL Map \u00b6 Imagine the current application looks somewhat like this:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def index (): pass @app.route ( '/user/&lt;username&gt;' ) def user ( username ): pass Then, with the centralized approach you would have one file with the views (:file: views.py ) but without any decorator:: def index(): pass def user(username): pass And then a file that sets up an application which maps the functions to URLs:: from flask import Flask from yourapplication import views app = Flask ( __name__ ) app . add_url_rule ( '/' , view_func = views . index ) app . add_url_rule ( '/user/&lt;username&gt;' , view_func = views . user ) Loading Late \u00b6 So far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use:: from werkzeug import import_string , cached_property class LazyView ( object ): def __init__ ( self , import_name ): self . __module__ , self . __name__ = import_name . rsplit ( '.' , 1 ) self . import_name = import_name @cached_property def view ( self ): return import_string ( self . import_name ) def __call__ ( self , * args , ** kwargs ): return self . view ( * args , ** kwargs ) What's important here is is that __module__ and __name__ are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don't provide a name for the rule yourself. Then you can define your central place to combine the views like this:: from flask import Flask from yourapplication.helpers import LazyView app = Flask ( __name__ ) app . add_url_rule ( '/' , view_func = LazyView ( 'yourapplication.views.index' )) app . add_url_rule ( '/user/&lt;username&gt;' , view_func = LazyView ( 'yourapplication.views.user' )) You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into :meth: ~flask.Flask.add_url_rule by prefixing a string with the project name and a dot, and by wrapping view_func in a LazyView as needed. :: def url(import_name, url_rules=[], **options): view = LazyView('yourapplication.' + import_name) for url_rule in url_rules: app.add_url_rule(url_rule, view_func=view, **options) # add a single route to the index view url('views.index', ['/']) # add two routes to a single function endpoint url_rules = ['/user/','/user/&lt;username&gt;'] url('views.user', url_rules) One thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator.","title":"Lazily Loading Views"},{"location":"patterns/lazyloading/#lazily-loading-views","text":"Flask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function. This can be a problem if your application has to import quick. It might have to do that on systems like Google's App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping. The system that enables having a central URL map is the :meth: ~flask.Flask.add_url_rule function. Instead of using decorators, you have a file that sets up the application with all URLs.","title":"Lazily Loading Views"},{"location":"patterns/lazyloading/#converting-to-centralized-url-map","text":"Imagine the current application looks somewhat like this:: from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def index (): pass @app.route ( '/user/&lt;username&gt;' ) def user ( username ): pass Then, with the centralized approach you would have one file with the views (:file: views.py ) but without any decorator:: def index(): pass def user(username): pass And then a file that sets up an application which maps the functions to URLs:: from flask import Flask from yourapplication import views app = Flask ( __name__ ) app . add_url_rule ( '/' , view_func = views . index ) app . add_url_rule ( '/user/&lt;username&gt;' , view_func = views . user )","title":"Converting to Centralized URL Map"},{"location":"patterns/lazyloading/#loading-late","text":"So far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use:: from werkzeug import import_string , cached_property class LazyView ( object ): def __init__ ( self , import_name ): self . __module__ , self . __name__ = import_name . rsplit ( '.' , 1 ) self . import_name = import_name @cached_property def view ( self ): return import_string ( self . import_name ) def __call__ ( self , * args , ** kwargs ): return self . view ( * args , ** kwargs ) What's important here is is that __module__ and __name__ are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don't provide a name for the rule yourself. Then you can define your central place to combine the views like this:: from flask import Flask from yourapplication.helpers import LazyView app = Flask ( __name__ ) app . add_url_rule ( '/' , view_func = LazyView ( 'yourapplication.views.index' )) app . add_url_rule ( '/user/&lt;username&gt;' , view_func = LazyView ( 'yourapplication.views.user' )) You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into :meth: ~flask.Flask.add_url_rule by prefixing a string with the project name and a dot, and by wrapping view_func in a LazyView as needed. :: def url(import_name, url_rules=[], **options): view = LazyView('yourapplication.' + import_name) for url_rule in url_rules: app.add_url_rule(url_rule, view_func=view, **options) # add a single route to the index view url('views.index', ['/']) # add two routes to a single function endpoint url_rules = ['/user/','/user/&lt;username&gt;'] url('views.user', url_rules) One thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator.","title":"Loading Late"},{"location":"patterns/methodoverrides/","text":"Adding HTTP Method Overrides \u00b6 Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it's possible to \u201cproxy\u201d HTTP methods through another HTTP method in total violation of the protocol. The way this works is by letting the client do an HTTP POST request and set the X-HTTP-Method-Override header and set the value to the intended HTTP method (such as PATCH ). This can easily be accomplished with an HTTP middleware:: class HTTPMethodOverrideMiddleware ( object ) : allowed_methods = frozenset ([ 'GET' , 'HEAD' , 'POST' , 'DELETE' , 'PUT' , 'PATCH' , 'OPTIONS' ]) bodyless_methods = frozenset ([ 'GET' , 'HEAD' , 'OPTIONS' , 'DELETE' ]) def __init__ ( self , app ) : self . app = app def __call__ ( self , environ , start_response ) : method = environ . get ( 'HTTP_X_HTTP_METHOD_OVERRIDE' , '' ). upper () if method in self.allowed_methods : method = method . encode ( 'ascii' , 'replace' ) environ [ 'REQUEST_METHOD' ] = method if method in self.bodyless_methods : environ [ 'CONTENT_LENGTH' ] = '0' return self . app ( environ , start_response ) To use this with Flask this is all that is necessary:: from flask import Flask app = Flask ( __name__ ) app . wsgi_app = HTTPMethodOverrideMiddleware ( app . wsgi_app )","title":"Adding HTTP Method Overrides"},{"location":"patterns/methodoverrides/#adding-http-method-overrides","text":"Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it's possible to \u201cproxy\u201d HTTP methods through another HTTP method in total violation of the protocol. The way this works is by letting the client do an HTTP POST request and set the X-HTTP-Method-Override header and set the value to the intended HTTP method (such as PATCH ). This can easily be accomplished with an HTTP middleware:: class HTTPMethodOverrideMiddleware ( object ) : allowed_methods = frozenset ([ 'GET' , 'HEAD' , 'POST' , 'DELETE' , 'PUT' , 'PATCH' , 'OPTIONS' ]) bodyless_methods = frozenset ([ 'GET' , 'HEAD' , 'OPTIONS' , 'DELETE' ]) def __init__ ( self , app ) : self . app = app def __call__ ( self , environ , start_response ) : method = environ . get ( 'HTTP_X_HTTP_METHOD_OVERRIDE' , '' ). upper () if method in self.allowed_methods : method = method . encode ( 'ascii' , 'replace' ) environ [ 'REQUEST_METHOD' ] = method if method in self.bodyless_methods : environ [ 'CONTENT_LENGTH' ] = '0' return self . app ( environ , start_response ) To use this with Flask this is all that is necessary:: from flask import Flask app = Flask ( __name__ ) app . wsgi_app = HTTPMethodOverrideMiddleware ( app . wsgi_app )","title":"Adding HTTP Method Overrides"},{"location":"patterns/mongoengine/","text":"MongoDB with MongoEngine \u00b6 Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use MongoEngine _, a document mapper library, to integrate with MongoDB. A running MongoDB server and Flask-MongoEngine _ are required. :: pip install flask-mongoengine .. _MongoEngine: http://mongoengine.org .. _Flask-MongoEngine: https://flask-mongoengine.readthedocs.io Configuration \u00b6 Basic setup can be done by defining MONGODB_SETTINGS on app.config and creating a MongoEngine instance. :: from flask import Flask from flask_mongoengine import MongoEngine app = Flask ( __name__ ) app . config [ 'MONGODB_SETTINGS' ] = { \"db\" : \"myapp\" , } db = MongoEngine ( app ) Mapping Documents \u00b6 To declare a model that represents a Mongo document, create a class that inherits from Document and declare each of the fields. :: import mongoengine as me class Movie ( me . Document ): title = me . StringField ( required = True ) year = me . IntField () rated = me . StringField () director = me . StringField () actors = me . ListField () If the document has nested fields, use EmbeddedDocument to defined the fields of the embedded document and EmbeddedDocumentField to declare it on the parent document. :: class Imdb ( me . EmbeddedDocument ) : imdb_id = me . StringField () rating = me . DecimalField () votes = me . IntField () class Movie ( me . Document ) : ... imdb = me . EmbeddedDocumentField ( Imdb ) Creating Data \u00b6 Instantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call doc.save() . :: bttf = Movie(title=\"Back To The Future\", year=1985) bttf.actors = [ \"Michael J. Fox\", \"Christopher Lloyd\" ] bttf.imdb = Imdb(imdb_id=\"tt0088763\", rating=8.5) bttf.save() Queries \u00b6 Use the class objects attribute to make queries. A keyword argument looks for an equal value on the field. :: bttf = Movies.objects(title=\"Back To The Future\").get_or_404() Query operators may be used by concatenating them with the field name using a double-underscore. objects , and queries returned by calling it, are iterable. :: some_theron_movie = Movie.objects(actors__in=[\"Charlize Theron\"]).first() for recents in Movie.objects(year__gte=2017): print(recents.title) Documentation \u00b6 There are many more ways to define and query documents with MongoEngine. For more information, check out the official documentation <MongoEngine_> _. Flask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their documentation <Flask-MongoEngine_> _ as well.","title":"MongoDB with MongoEngine"},{"location":"patterns/mongoengine/#mongodb-with-mongoengine","text":"Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use MongoEngine _, a document mapper library, to integrate with MongoDB. A running MongoDB server and Flask-MongoEngine _ are required. :: pip install flask-mongoengine .. _MongoEngine: http://mongoengine.org .. _Flask-MongoEngine: https://flask-mongoengine.readthedocs.io","title":"MongoDB with MongoEngine"},{"location":"patterns/mongoengine/#configuration","text":"Basic setup can be done by defining MONGODB_SETTINGS on app.config and creating a MongoEngine instance. :: from flask import Flask from flask_mongoengine import MongoEngine app = Flask ( __name__ ) app . config [ 'MONGODB_SETTINGS' ] = { \"db\" : \"myapp\" , } db = MongoEngine ( app )","title":"Configuration"},{"location":"patterns/mongoengine/#mapping-documents","text":"To declare a model that represents a Mongo document, create a class that inherits from Document and declare each of the fields. :: import mongoengine as me class Movie ( me . Document ): title = me . StringField ( required = True ) year = me . IntField () rated = me . StringField () director = me . StringField () actors = me . ListField () If the document has nested fields, use EmbeddedDocument to defined the fields of the embedded document and EmbeddedDocumentField to declare it on the parent document. :: class Imdb ( me . EmbeddedDocument ) : imdb_id = me . StringField () rating = me . DecimalField () votes = me . IntField () class Movie ( me . Document ) : ... imdb = me . EmbeddedDocumentField ( Imdb )","title":"Mapping Documents"},{"location":"patterns/mongoengine/#creating-data","text":"Instantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call doc.save() . :: bttf = Movie(title=\"Back To The Future\", year=1985) bttf.actors = [ \"Michael J. Fox\", \"Christopher Lloyd\" ] bttf.imdb = Imdb(imdb_id=\"tt0088763\", rating=8.5) bttf.save()","title":"Creating Data"},{"location":"patterns/mongoengine/#queries","text":"Use the class objects attribute to make queries. A keyword argument looks for an equal value on the field. :: bttf = Movies.objects(title=\"Back To The Future\").get_or_404() Query operators may be used by concatenating them with the field name using a double-underscore. objects , and queries returned by calling it, are iterable. :: some_theron_movie = Movie.objects(actors__in=[\"Charlize Theron\"]).first() for recents in Movie.objects(year__gte=2017): print(recents.title)","title":"Queries"},{"location":"patterns/mongoengine/#documentation","text":"There are many more ways to define and query documents with MongoEngine. For more information, check out the official documentation <MongoEngine_> _. Flask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their documentation <Flask-MongoEngine_> _ as well.","title":"Documentation"},{"location":"patterns/mongokit/","text":":orphan: MongoDB with MongoKit \u00b6 MongoKit is no longer maintained. See :doc: /patterns/mongoengine instead.","title":"Mongokit"},{"location":"patterns/mongokit/#mongodb-with-mongokit","text":"MongoKit is no longer maintained. See :doc: /patterns/mongoengine instead.","title":"MongoDB with MongoKit"},{"location":"patterns/packages/","text":".. _larger-applications: Larger Applications \u00b6 Imagine a simple flask application structure that looks like this:: /yourapplication yourapplication.py /static style.css /templates layout.html index.html login.html ... While this is fine for small applications, for larger applications it's a good idea to use a package instead of a module. The :ref: tutorial <tutorial> is structured to use the package pattern, see the :gh: example code <examples/tutorial> . Simple Packages \u00b6 To convert that into a larger one, just create a new folder :file: yourapplication inside the existing one and move everything below it. Then rename :file: yourapplication.py to :file: __init__.py . (Make sure to delete all .pyc files first, otherwise things would most likely break) You should then end up with something like that:: /yourapplication /yourapplication __init__.py /static style.css /templates layout.html index.html login.html ... But how do you run your application now? The naive python yourapplication/__init__.py will not work. Let's just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called :file: setup.py next to the inner :file: yourapplication folder with the following contents:: from setuptools import setup setup ( name = 'yourapplication' , packages = [ 'yourapplication' ], include_package_data = True , install_requires = [ 'flask' , ], ) In order to run the application you need to export an environment variable that tells Flask where to find the application instance:: $ export FLASK_APP = yourapplication If you are outside of the project directory make sure to provide the exact path to your application directory. Similarly you can turn on the development features like this:: $ export FLASK_ENV = development In order to install and run the application you need to issue the following commands:: $ pip install -e . $ flask run What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist: the Flask application object creation has to be in the :file: __init__.py file. That way each module can import it safely and the __name__ variable will resolve to the correct package. all the view functions (the ones with a :meth: ~flask.Flask.route decorator on top) have to be imported in the :file: __init__.py file. Not the object itself, but the module it is in. Import the view module after the application object is created . Here's an example :file: __init__.py :: from flask import Flask app = Flask ( __name__ ) import yourapplication.views And this is what :file: views.py would look like:: from yourapplication import app @app.route ( '/' ) def index (): return 'Hello World!' You should then end up with something like that:: /yourapplication setup.py /yourapplication __init__.py views.py /static style.css /templates layout.html index.html login.html ... .. admonition:: Circular Imports Every Python programmer hates them, and yet we just added some: circular imports (That's when two modules depend on each other. In this case :file: views.py depends on :file: __init__.py ). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in :file: __init__.py and just ensuring the module is imported and we are doing that at the bottom of the file. There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the :ref: becomingbig section for some inspiration how to deal with that. .. _working-with-modules: Working with Blueprints \u00b6 If you have larger applications it's recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the :ref: blueprints chapter of the documentation.","title":"Packages"},{"location":"patterns/packages/#larger-applications","text":"Imagine a simple flask application structure that looks like this:: /yourapplication yourapplication.py /static style.css /templates layout.html index.html login.html ... While this is fine for small applications, for larger applications it's a good idea to use a package instead of a module. The :ref: tutorial <tutorial> is structured to use the package pattern, see the :gh: example code <examples/tutorial> .","title":"Larger Applications"},{"location":"patterns/packages/#simple-packages","text":"To convert that into a larger one, just create a new folder :file: yourapplication inside the existing one and move everything below it. Then rename :file: yourapplication.py to :file: __init__.py . (Make sure to delete all .pyc files first, otherwise things would most likely break) You should then end up with something like that:: /yourapplication /yourapplication __init__.py /static style.css /templates layout.html index.html login.html ... But how do you run your application now? The naive python yourapplication/__init__.py will not work. Let's just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called :file: setup.py next to the inner :file: yourapplication folder with the following contents:: from setuptools import setup setup ( name = 'yourapplication' , packages = [ 'yourapplication' ], include_package_data = True , install_requires = [ 'flask' , ], ) In order to run the application you need to export an environment variable that tells Flask where to find the application instance:: $ export FLASK_APP = yourapplication If you are outside of the project directory make sure to provide the exact path to your application directory. Similarly you can turn on the development features like this:: $ export FLASK_ENV = development In order to install and run the application you need to issue the following commands:: $ pip install -e . $ flask run What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist: the Flask application object creation has to be in the :file: __init__.py file. That way each module can import it safely and the __name__ variable will resolve to the correct package. all the view functions (the ones with a :meth: ~flask.Flask.route decorator on top) have to be imported in the :file: __init__.py file. Not the object itself, but the module it is in. Import the view module after the application object is created . Here's an example :file: __init__.py :: from flask import Flask app = Flask ( __name__ ) import yourapplication.views And this is what :file: views.py would look like:: from yourapplication import app @app.route ( '/' ) def index (): return 'Hello World!' You should then end up with something like that:: /yourapplication setup.py /yourapplication __init__.py views.py /static style.css /templates layout.html index.html login.html ... .. admonition:: Circular Imports Every Python programmer hates them, and yet we just added some: circular imports (That's when two modules depend on each other. In this case :file: views.py depends on :file: __init__.py ). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in :file: __init__.py and just ensuring the module is imported and we are doing that at the bottom of the file. There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the :ref: becomingbig section for some inspiration how to deal with that. .. _working-with-modules:","title":"Simple Packages"},{"location":"patterns/packages/#working-with-blueprints","text":"If you have larger applications it's recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the :ref: blueprints chapter of the documentation.","title":"Working with Blueprints"},{"location":"patterns/requestchecksum/","text":"Request Content Checksums \u00b6 Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs. Fortunately this is however very simple to change by wrapping the input stream. The following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment:: import hashlib class ChecksumCalcStream ( object ): def __init__ ( self , stream ): self . _stream = stream self . _hash = hashlib . sha1 () def read ( self , bytes ): rv = self . _stream . read ( bytes ) self . _hash . update ( rv ) return rv def readline ( self , size_hint ): rv = self . _stream . readline ( size_hint ) self . _hash . update ( rv ) return rv def generate_checksum ( request ): env = request . environ stream = ChecksumCalcStream ( env [ 'wsgi.input' ]) env [ 'wsgi.input' ] = stream return stream . _hash To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing request.form or anything of that nature. before_request_handlers for instance should be careful not to access it). Example usage:: @app.route('/special-api', methods=['POST']) def special_api(): hash = generate_checksum(request) # Accessing this parses the input stream files = request.files # At this point the hash is fully constructed. checksum = hash.hexdigest() return 'Hash was: %s' % checksum","title":"Request Content Checksums"},{"location":"patterns/requestchecksum/#request-content-checksums","text":"Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs. Fortunately this is however very simple to change by wrapping the input stream. The following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment:: import hashlib class ChecksumCalcStream ( object ): def __init__ ( self , stream ): self . _stream = stream self . _hash = hashlib . sha1 () def read ( self , bytes ): rv = self . _stream . read ( bytes ) self . _hash . update ( rv ) return rv def readline ( self , size_hint ): rv = self . _stream . readline ( size_hint ) self . _hash . update ( rv ) return rv def generate_checksum ( request ): env = request . environ stream = ChecksumCalcStream ( env [ 'wsgi.input' ]) env [ 'wsgi.input' ] = stream return stream . _hash To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing request.form or anything of that nature. before_request_handlers for instance should be careful not to access it). Example usage:: @app.route('/special-api', methods=['POST']) def special_api(): hash = generate_checksum(request) # Accessing this parses the input stream files = request.files # At this point the hash is fully constructed. checksum = hash.hexdigest() return 'Hash was: %s' % checksum","title":"Request Content Checksums"},{"location":"patterns/singlepageapplications/","text":"Single-Page Applications \u00b6 Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA. The following example demonstrates how to serve an SPA along with an API:: from flask import Flask , jsonify app = Flask ( __name__ , static_folder = 'app' ) @app.route ( \"/heartbeat\" ) def heartbeat (): return jsonify ({ \"status\" : \"healthy\" }) @app.route ( '/' , defaults = { 'path' : '' }) @app.route ( '/&lt;path:path&gt;' ) def catch_all ( path ): return app . send_static_file ( \"index.html\" )","title":"Single-Page Applications"},{"location":"patterns/singlepageapplications/#single-page-applications","text":"Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA. The following example demonstrates how to serve an SPA along with an API:: from flask import Flask , jsonify app = Flask ( __name__ , static_folder = 'app' ) @app.route ( \"/heartbeat\" ) def heartbeat (): return jsonify ({ \"status\" : \"healthy\" }) @app.route ( '/' , defaults = { 'path' : '' }) @app.route ( '/&lt;path:path&gt;' ) def catch_all ( path ): return app . send_static_file ( \"index.html\" )","title":"Single-Page Applications"},{"location":"patterns/sqlalchemy/","text":".. _sqlalchemy-pattern: SQLAlchemy in Flask \u00b6 Many people prefer SQLAlchemy _ for database access. In this case it's encouraged to use a package instead of a module for your flask application and drop the models into a separate module (:ref: larger-applications ). While that is not necessary, it makes a lot of sense. There are four very common ways to use SQLAlchemy. I will outline each of them here: Flask-SQLAlchemy Extension \u00b6 Because SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly. You can download Flask-SQLAlchemy from PyPI <https://pypi.org/project/Flask-SQLAlchemy/> . .. _Flask-SQLAlchemy: http://flask-sqlalchemy.pocoo.org/ Declarative \u00b6 The declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the declarative _ extension. Here's the example :file: database.py module for your application:: from sqlalchemy import create_engine from sqlalchemy.orm import scoped_session , sessionmaker from sqlalchemy.ext.declarative import declarative_base engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) db_session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , bind = engine )) Base = declarative_base () Base . query = db_session . query_property () def init_db (): # import all modules here that might define models so that # they will be registered properly on the metadata. Otherwise # you will have to import them first before calling init_db() import yourapplication.models Base . metadata . create_all ( bind = engine ) To define your models, just subclass the Base class that was created by the code above. If you are wondering why we don't have to care about threads here (like we did in the SQLite3 example above with the :data: ~flask.g object): that's because SQLAlchemy does that for us already with the :class: ~sqlalchemy.orm.scoped_session . To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:: from yourapplication.database import db_session @app.teardown_appcontext def shutdown_session ( exception = None ): db_session . remove () Here is an example model (put this into :file: models.py , e.g.):: from sqlalchemy import Column , Integer , String from yourapplication.database import Base class User ( Base ): __tablename__ = 'users' id = Column ( Integer , primary_key = True ) name = Column ( String ( 50 ), unique = True ) email = Column ( String ( 120 ), unique = True ) def __init__ ( self , name = None , email = None ): self . name = name self . email = email def __repr__ ( self ): return '&lt;User %r &gt;' % ( self . name ) To create the database you can use the init_db function: from yourapplication.database import init_db init_db() You can insert entries into the database like this: from yourapplication.database import db_session from yourapplication.models import User u = User('admin', 'admin@localhost') db_session.add(u) db_session.commit() Querying is simple as well: User.query.all() [ ] User.query.filter(User.name == 'admin').first() .. _SQLAlchemy: https://www.sqlalchemy.org/ .. _declarative: https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/ Manual Object Relational Mapping \u00b6 Manual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It's more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package. Here is an example :file: database.py module for your application:: from sqlalchemy import create_engine , MetaData from sqlalchemy.orm import scoped_session , sessionmaker engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) metadata = MetaData () db_session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , bind = engine )) def init_db (): metadata . create_all ( bind = engine ) As in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module:: from yourapplication.database import db_session @app.teardown_appcontext def shutdown_session ( exception = None ): db_session . remove () Here is an example table and model (put this into :file: models.py ):: from sqlalchemy import Table , Column , Integer , String from sqlalchemy.orm import mapper from yourapplication.database import metadata , db_session class User ( object ): query = db_session . query_property () def __init__ ( self , name = None , email = None ): self . name = name self . email = email def __repr__ ( self ): return '&lt;User %r &gt;' % ( self . name ) users = Table ( 'users' , metadata , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ( 50 ), unique = True ), Column ( 'email' , String ( 120 ), unique = True ) ) mapper ( User , users ) Querying and inserting works exactly the same as in the example above. SQL Abstraction Layer \u00b6 If you just want to use the database system (and SQL) abstraction layer you basically only need the engine:: from sqlalchemy import create_engine , MetaData , Table engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) metadata = MetaData ( bind = engine ) Then you can either declare the tables in your code like in the examples above, or automatically load them:: from sqlalchemy import Table users = Table ( 'users' , metadata , autoload = True ) To insert data you can use the insert method. We have to get a connection first so that we can use a transaction: con = engine.connect() con.execute(users.insert(), name='admin', email='admin@localhost') SQLAlchemy will automatically commit for us. To query your database, you use the engine directly or use a connection: users.select(users.c.id == 1).execute().first() (1, u'admin', u'admin@localhost') These results are also dict-like tuples: r = users.select(users.c.id == 1).execute().first() r['name'] u'admin' You can also pass strings of SQL statements to the :meth: ~sqlalchemy.engine.base.Connection.execute method: engine.execute('select * from users where id = :1', [1]).first() (1, u'admin', u'admin@localhost') For more information about SQLAlchemy, head over to the website <https://www.sqlalchemy.org/> _.","title":"Sqlalchemy"},{"location":"patterns/sqlalchemy/#sqlalchemy-in-flask","text":"Many people prefer SQLAlchemy _ for database access. In this case it's encouraged to use a package instead of a module for your flask application and drop the models into a separate module (:ref: larger-applications ). While that is not necessary, it makes a lot of sense. There are four very common ways to use SQLAlchemy. I will outline each of them here:","title":"SQLAlchemy in Flask"},{"location":"patterns/sqlalchemy/#flask-sqlalchemy-extension","text":"Because SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly. You can download Flask-SQLAlchemy from PyPI <https://pypi.org/project/Flask-SQLAlchemy/> . .. _Flask-SQLAlchemy: http://flask-sqlalchemy.pocoo.org/","title":"Flask-SQLAlchemy Extension"},{"location":"patterns/sqlalchemy/#declarative","text":"The declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the declarative _ extension. Here's the example :file: database.py module for your application:: from sqlalchemy import create_engine from sqlalchemy.orm import scoped_session , sessionmaker from sqlalchemy.ext.declarative import declarative_base engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) db_session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , bind = engine )) Base = declarative_base () Base . query = db_session . query_property () def init_db (): # import all modules here that might define models so that # they will be registered properly on the metadata. Otherwise # you will have to import them first before calling init_db() import yourapplication.models Base . metadata . create_all ( bind = engine ) To define your models, just subclass the Base class that was created by the code above. If you are wondering why we don't have to care about threads here (like we did in the SQLite3 example above with the :data: ~flask.g object): that's because SQLAlchemy does that for us already with the :class: ~sqlalchemy.orm.scoped_session . To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:: from yourapplication.database import db_session @app.teardown_appcontext def shutdown_session ( exception = None ): db_session . remove () Here is an example model (put this into :file: models.py , e.g.):: from sqlalchemy import Column , Integer , String from yourapplication.database import Base class User ( Base ): __tablename__ = 'users' id = Column ( Integer , primary_key = True ) name = Column ( String ( 50 ), unique = True ) email = Column ( String ( 120 ), unique = True ) def __init__ ( self , name = None , email = None ): self . name = name self . email = email def __repr__ ( self ): return '&lt;User %r &gt;' % ( self . name ) To create the database you can use the init_db function: from yourapplication.database import init_db init_db() You can insert entries into the database like this: from yourapplication.database import db_session from yourapplication.models import User u = User('admin', 'admin@localhost') db_session.add(u) db_session.commit() Querying is simple as well: User.query.all() [ ] User.query.filter(User.name == 'admin').first() .. _SQLAlchemy: https://www.sqlalchemy.org/ .. _declarative: https://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/","title":"Declarative"},{"location":"patterns/sqlalchemy/#manual-object-relational-mapping","text":"Manual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It's more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package. Here is an example :file: database.py module for your application:: from sqlalchemy import create_engine , MetaData from sqlalchemy.orm import scoped_session , sessionmaker engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) metadata = MetaData () db_session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , bind = engine )) def init_db (): metadata . create_all ( bind = engine ) As in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module:: from yourapplication.database import db_session @app.teardown_appcontext def shutdown_session ( exception = None ): db_session . remove () Here is an example table and model (put this into :file: models.py ):: from sqlalchemy import Table , Column , Integer , String from sqlalchemy.orm import mapper from yourapplication.database import metadata , db_session class User ( object ): query = db_session . query_property () def __init__ ( self , name = None , email = None ): self . name = name self . email = email def __repr__ ( self ): return '&lt;User %r &gt;' % ( self . name ) users = Table ( 'users' , metadata , Column ( 'id' , Integer , primary_key = True ), Column ( 'name' , String ( 50 ), unique = True ), Column ( 'email' , String ( 120 ), unique = True ) ) mapper ( User , users ) Querying and inserting works exactly the same as in the example above.","title":"Manual Object Relational Mapping"},{"location":"patterns/sqlalchemy/#sql-abstraction-layer","text":"If you just want to use the database system (and SQL) abstraction layer you basically only need the engine:: from sqlalchemy import create_engine , MetaData , Table engine = create_engine ( 'sqlite:////tmp/test.db' , convert_unicode = True ) metadata = MetaData ( bind = engine ) Then you can either declare the tables in your code like in the examples above, or automatically load them:: from sqlalchemy import Table users = Table ( 'users' , metadata , autoload = True ) To insert data you can use the insert method. We have to get a connection first so that we can use a transaction: con = engine.connect() con.execute(users.insert(), name='admin', email='admin@localhost') SQLAlchemy will automatically commit for us. To query your database, you use the engine directly or use a connection: users.select(users.c.id == 1).execute().first() (1, u'admin', u'admin@localhost') These results are also dict-like tuples: r = users.select(users.c.id == 1).execute().first() r['name'] u'admin' You can also pass strings of SQL statements to the :meth: ~sqlalchemy.engine.base.Connection.execute method: engine.execute('select * from users where id = :1', [1]).first() (1, u'admin', u'admin@localhost') For more information about SQLAlchemy, head over to the website <https://www.sqlalchemy.org/> _.","title":"SQL Abstraction Layer"},{"location":"patterns/sqlite3/","text":".. _sqlite3: Using SQLite 3 with Flask \u00b6 In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request). Here is a simple example of how you can use SQLite 3 with Flask:: import sqlite3 from flask import g DATABASE = '/path/to/database.db' def get_db (): db = getattr ( g , '_database' , None ) if db is None : db = g . _database = sqlite3 . connect ( DATABASE ) return db @app.teardown_appcontext def close_connection ( exception ): db = getattr ( g , '_database' , None ) if db is not None : db . close () Now, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the get_db function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated. Note: if you use Flask 0.9 or older you need to use flask._app_ctx_stack.top instead of g as the :data: flask.g object was bound to the request and not application context. Example:: @app.route('/') def index(): cur = get_db().cursor() ... .. note:: Please keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it. Connect on Demand \u00b6 The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:: with app.app_context(): # now you can use get_db() .. _easy-querying: Easy Querying \u00b6 Now in each request handling function you can access get_db() to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the get_db function we created above:: def make_dicts(cursor, row): return dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) db.row_factory = make_dicts This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in get_db instead:: db.row_factory = sqlite3.Row This would use Row objects rather than dicts to return the results of queries. These are namedtuple s, so we can access them either by index or by key. For example, assuming we have a sqlite3.Row called r for the rows id , FirstName , LastName , and MiddleInitial :: &gt;&gt;&gt; # You can get values based on the row's name &gt;&gt;&gt; r['FirstName'] John &gt;&gt;&gt; # Or, you can get them based on index &gt;&gt;&gt; r[1] John # Row objects are also iterable: &gt;&gt;&gt; for value in r: ... print(value) 1 John Doe M Additionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results:: def query_db(query, args=(), one=False): cur = get_db().execute(query, args) rv = cur.fetchall() cur.close() return (rv[0] if rv else None) if one else rv This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects. Here is how you can use it:: for user in query_db('select * from users'): print user['username'], 'has the id', user['user_id'] Or if you just want a single result:: user = query_db('select * from users where username = ?', [the_username], one=True) if user is None: print 'No such user' else: print the_username, 'has the id', user['user_id'] To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using SQL Injections <https://en.wikipedia.org/wiki/SQL_injection> _. Initial Schemas \u00b6 Relational databases need schemas, so applications often ship a schema.sql file that creates the database. It's a good idea to provide a function that creates the database based on that schema. This function can do that for you:: def init_db(): with app.app_context(): db = get_db() with app.open_resource('schema.sql', mode='r') as f: db.cursor().executescript(f.read()) db.commit() You can then create such a database from the Python shell: from yourapplication import init_db init_db()","title":"Sqlite3"},{"location":"patterns/sqlite3/#using-sqlite-3-with-flask","text":"In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request). Here is a simple example of how you can use SQLite 3 with Flask:: import sqlite3 from flask import g DATABASE = '/path/to/database.db' def get_db (): db = getattr ( g , '_database' , None ) if db is None : db = g . _database = sqlite3 . connect ( DATABASE ) return db @app.teardown_appcontext def close_connection ( exception ): db = getattr ( g , '_database' , None ) if db is not None : db . close () Now, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the get_db function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated. Note: if you use Flask 0.9 or older you need to use flask._app_ctx_stack.top instead of g as the :data: flask.g object was bound to the request and not application context. Example:: @app.route('/') def index(): cur = get_db().cursor() ... .. note:: Please keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it.","title":"Using SQLite 3 with Flask"},{"location":"patterns/sqlite3/#connect-on-demand","text":"The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:: with app.app_context(): # now you can use get_db() .. _easy-querying:","title":"Connect on Demand"},{"location":"patterns/sqlite3/#easy-querying","text":"Now in each request handling function you can access get_db() to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the get_db function we created above:: def make_dicts(cursor, row): return dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) db.row_factory = make_dicts This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in get_db instead:: db.row_factory = sqlite3.Row This would use Row objects rather than dicts to return the results of queries. These are namedtuple s, so we can access them either by index or by key. For example, assuming we have a sqlite3.Row called r for the rows id , FirstName , LastName , and MiddleInitial :: &gt;&gt;&gt; # You can get values based on the row's name &gt;&gt;&gt; r['FirstName'] John &gt;&gt;&gt; # Or, you can get them based on index &gt;&gt;&gt; r[1] John # Row objects are also iterable: &gt;&gt;&gt; for value in r: ... print(value) 1 John Doe M Additionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results:: def query_db(query, args=(), one=False): cur = get_db().execute(query, args) rv = cur.fetchall() cur.close() return (rv[0] if rv else None) if one else rv This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects. Here is how you can use it:: for user in query_db('select * from users'): print user['username'], 'has the id', user['user_id'] Or if you just want a single result:: user = query_db('select * from users where username = ?', [the_username], one=True) if user is None: print 'No such user' else: print the_username, 'has the id', user['user_id'] To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using SQL Injections <https://en.wikipedia.org/wiki/SQL_injection> _.","title":"Easy Querying"},{"location":"patterns/sqlite3/#initial-schemas","text":"Relational databases need schemas, so applications often ship a schema.sql file that creates the database. It's a good idea to provide a function that creates the database based on that schema. This function can do that for you:: def init_db(): with app.app_context(): db = get_db() with app.open_resource('schema.sql', mode='r') as f: db.cursor().executescript(f.read()) db.commit() You can then create such a database from the Python shell: from yourapplication import init_db init_db()","title":"Initial Schemas"},{"location":"patterns/streaming/","text":"Streaming Contents \u00b6 Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem? The answer is by using generators and direct responses. Basic Usage \u00b6 This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:: from flask import Response @app.route ( '/large.csv' ) def generate_large_csv (): def generate (): for row in iter_all_rows (): yield ',' . join ( row ) + ' \\n ' return Response ( generate (), mimetype = 'text/csv' ) Each yield expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled. Streaming from Templates \u00b6 The Jinja2 template engine also supports rendering templates piece by piece. This functionality is not directly exposed by Flask because it is quite uncommon, but you can easily do it yourself:: from flask import Response def stream_template ( template_name , ** context ): app . update_template_context ( context ) t = app . jinja_env . get_template ( template_name ) rv = t . stream ( context ) rv . enable_buffering ( 5 ) return rv @app.route ( '/my-large-page.html' ) def render_large_template (): rows = iter_all_rows () return Response ( stream_template ( 'the_template.html' , rows = rows )) The trick here is to get the template object from the Jinja2 environment on the application and to call :meth: ~jinja2.Template.stream instead of :meth: ~jinja2.Template.render which returns a stream object instead of a string. Since we're bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling :meth: ~flask.Flask.update_template_context . The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with rv.enable_buffering(size) . 5 is a sane default. Streaming with Context \u00b6 .. versionadded:: 0.9 Note that when you stream data, the request context is already gone the moment the function executes. Flask 0.9 provides you with a helper that can keep the request context around during the execution of the generator:: from flask import stream_with_context , request , Response @app.route ( '/stream' ) def streamed_response (): def generate (): yield 'Hello ' yield request . args [ 'name' ] yield '!' return Response ( stream_with_context ( generate ())) Without the :func: ~flask.stream_with_context function you would get a :class: RuntimeError at that point.","title":"Streaming Contents"},{"location":"patterns/streaming/#streaming-contents","text":"Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem? The answer is by using generators and direct responses.","title":"Streaming Contents"},{"location":"patterns/streaming/#basic-usage","text":"This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:: from flask import Response @app.route ( '/large.csv' ) def generate_large_csv (): def generate (): for row in iter_all_rows (): yield ',' . join ( row ) + ' \\n ' return Response ( generate (), mimetype = 'text/csv' ) Each yield expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled.","title":"Basic Usage"},{"location":"patterns/streaming/#streaming-from-templates","text":"The Jinja2 template engine also supports rendering templates piece by piece. This functionality is not directly exposed by Flask because it is quite uncommon, but you can easily do it yourself:: from flask import Response def stream_template ( template_name , ** context ): app . update_template_context ( context ) t = app . jinja_env . get_template ( template_name ) rv = t . stream ( context ) rv . enable_buffering ( 5 ) return rv @app.route ( '/my-large-page.html' ) def render_large_template (): rows = iter_all_rows () return Response ( stream_template ( 'the_template.html' , rows = rows )) The trick here is to get the template object from the Jinja2 environment on the application and to call :meth: ~jinja2.Template.stream instead of :meth: ~jinja2.Template.render which returns a stream object instead of a string. Since we're bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling :meth: ~flask.Flask.update_template_context . The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with rv.enable_buffering(size) . 5 is a sane default.","title":"Streaming from Templates"},{"location":"patterns/streaming/#streaming-with-context","text":".. versionadded:: 0.9 Note that when you stream data, the request context is already gone the moment the function executes. Flask 0.9 provides you with a helper that can keep the request context around during the execution of the generator:: from flask import stream_with_context , request , Response @app.route ( '/stream' ) def streamed_response (): def generate (): yield 'Hello ' yield request . args [ 'name' ] yield '!' return Response ( stream_with_context ( generate ())) Without the :func: ~flask.stream_with_context function you would get a :class: RuntimeError at that point.","title":"Streaming with Context"},{"location":"patterns/subclassing/","text":"Subclassing Flask \u00b6 The :class: ~flask.Flask class is designed for subclassing. For example, you may want to override how request parameters are handled to preserve their order:: from flask import Flask , Request from werkzeug.datastructures import ImmutableOrderedMultiDict class MyRequest ( Request ): \"\"\"Request subclass to override request parameter storage\"\"\" parameter_storage_class = ImmutableOrderedMultiDict class MyFlask ( Flask ): \"\"\"Flask subclass using the custom request class\"\"\" request_class = MyRequest This is the recommended approach for overriding or augmenting Flask's internal functionality.","title":"Subclassing Flask"},{"location":"patterns/subclassing/#subclassing-flask","text":"The :class: ~flask.Flask class is designed for subclassing. For example, you may want to override how request parameters are handled to preserve their order:: from flask import Flask , Request from werkzeug.datastructures import ImmutableOrderedMultiDict class MyRequest ( Request ): \"\"\"Request subclass to override request parameter storage\"\"\" parameter_storage_class = ImmutableOrderedMultiDict class MyFlask ( Flask ): \"\"\"Flask subclass using the custom request class\"\"\" request_class = MyRequest This is the recommended approach for overriding or augmenting Flask's internal functionality.","title":"Subclassing Flask"},{"location":"patterns/templateinheritance/","text":".. _template-inheritance: Template Inheritance \u00b6 The most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base \"skeleton\" template that contains all the common elements of your site and defines blocks that child templates can override. Sounds complicated but is very basic. It's easiest to understand it by starting with an example. Base Template \u00b6 This template, which we'll call :file: layout.html , defines a simple HTML skeleton document that you might use for a simple two-column page. It's the job of \"child\" templates to fill the empty blocks with content: .. sourcecode:: html+jinja &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; {% block head %} &lt;link rel=\"stylesheet\" href=\" {{ url_for ( 'static' , filename = 'style.css' ) }} \"&gt; &lt;title&gt; {% block title %}{% endblock %} - My Webpage&lt;/title&gt; {% endblock %} &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt; {% block content %}{% endblock %} &lt;/div&gt; &lt;div id=\"footer\"&gt; {% block footer %} &amp;copy; Copyright 2010 by &lt;a href=\"http://domain.invalid/\"&gt;you&lt;/a&gt;. {% endblock %} &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; In this example, the {% block %} tags define four blocks that child templates can fill in. All the block tag does is tell the template engine that a child template may override those portions of the template. Child Template \u00b6 A child template might look like this: .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block title %} Index {% endblock %} {% block head %} {{ super () }} &lt;style type=\"text/css\"&gt; .important { color: #336699; } &lt;/style&gt; {% endblock %} {% block content %} &lt;h1&gt;Index&lt;/h1&gt; &lt;p class=\"important\"&gt; Welcome on my awesome homepage. {% endblock %} The {% extends %} tag is the key here. It tells the template engine that this template \"extends\" another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use {{ super() }} .","title":"Templateinheritance"},{"location":"patterns/templateinheritance/#template-inheritance","text":"The most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base \"skeleton\" template that contains all the common elements of your site and defines blocks that child templates can override. Sounds complicated but is very basic. It's easiest to understand it by starting with an example.","title":"Template Inheritance"},{"location":"patterns/templateinheritance/#base-template","text":"This template, which we'll call :file: layout.html , defines a simple HTML skeleton document that you might use for a simple two-column page. It's the job of \"child\" templates to fill the empty blocks with content: .. sourcecode:: html+jinja &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; {% block head %} &lt;link rel=\"stylesheet\" href=\" {{ url_for ( 'static' , filename = 'style.css' ) }} \"&gt; &lt;title&gt; {% block title %}{% endblock %} - My Webpage&lt;/title&gt; {% endblock %} &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt; {% block content %}{% endblock %} &lt;/div&gt; &lt;div id=\"footer\"&gt; {% block footer %} &amp;copy; Copyright 2010 by &lt;a href=\"http://domain.invalid/\"&gt;you&lt;/a&gt;. {% endblock %} &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; In this example, the {% block %} tags define four blocks that child templates can fill in. All the block tag does is tell the template engine that a child template may override those portions of the template.","title":"Base Template"},{"location":"patterns/templateinheritance/#child-template","text":"A child template might look like this: .. sourcecode:: html+jinja {% extends \"layout.html\" %} {% block title %} Index {% endblock %} {% block head %} {{ super () }} &lt;style type=\"text/css\"&gt; .important { color: #336699; } &lt;/style&gt; {% endblock %} {% block content %} &lt;h1&gt;Index&lt;/h1&gt; &lt;p class=\"important\"&gt; Welcome on my awesome homepage. {% endblock %} The {% extends %} tag is the key here. It tells the template engine that this template \"extends\" another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use {{ super() }} .","title":"Child Template"},{"location":"patterns/urlprocessors/","text":"Using URL Processors \u00b6 .. versionadded:: 0.7 Flask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don't always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don't want to have to handle it in every single function yourself. URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics. Internationalized Application URLs \u00b6 Consider an application like this:: from flask import Flask , g app = Flask ( __name__ ) @app.route ( '/&lt;lang_code&gt;/' ) def index ( lang_code ): g . lang_code = lang_code ... @app.route ( '/&lt;lang_code&gt;/about' ) def about ( lang_code ): g . lang_code = lang_code ... This is an awful lot of repetition as you have to handle the language code setting on the :data: ~flask.g object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying. For the latter, this is where :func: ~flask.Flask.url_defaults functions come in. They can automatically inject values into a call for :func: ~flask.url_for automatically. The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named 'lang_code' :: @app.url_defaults def add_language_code(endpoint, values): if 'lang_code' in values or not g.lang_code: return if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'): values['lang_code'] = g.lang_code The method :meth: ~werkzeug.routing.Map.is_endpoint_expecting of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint. The reverse of that function are :meth: ~flask.Flask.url_value_preprocessor \\s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else:: @app.url_value_preprocessor def pull_lang_code(endpoint, values): g.lang_code = values.pop('lang_code', None) That way you no longer have to do the lang_code assignment to :data: ~flask.g in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the 'lang_code' is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this:: from flask import Flask , g app = Flask ( __name__ ) @app.url_defaults def add_language_code ( endpoint , values ): if 'lang_code' in values or not g . lang_code : return if app . url_map . is_endpoint_expecting ( endpoint , 'lang_code' ): values [ 'lang_code' ] = g . lang_code @app.url_value_preprocessor def pull_lang_code ( endpoint , values ): g . lang_code = values . pop ( 'lang_code' , None ) @app.route ( '/&lt;lang_code&gt;/' ) def index (): ... @app.route ( '/&lt;lang_code&gt;/about' ) def about (): ... Internationalized Blueprint URLs \u00b6 Because blueprints can automatically prefix all URLs with a common string it's easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the :meth: ~flask.Flask.url_defaults function because it no longer has to check if the URL is really interested in a 'lang_code' parameter:: from flask import Blueprint , g bp = Blueprint ( 'frontend' , __name__ , url_prefix = '/&lt;lang_code&gt;' ) @bp.url_defaults def add_language_code ( endpoint , values ): values . setdefault ( 'lang_code' , g . lang_code ) @bp.url_value_preprocessor def pull_lang_code ( endpoint , values ): g . lang_code = values . pop ( 'lang_code' ) @bp.route ( '/' ) def index (): ... @bp.route ( '/about' ) def about (): ...","title":"Using URL Processors"},{"location":"patterns/urlprocessors/#using-url-processors","text":".. versionadded:: 0.7 Flask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don't always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don't want to have to handle it in every single function yourself. URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics.","title":"Using URL Processors"},{"location":"patterns/urlprocessors/#internationalized-application-urls","text":"Consider an application like this:: from flask import Flask , g app = Flask ( __name__ ) @app.route ( '/&lt;lang_code&gt;/' ) def index ( lang_code ): g . lang_code = lang_code ... @app.route ( '/&lt;lang_code&gt;/about' ) def about ( lang_code ): g . lang_code = lang_code ... This is an awful lot of repetition as you have to handle the language code setting on the :data: ~flask.g object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying. For the latter, this is where :func: ~flask.Flask.url_defaults functions come in. They can automatically inject values into a call for :func: ~flask.url_for automatically. The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named 'lang_code' :: @app.url_defaults def add_language_code(endpoint, values): if 'lang_code' in values or not g.lang_code: return if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'): values['lang_code'] = g.lang_code The method :meth: ~werkzeug.routing.Map.is_endpoint_expecting of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint. The reverse of that function are :meth: ~flask.Flask.url_value_preprocessor \\s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else:: @app.url_value_preprocessor def pull_lang_code(endpoint, values): g.lang_code = values.pop('lang_code', None) That way you no longer have to do the lang_code assignment to :data: ~flask.g in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the 'lang_code' is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this:: from flask import Flask , g app = Flask ( __name__ ) @app.url_defaults def add_language_code ( endpoint , values ): if 'lang_code' in values or not g . lang_code : return if app . url_map . is_endpoint_expecting ( endpoint , 'lang_code' ): values [ 'lang_code' ] = g . lang_code @app.url_value_preprocessor def pull_lang_code ( endpoint , values ): g . lang_code = values . pop ( 'lang_code' , None ) @app.route ( '/&lt;lang_code&gt;/' ) def index (): ... @app.route ( '/&lt;lang_code&gt;/about' ) def about (): ...","title":"Internationalized Application URLs"},{"location":"patterns/urlprocessors/#internationalized-blueprint-urls","text":"Because blueprints can automatically prefix all URLs with a common string it's easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the :meth: ~flask.Flask.url_defaults function because it no longer has to check if the URL is really interested in a 'lang_code' parameter:: from flask import Blueprint , g bp = Blueprint ( 'frontend' , __name__ , url_prefix = '/&lt;lang_code&gt;' ) @bp.url_defaults def add_language_code ( endpoint , values ): values . setdefault ( 'lang_code' , g . lang_code ) @bp.url_value_preprocessor def pull_lang_code ( endpoint , values ): g . lang_code = values . pop ( 'lang_code' ) @bp.route ( '/' ) def index (): ... @bp.route ( '/about' ) def about (): ...","title":"Internationalized Blueprint URLs"},{"location":"patterns/viewdecorators/","text":"View Decorators \u00b6 Python has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The :meth: ~flask.Flask.route decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution. Login Required Decorator \u00b6 So let's implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function's information to the new function. Use :func: functools.wraps to handle this for you. This example assumes that the login page is called 'login' and that the current user is stored in g.user and is None if there is no-one logged in. :: from functools import wraps from flask import g , request , redirect , url_for def login_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): if g . user is None : return redirect ( url_for ( 'login' , next = request . url )) return f ( * args , ** kwargs ) return decorated_function To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the :meth: ~flask.Flask.route decorator is the outermost. :: @app.route('/secret_page') @login_required def secret_page(): pass .. note:: The next value will exist in request.args after a GET request for the login page. You'll have to pass it along when sending the POST request from the login form. You can do this with a hidden input tag, then retrieve it from request.form when logging the user in. :: &lt;input type=\"hidden\" value=\" {{ request.args.get ( 'next' , '' ) }} \"/&gt; Caching Decorator \u00b6 Imagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We're assuming you have set up a cache like mentioned in :ref: caching-pattern . Here is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read. The decorated function will then work as follows get the unique cache key for the current request base on the current path. get the value for that key from the cache. If the cache returned something we will return that value. otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes). Here the code:: from functools import wraps from flask import request def cached ( timeout = 5 * 60 , key = 'view/ %s ' ): def decorator ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): cache_key = key % request . path rv = cache . get ( cache_key ) if rv is not None : return rv rv = f ( * args , ** kwargs ) cache . set ( cache_key , rv , timeout = timeout ) return rv return decorated_function return decorator Notice that this assumes an instantiated cache object is available, see :ref: caching-pattern for more information. Templating Decorator \u00b6 A common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same:: @app.route('/') def index(): return render_template('index.html', value=42) @app.route('/') @templated('index.html') def index(): return dict(value=42) @app.route('/') @templated() def index(): return dict(value=42) As you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + '.html' . Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If None is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings. Here is the code for that decorator:: from functools import wraps from flask import request , render_template def templated ( template = None ): def decorator ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): template_name = template if template_name is None : template_name = request . endpoint \\ . replace ( '.' , '/' ) + '.html' ctx = f ( * args , ** kwargs ) if ctx is None : ctx = {} elif not isinstance ( ctx , dict ): return ctx return render_template ( template_name , ** ctx ) return decorated_function return decorator Endpoint Decorator \u00b6 When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the :class: ~werkzeug.routing.Rule to a view function. This is possible with this decorator. For example:: from flask import Flask from werkzeug.routing import Rule app = Flask ( __name__ ) app . url_map . add ( Rule ( '/' , endpoint = 'index' )) @app.endpoint ( 'index' ) def my_index (): return \"Hello world\"","title":"View Decorators"},{"location":"patterns/viewdecorators/#view-decorators","text":"Python has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The :meth: ~flask.Flask.route decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution.","title":"View Decorators"},{"location":"patterns/viewdecorators/#login-required-decorator","text":"So let's implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function's information to the new function. Use :func: functools.wraps to handle this for you. This example assumes that the login page is called 'login' and that the current user is stored in g.user and is None if there is no-one logged in. :: from functools import wraps from flask import g , request , redirect , url_for def login_required ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): if g . user is None : return redirect ( url_for ( 'login' , next = request . url )) return f ( * args , ** kwargs ) return decorated_function To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the :meth: ~flask.Flask.route decorator is the outermost. :: @app.route('/secret_page') @login_required def secret_page(): pass .. note:: The next value will exist in request.args after a GET request for the login page. You'll have to pass it along when sending the POST request from the login form. You can do this with a hidden input tag, then retrieve it from request.form when logging the user in. :: &lt;input type=\"hidden\" value=\" {{ request.args.get ( 'next' , '' ) }} \"/&gt;","title":"Login Required Decorator"},{"location":"patterns/viewdecorators/#caching-decorator","text":"Imagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We're assuming you have set up a cache like mentioned in :ref: caching-pattern . Here is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read. The decorated function will then work as follows get the unique cache key for the current request base on the current path. get the value for that key from the cache. If the cache returned something we will return that value. otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes). Here the code:: from functools import wraps from flask import request def cached ( timeout = 5 * 60 , key = 'view/ %s ' ): def decorator ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): cache_key = key % request . path rv = cache . get ( cache_key ) if rv is not None : return rv rv = f ( * args , ** kwargs ) cache . set ( cache_key , rv , timeout = timeout ) return rv return decorated_function return decorator Notice that this assumes an instantiated cache object is available, see :ref: caching-pattern for more information.","title":"Caching Decorator"},{"location":"patterns/viewdecorators/#templating-decorator","text":"A common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same:: @app.route('/') def index(): return render_template('index.html', value=42) @app.route('/') @templated('index.html') def index(): return dict(value=42) @app.route('/') @templated() def index(): return dict(value=42) As you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + '.html' . Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If None is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings. Here is the code for that decorator:: from functools import wraps from flask import request , render_template def templated ( template = None ): def decorator ( f ): @wraps ( f ) def decorated_function ( * args , ** kwargs ): template_name = template if template_name is None : template_name = request . endpoint \\ . replace ( '.' , '/' ) + '.html' ctx = f ( * args , ** kwargs ) if ctx is None : ctx = {} elif not isinstance ( ctx , dict ): return ctx return render_template ( template_name , ** ctx ) return decorated_function return decorator","title":"Templating Decorator"},{"location":"patterns/viewdecorators/#endpoint-decorator","text":"When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the :class: ~werkzeug.routing.Rule to a view function. This is possible with this decorator. For example:: from flask import Flask from werkzeug.routing import Rule app = Flask ( __name__ ) app . url_map . add ( Rule ( '/' , endpoint = 'index' )) @app.endpoint ( 'index' ) def my_index (): return \"Hello world\"","title":"Endpoint Decorator"},{"location":"patterns/wtforms/","text":"Form Validation with WTForms \u00b6 When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms _ which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try. When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (:ref: larger-applications ) for that and adding a separate module for the forms. .. admonition:: Getting the most out of WTForms with an Extension The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI <https://pypi.org/project/Flask-WTF/> . .. _Flask-WTF: https://flask-wtf.readthedocs.io/en/stable/ The Forms \u00b6 This is an example form for a typical registration page:: from wtforms import Form , BooleanField , StringField , PasswordField , validators class RegistrationForm ( Form ): username = StringField ( 'Username' , [ validators . Length ( min = 4 , max = 25 )]) email = StringField ( 'Email Address' , [ validators . Length ( min = 6 , max = 35 )]) password = PasswordField ( 'New Password' , [ validators . DataRequired (), validators . EqualTo ( 'confirm' , message = 'Passwords must match' ) ]) confirm = PasswordField ( 'Repeat Password' ) accept_tos = BooleanField ( 'I accept the TOS' , [ validators . DataRequired ()]) In the View \u00b6 In the view function, the usage of this form looks like this:: @app.route('/register', methods=['GET', 'POST']) def register(): form = RegistrationForm(request.form) if request.method == 'POST' and form.validate(): user = User(form.username.data, form.email.data, form.password.data) db_session.add(user) flash('Thanks for registering') return redirect(url_for('login')) return render_template('register.html', form=form) Notice we're implying that the view is using SQLAlchemy here (:ref: sqlalchemy-pattern ), but that's not a requirement, of course. Adapt the code as necessary. Things to remember: create the form from the request :attr: ~flask.request.form value if the data is submitted via the HTTP POST method and :attr: ~flask.request.args if the data is submitted as GET . to validate the data, call the :func: ~wtforms.form.Form.validate method, which will return True if the data validates, False otherwise. to access individual values from the form, access form.<NAME>.data . Forms in Templates \u00b6 Now to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any. Here's an example :file: _formhelpers.html template with such a macro: .. sourcecode:: html+jinja {% macro render_field ( field ) %} &lt;dt&gt; {{ field.label }} &lt;dd&gt; {{ field (** kwargs )| safe }} {% if field.errors %} &lt;ul class=errors&gt; {% for error in field.errors %} &lt;li&gt; {{ error }} &lt;/li&gt; {% endfor %} &lt;/ul&gt; {% endif %} &lt;/dd&gt; {% endmacro %} This macro accepts a couple of keyword arguments that are forwarded to WTForm's field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call render_field(form.username, class='username') to add a class to the input element. Note that WTForms returns standard Python unicode strings, so we have to tell Jinja2 that this data is already HTML-escaped with the |safe filter. Here is the :file: register.html template for the function we used above, which takes advantage of the :file: _formhelpers.html template: .. sourcecode:: html+jinja { % from \"_formhelpers.html\" import render_field % } & lt ; form method = post & gt ; & lt ; dl & gt ; {{ render_field ( form . username ) }} {{ render_field ( form . email ) }} {{ render_field ( form . password ) }} {{ render_field ( form . confirm ) }} {{ render_field ( form . accept_tos ) }} & lt ; / dl & gt ; & lt ; p & gt ; & lt ; input type = submit value = Register & gt ; & lt ; / form & gt ; For more information about WTForms, head over to the WTForms website _. .. _WTForms: https://wtforms.readthedocs.io/ .. _WTForms website: https://wtforms.readthedocs.io/","title":"Form Validation with WTForms"},{"location":"patterns/wtforms/#form-validation-with-wtforms","text":"When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms _ which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try. When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (:ref: larger-applications ) for that and adding a separate module for the forms. .. admonition:: Getting the most out of WTForms with an Extension The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI <https://pypi.org/project/Flask-WTF/> . .. _Flask-WTF: https://flask-wtf.readthedocs.io/en/stable/","title":"Form Validation with WTForms"},{"location":"patterns/wtforms/#the-forms","text":"This is an example form for a typical registration page:: from wtforms import Form , BooleanField , StringField , PasswordField , validators class RegistrationForm ( Form ): username = StringField ( 'Username' , [ validators . Length ( min = 4 , max = 25 )]) email = StringField ( 'Email Address' , [ validators . Length ( min = 6 , max = 35 )]) password = PasswordField ( 'New Password' , [ validators . DataRequired (), validators . EqualTo ( 'confirm' , message = 'Passwords must match' ) ]) confirm = PasswordField ( 'Repeat Password' ) accept_tos = BooleanField ( 'I accept the TOS' , [ validators . DataRequired ()])","title":"The Forms"},{"location":"patterns/wtforms/#in-the-view","text":"In the view function, the usage of this form looks like this:: @app.route('/register', methods=['GET', 'POST']) def register(): form = RegistrationForm(request.form) if request.method == 'POST' and form.validate(): user = User(form.username.data, form.email.data, form.password.data) db_session.add(user) flash('Thanks for registering') return redirect(url_for('login')) return render_template('register.html', form=form) Notice we're implying that the view is using SQLAlchemy here (:ref: sqlalchemy-pattern ), but that's not a requirement, of course. Adapt the code as necessary. Things to remember: create the form from the request :attr: ~flask.request.form value if the data is submitted via the HTTP POST method and :attr: ~flask.request.args if the data is submitted as GET . to validate the data, call the :func: ~wtforms.form.Form.validate method, which will return True if the data validates, False otherwise. to access individual values from the form, access form.<NAME>.data .","title":"In the View"},{"location":"patterns/wtforms/#forms-in-templates","text":"Now to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any. Here's an example :file: _formhelpers.html template with such a macro: .. sourcecode:: html+jinja {% macro render_field ( field ) %} &lt;dt&gt; {{ field.label }} &lt;dd&gt; {{ field (** kwargs )| safe }} {% if field.errors %} &lt;ul class=errors&gt; {% for error in field.errors %} &lt;li&gt; {{ error }} &lt;/li&gt; {% endfor %} &lt;/ul&gt; {% endif %} &lt;/dd&gt; {% endmacro %} This macro accepts a couple of keyword arguments that are forwarded to WTForm's field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call render_field(form.username, class='username') to add a class to the input element. Note that WTForms returns standard Python unicode strings, so we have to tell Jinja2 that this data is already HTML-escaped with the |safe filter. Here is the :file: register.html template for the function we used above, which takes advantage of the :file: _formhelpers.html template: .. sourcecode:: html+jinja { % from \"_formhelpers.html\" import render_field % } & lt ; form method = post & gt ; & lt ; dl & gt ; {{ render_field ( form . username ) }} {{ render_field ( form . email ) }} {{ render_field ( form . password ) }} {{ render_field ( form . confirm ) }} {{ render_field ( form . accept_tos ) }} & lt ; / dl & gt ; & lt ; p & gt ; & lt ; input type = submit value = Register & gt ; & lt ; / form & gt ; For more information about WTForms, head over to the WTForms website _. .. _WTForms: https://wtforms.readthedocs.io/ .. _WTForms website: https://wtforms.readthedocs.io/","title":"Forms in Templates"},{"location":"tutorial/","text":".. _tutorial: Tutorial \u00b6 .. toctree:: :caption: Contents: :maxdepth: 1 layout factory database views templates static blog install tests deploy next This tutorial will walk you through creating a basic blog application called Flaskr. Users will be able to register, log in, create posts, and edit or delete their own posts. You will be able to package and install the application on other computers. .. image:: flaskr_index.png :align: center :class: screenshot :alt: screenshot of index page It's assumed that you're already familiar with Python. The official tutorial _ in the Python docs is a great way to learn or review first. .. _official tutorial: https://docs.python.org/3/tutorial/ While it's designed to give a good starting point, the tutorial doesn't cover all of Flask's features. Check out the :ref: quickstart for an overview of what Flask can do, then dive into the docs to find out more. The tutorial only uses what's provided by Flask and Python. In another project, you might decide to use :ref: extensions or other libraries to make some tasks simpler. .. image:: flaskr_login.png :align: center :class: screenshot :alt: screenshot of login page Flask is flexible. It doesn't require you to use any particular project or code layout. However, when first starting, it's helpful to use a more structured approach. This means that the tutorial will require a bit of boilerplate up front, but it's done to avoid many common pitfalls that new developers encounter, and it creates a project that's easy to expand on. Once you become more comfortable with Flask, you can step out of this structure and take full advantage of Flask's flexibility. .. image:: flaskr_edit.png :align: center :class: screenshot :alt: screenshot of login page :gh: The tutorial project is available as an example in the Flask repository <examples/tutorial> , if you want to compare your project with the final product as you follow the tutorial. Continue to :doc: layout .","title":"Index"},{"location":"tutorial/#tutorial","text":".. toctree:: :caption: Contents: :maxdepth: 1 layout factory database views templates static blog install tests deploy next This tutorial will walk you through creating a basic blog application called Flaskr. Users will be able to register, log in, create posts, and edit or delete their own posts. You will be able to package and install the application on other computers. .. image:: flaskr_index.png :align: center :class: screenshot :alt: screenshot of index page It's assumed that you're already familiar with Python. The official tutorial _ in the Python docs is a great way to learn or review first. .. _official tutorial: https://docs.python.org/3/tutorial/ While it's designed to give a good starting point, the tutorial doesn't cover all of Flask's features. Check out the :ref: quickstart for an overview of what Flask can do, then dive into the docs to find out more. The tutorial only uses what's provided by Flask and Python. In another project, you might decide to use :ref: extensions or other libraries to make some tasks simpler. .. image:: flaskr_login.png :align: center :class: screenshot :alt: screenshot of login page Flask is flexible. It doesn't require you to use any particular project or code layout. However, when first starting, it's helpful to use a more structured approach. This means that the tutorial will require a bit of boilerplate up front, but it's done to avoid many common pitfalls that new developers encounter, and it creates a project that's easy to expand on. Once you become more comfortable with Flask, you can step out of this structure and take full advantage of Flask's flexibility. .. image:: flaskr_edit.png :align: center :class: screenshot :alt: screenshot of login page :gh: The tutorial project is available as an example in the Flask repository <examples/tutorial> , if you want to compare your project with the final product as you follow the tutorial. Continue to :doc: layout .","title":"Tutorial"},{"location":"tutorial/blog/","text":".. currentmodule:: flask Blog Blueprint \u00b6 You'll use the same techniques you learned about when writing the authentication blueprint to write the blog blueprint. The blog should list all posts, allow logged in users to create posts, and allow the author of a post to edit or delete it. As you implement each view, keep the development server running. As you save your changes, try going to the URL in your browser and testing them out. The Blueprint \u00b6 Define the blueprint and register it in the application factory. .. code-block:: python :caption: flaskr/blog.py from flask import ( Blueprint , flash , g , redirect , render_template , request , url_for ) from werkzeug.exceptions import abort from flaskr.auth import login_required from flaskr.db import get_db bp = Blueprint ( 'blog' , __name__ ) Import and register the blueprint from the factory using :meth: app.register_blueprint() <Flask.register_blueprint> . Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import blog app . register_blueprint ( blog . bp ) app . add_url_rule ( '/' , endpoint = 'index' ) return app Unlike the auth blueprint, the blog blueprint does not have a url_prefix . So the index view will be at / , the create view at /create , and so on. The blog is the main feature of Flaskr, so it makes sense that the blog index will be the main index. However, the endpoint for the index view defined below will be blog.index . Some of the authentication views referred to a plain index endpoint. :meth: app.add_url_rule() <Flask.add_url_rule> associates the endpoint name 'index' with the / url so that url_for('index') or url_for('blog.index') will both work, generating the same / URL either way. In another application you might give the blog blueprint a url_prefix and define a separate index view in the application factory, similar to the hello view. Then the index and blog.index endpoints and URLs would be different. Index \u00b6 The index will show all of the posts, most recent first. A JOIN is used so that the author information from the user table is available in the result. .. code-block:: python :caption: flaskr/blog.py @bp.route('/') def index(): db = get_db() posts = db.execute( 'SELECT p.id, title, body, created, author_id, username' ' FROM post p JOIN user u ON p.author_id = u.id' ' ORDER BY created DESC' ).fetchall() return render_template('blog/index.html', posts=posts) .. code-block:: html+jinja :caption: flaskr/templates/blog/index.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Posts {% endblock %} &lt;/h1&gt; {% if g.user %} &lt;a class=\"action\" href=\" {{ url_for ( 'blog.create' ) }} \"&gt;New&lt;/a&gt; {% endif %} {% endblock %} {% block content %} {% for post in posts %} &lt;article class=\"post\"&gt; &lt;header&gt; &lt;div&gt; &lt;h1&gt; {{ post [ 'title' ] }} &lt;/h1&gt; &lt;div class=\"about\"&gt;by {{ post [ 'username' ] }} on {{ post [ 'created' ] .strftime ( '%Y-%m-%d' ) }} &lt;/div&gt; &lt;/div&gt; {% if g.user [ 'id' ] == post [ 'author_id' ] %} &lt;a class=\"action\" href=\" {{ url_for ( 'blog.update' , id = post [ 'id' ]) }} \"&gt;Edit&lt;/a&gt; {% endif %} &lt;/header&gt; &lt;p class=\"body\"&gt; {{ post [ 'body' ] }} &lt;/p&gt; &lt;/article&gt; {% if not loop .last %} &lt;hr&gt; {% endif %} {% endfor %} {% endblock %} When a user is logged in, the header block adds a link to the create view. When the user is the author of a post, they'll see an \"Edit\" link to the update view for that post. loop.last is a special variable available inside Jinja for loops _. It's used to display a line after each post except the last one, to visually separate them. .. _Jinja for loops: http://jinja.pocoo.org/docs/templates/#for Create \u00b6 The create view works the same as the auth register view. Either the form is displayed, or the posted data is validated and the post is added to the database or an error is shown. The login_required decorator you wrote earlier is used on the blog views. A user must be logged in to visit these views, otherwise they will be redirected to the login page. .. code-block:: python :caption: flaskr/blog.py @bp.route('/create', methods=('GET', 'POST')) @login_required def create(): if request.method == 'POST': title = request.form['title'] body = request.form['body'] error = None if not title: error = 'Title is required.' if error is not None: flash(error) else: db = get_db() db.execute( 'INSERT INTO post (title, body, author_id)' ' VALUES (?, ?, ?)', (title, body, g.user['id']) ) db.commit() return redirect(url_for('blog.index')) return render_template('blog/create.html') .. code-block:: html+jinja :caption: flaskr/templates/blog/create.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} New Post {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"title\"&gt;Title&lt;/label&gt; &lt;input name=\"title\" id=\"title\" value=\" {{ request.form [ 'title' ] }} \" required&gt; &lt;label for=\"body\"&gt;Body&lt;/label&gt; &lt;textarea name=\"body\" id=\"body\"&gt; {{ request.form [ 'body' ] }} &lt;/textarea&gt; &lt;input type=\"submit\" value=\"Save\"&gt; &lt;/form&gt; {% endblock %} Update \u00b6 Both the update and delete views will need to fetch a post by id and check if the author matches the logged in user. To avoid duplicating code, you can write a function to get the post and call it from each view. .. code-block:: python :caption: flaskr/blog.py def get_post(id, check_author=True): post = get_db().execute( 'SELECT p.id, title, body, created, author_id, username' ' FROM post p JOIN user u ON p.author_id = u.id' ' WHERE p.id = ?', (id,) ).fetchone() if post is None: abort(404, \"Post id {0} doesn't exist.\".format(id)) if check_author and post['author_id'] != g.user['id']: abort(403) return post :func: abort will raise a special exception that returns an HTTP status code. It takes an optional message to show with the error, otherwise a default message is used. 404 means \"Not Found\", and 403 means \"Forbidden\". ( 401 means \"Unauthorized\", but you redirect to the login page instead of returning that status.) The check_author argument is defined so that the function can be used to get a post without checking the author. This would be useful if you wrote a view to show an individual post on a page, where the user doesn't matter because they're not modifying the post. .. code-block:: python :caption: flaskr/blog.py @ bp . route ( '/&lt;int:id&gt;/update' , methods =( 'GET' , 'POST' )) @ login_required def update ( id ): post = get_post ( id ) if request . method == 'POST' : title = request . form [ 'title' ] body = request . form [ 'body' ] error = None if not title : error = 'Title is required.' if error is not None : flash ( error ) else : db = get_db () db . execute ( 'UPDATE post SET title = ?, body = ?' ' WHERE id = ?' , ( title , body , id ) ) db . commit () return redirect ( url_for ( 'blog.index' )) return render_template ( 'blog/update.html' , post = post ) Unlike the views you've written so far, the update function takes an argument, id . That corresponds to the <int:id> in the route. A real URL will look like /1/update . Flask will capture the 1 , ensure it's an :class: int , and pass it as the id argument. If you don't specify int: and instead do <id> , it will be a string. To generate a URL to the update page, :func: url_for needs to be passed the id so it knows what to fill in: url_for('blog.update', id=post['id']) . This is also in the index.html file above. The create and update views look very similar. The main difference is that the update view uses a post object and an UPDATE query instead of an INSERT . With some clever refactoring, you could use one view and template for both actions, but for the tutorial it's clearer to keep them separate. .. code-block:: html+jinja :caption: flaskr/templates/blog/update.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Edit \" {{ post [ 'title' ] }} \" {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"title\"&gt;Title&lt;/label&gt; &lt;input name=\"title\" id=\"title\" value=\" {{ request.form [ 'title' ] or post [ 'title' ] }} \" required&gt; &lt;label for=\"body\"&gt;Body&lt;/label&gt; &lt;textarea name=\"body\" id=\"body\"&gt; {{ request.form [ 'body' ] or post [ 'body' ] }} &lt;/textarea&gt; &lt;input type=\"submit\" value=\"Save\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;form action=\" {{ url_for ( 'blog.delete' , id = post [ 'id' ]) }} \" method=\"post\"&gt; &lt;input class=\"danger\" type=\"submit\" value=\"Delete\" onclick=\"return confirm('Are you sure?');\"&gt; &lt;/form&gt; {% endblock %} This template has two forms. The first posts the edited data to the current page ( /<id>/update ). The other form contains only a button and specifies an action attribute that posts to the delete view instead. The button uses some JavaScript to show a confirmation dialog before submitting. The pattern {{ request.form['title'] or post['title'] }} is used to choose what data appears in the form. When the form hasn't been submitted, the original post data appears, but if invalid form data was posted you want to display that so the user can fix the error, so request.form is used instead. :data: request is another variable that's automatically available in templates. Delete \u00b6 The delete view doesn't have its own template, the delete button is part of update.html and posts to the /<id>/delete URL. Since there is no template, it will only handle the POST method and then redirect to the index view. .. code-block:: python :caption: flaskr/blog.py @ bp . route ( '/&lt;int:id&gt;/delete' , methods =( 'POST' ,)) @ login_required def delete ( id ): get_post ( id ) db = get_db () db . execute ( 'DELETE FROM post WHERE id = ?' , ( id ,)) db . commit () return redirect ( url_for ( 'blog.index' )) Congratulations, you've now finished writing your application! Take some time to try out everything in the browser. However, there's still more to do before the project is complete. Continue to :doc: install .","title":"Blog"},{"location":"tutorial/blog/#blog-blueprint","text":"You'll use the same techniques you learned about when writing the authentication blueprint to write the blog blueprint. The blog should list all posts, allow logged in users to create posts, and allow the author of a post to edit or delete it. As you implement each view, keep the development server running. As you save your changes, try going to the URL in your browser and testing them out.","title":"Blog Blueprint"},{"location":"tutorial/blog/#the-blueprint","text":"Define the blueprint and register it in the application factory. .. code-block:: python :caption: flaskr/blog.py from flask import ( Blueprint , flash , g , redirect , render_template , request , url_for ) from werkzeug.exceptions import abort from flaskr.auth import login_required from flaskr.db import get_db bp = Blueprint ( 'blog' , __name__ ) Import and register the blueprint from the factory using :meth: app.register_blueprint() <Flask.register_blueprint> . Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import blog app . register_blueprint ( blog . bp ) app . add_url_rule ( '/' , endpoint = 'index' ) return app Unlike the auth blueprint, the blog blueprint does not have a url_prefix . So the index view will be at / , the create view at /create , and so on. The blog is the main feature of Flaskr, so it makes sense that the blog index will be the main index. However, the endpoint for the index view defined below will be blog.index . Some of the authentication views referred to a plain index endpoint. :meth: app.add_url_rule() <Flask.add_url_rule> associates the endpoint name 'index' with the / url so that url_for('index') or url_for('blog.index') will both work, generating the same / URL either way. In another application you might give the blog blueprint a url_prefix and define a separate index view in the application factory, similar to the hello view. Then the index and blog.index endpoints and URLs would be different.","title":"The Blueprint"},{"location":"tutorial/blog/#index","text":"The index will show all of the posts, most recent first. A JOIN is used so that the author information from the user table is available in the result. .. code-block:: python :caption: flaskr/blog.py @bp.route('/') def index(): db = get_db() posts = db.execute( 'SELECT p.id, title, body, created, author_id, username' ' FROM post p JOIN user u ON p.author_id = u.id' ' ORDER BY created DESC' ).fetchall() return render_template('blog/index.html', posts=posts) .. code-block:: html+jinja :caption: flaskr/templates/blog/index.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Posts {% endblock %} &lt;/h1&gt; {% if g.user %} &lt;a class=\"action\" href=\" {{ url_for ( 'blog.create' ) }} \"&gt;New&lt;/a&gt; {% endif %} {% endblock %} {% block content %} {% for post in posts %} &lt;article class=\"post\"&gt; &lt;header&gt; &lt;div&gt; &lt;h1&gt; {{ post [ 'title' ] }} &lt;/h1&gt; &lt;div class=\"about\"&gt;by {{ post [ 'username' ] }} on {{ post [ 'created' ] .strftime ( '%Y-%m-%d' ) }} &lt;/div&gt; &lt;/div&gt; {% if g.user [ 'id' ] == post [ 'author_id' ] %} &lt;a class=\"action\" href=\" {{ url_for ( 'blog.update' , id = post [ 'id' ]) }} \"&gt;Edit&lt;/a&gt; {% endif %} &lt;/header&gt; &lt;p class=\"body\"&gt; {{ post [ 'body' ] }} &lt;/p&gt; &lt;/article&gt; {% if not loop .last %} &lt;hr&gt; {% endif %} {% endfor %} {% endblock %} When a user is logged in, the header block adds a link to the create view. When the user is the author of a post, they'll see an \"Edit\" link to the update view for that post. loop.last is a special variable available inside Jinja for loops _. It's used to display a line after each post except the last one, to visually separate them. .. _Jinja for loops: http://jinja.pocoo.org/docs/templates/#for","title":"Index"},{"location":"tutorial/blog/#create","text":"The create view works the same as the auth register view. Either the form is displayed, or the posted data is validated and the post is added to the database or an error is shown. The login_required decorator you wrote earlier is used on the blog views. A user must be logged in to visit these views, otherwise they will be redirected to the login page. .. code-block:: python :caption: flaskr/blog.py @bp.route('/create', methods=('GET', 'POST')) @login_required def create(): if request.method == 'POST': title = request.form['title'] body = request.form['body'] error = None if not title: error = 'Title is required.' if error is not None: flash(error) else: db = get_db() db.execute( 'INSERT INTO post (title, body, author_id)' ' VALUES (?, ?, ?)', (title, body, g.user['id']) ) db.commit() return redirect(url_for('blog.index')) return render_template('blog/create.html') .. code-block:: html+jinja :caption: flaskr/templates/blog/create.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} New Post {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"title\"&gt;Title&lt;/label&gt; &lt;input name=\"title\" id=\"title\" value=\" {{ request.form [ 'title' ] }} \" required&gt; &lt;label for=\"body\"&gt;Body&lt;/label&gt; &lt;textarea name=\"body\" id=\"body\"&gt; {{ request.form [ 'body' ] }} &lt;/textarea&gt; &lt;input type=\"submit\" value=\"Save\"&gt; &lt;/form&gt; {% endblock %}","title":"Create"},{"location":"tutorial/blog/#update","text":"Both the update and delete views will need to fetch a post by id and check if the author matches the logged in user. To avoid duplicating code, you can write a function to get the post and call it from each view. .. code-block:: python :caption: flaskr/blog.py def get_post(id, check_author=True): post = get_db().execute( 'SELECT p.id, title, body, created, author_id, username' ' FROM post p JOIN user u ON p.author_id = u.id' ' WHERE p.id = ?', (id,) ).fetchone() if post is None: abort(404, \"Post id {0} doesn't exist.\".format(id)) if check_author and post['author_id'] != g.user['id']: abort(403) return post :func: abort will raise a special exception that returns an HTTP status code. It takes an optional message to show with the error, otherwise a default message is used. 404 means \"Not Found\", and 403 means \"Forbidden\". ( 401 means \"Unauthorized\", but you redirect to the login page instead of returning that status.) The check_author argument is defined so that the function can be used to get a post without checking the author. This would be useful if you wrote a view to show an individual post on a page, where the user doesn't matter because they're not modifying the post. .. code-block:: python :caption: flaskr/blog.py @ bp . route ( '/&lt;int:id&gt;/update' , methods =( 'GET' , 'POST' )) @ login_required def update ( id ): post = get_post ( id ) if request . method == 'POST' : title = request . form [ 'title' ] body = request . form [ 'body' ] error = None if not title : error = 'Title is required.' if error is not None : flash ( error ) else : db = get_db () db . execute ( 'UPDATE post SET title = ?, body = ?' ' WHERE id = ?' , ( title , body , id ) ) db . commit () return redirect ( url_for ( 'blog.index' )) return render_template ( 'blog/update.html' , post = post ) Unlike the views you've written so far, the update function takes an argument, id . That corresponds to the <int:id> in the route. A real URL will look like /1/update . Flask will capture the 1 , ensure it's an :class: int , and pass it as the id argument. If you don't specify int: and instead do <id> , it will be a string. To generate a URL to the update page, :func: url_for needs to be passed the id so it knows what to fill in: url_for('blog.update', id=post['id']) . This is also in the index.html file above. The create and update views look very similar. The main difference is that the update view uses a post object and an UPDATE query instead of an INSERT . With some clever refactoring, you could use one view and template for both actions, but for the tutorial it's clearer to keep them separate. .. code-block:: html+jinja :caption: flaskr/templates/blog/update.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Edit \" {{ post [ 'title' ] }} \" {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"title\"&gt;Title&lt;/label&gt; &lt;input name=\"title\" id=\"title\" value=\" {{ request.form [ 'title' ] or post [ 'title' ] }} \" required&gt; &lt;label for=\"body\"&gt;Body&lt;/label&gt; &lt;textarea name=\"body\" id=\"body\"&gt; {{ request.form [ 'body' ] or post [ 'body' ] }} &lt;/textarea&gt; &lt;input type=\"submit\" value=\"Save\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;form action=\" {{ url_for ( 'blog.delete' , id = post [ 'id' ]) }} \" method=\"post\"&gt; &lt;input class=\"danger\" type=\"submit\" value=\"Delete\" onclick=\"return confirm('Are you sure?');\"&gt; &lt;/form&gt; {% endblock %} This template has two forms. The first posts the edited data to the current page ( /<id>/update ). The other form contains only a button and specifies an action attribute that posts to the delete view instead. The button uses some JavaScript to show a confirmation dialog before submitting. The pattern {{ request.form['title'] or post['title'] }} is used to choose what data appears in the form. When the form hasn't been submitted, the original post data appears, but if invalid form data was posted you want to display that so the user can fix the error, so request.form is used instead. :data: request is another variable that's automatically available in templates.","title":"Update"},{"location":"tutorial/blog/#delete","text":"The delete view doesn't have its own template, the delete button is part of update.html and posts to the /<id>/delete URL. Since there is no template, it will only handle the POST method and then redirect to the index view. .. code-block:: python :caption: flaskr/blog.py @ bp . route ( '/&lt;int:id&gt;/delete' , methods =( 'POST' ,)) @ login_required def delete ( id ): get_post ( id ) db = get_db () db . execute ( 'DELETE FROM post WHERE id = ?' , ( id ,)) db . commit () return redirect ( url_for ( 'blog.index' )) Congratulations, you've now finished writing your application! Take some time to try out everything in the browser. However, there's still more to do before the project is complete. Continue to :doc: install .","title":"Delete"},{"location":"tutorial/database/","text":".. currentmodule:: flask Define and Access the Database \u00b6 The application will use a SQLite _ database to store users and posts. Python comes with built-in support for SQLite in the :mod: sqlite3 module. SQLite is convenient because it doesn't require setting up a separate database server and is built-in to Python. However, if concurrent requests try to write to the database at the same time, they will slow down as each write happens sequentially. Small applications won't notice this. Once you become big, you may want to switch to a different database. The tutorial doesn't go into detail about SQL. If you are not familiar with it, the SQLite docs describe the language _. .. _SQLite: https://sqlite.org/about.html .. _language: https://sqlite.org/lang.html Connect to the Database \u00b6 The first thing to do when working with a SQLite database (and most other Python database libraries) is to create a connection to it. Any queries and operations are performed using the connection, which is closed after the work is finished. In web applications this connection is typically tied to the request. It is created at some point when handling a request, and closed before the response is sent. .. code-block:: python :caption: flaskr/db.py import sqlite3 import click from flask import current_app , g from flask.cli import with_appcontext def get_db (): if 'db' not in g : g . db = sqlite3 . connect ( current_app . config [ 'DATABASE' ], detect_types = sqlite3 . PARSE_DECLTYPES ) g . db . row_factory = sqlite3 . Row return g . db def close_db ( e = None ): db = g . pop ( 'db' , None ) if db is not None : db . close () :data: g is a special object that is unique for each request. It is used to store data that might be accessed by multiple functions during the request. The connection is stored and reused instead of creating a new connection if get_db is called a second time in the same request. :data: current_app is another special object that points to the Flask application handling the request. Since you used an application factory, there is no application object when writing the rest of your code. get_db will be called when the application has been created and is handling a request, so :data: current_app can be used. :func: sqlite3.connect establishes a connection to the file pointed at by the DATABASE configuration key. This file doesn't have to exist yet, and won't until you initialize the database later. :class: sqlite3.Row tells the connection to return rows that behave like dicts. This allows accessing the columns by name. close_db checks if a connection was created by checking if g.db was set. If the connection exists, it is closed. Further down you will tell your application about the close_db function in the application factory so that it is called after each request. Create the Tables \u00b6 In SQLite, data is stored in tables and columns . These need to be created before you can store and retrieve data. Flaskr will store users in the user table, and posts in the post table. Create a file with the SQL commands needed to create empty tables: .. code-block:: sql :caption: flaskr/schema.sql DROP TABLE IF EXISTS user; DROP TABLE IF EXISTS post; CREATE TABLE user ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL ); CREATE TABLE post ( id INTEGER PRIMARY KEY AUTOINCREMENT, author_id INTEGER NOT NULL, created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, title TEXT NOT NULL, body TEXT NOT NULL, FOREIGN KEY (author_id) REFERENCES user (id) ); Add the Python functions that will run these SQL commands to the db.py file: .. code-block:: python :caption: flaskr/db.py def init_db(): db = get_db() with current_app.open_resource('schema.sql') as f: db.executescript(f.read().decode('utf8')) @click.command('init-db') @with_appcontext def init_db_command(): \"\"\"Clear the existing data and create new tables.\"\"\" init_db() click.echo('Initialized the database.') :meth: open_resource() <Flask.open_resource> opens a file relative to the flaskr package, which is useful since you won't necessarily know where that location is when deploying the application later. get_db returns a database connection, which is used to execute the commands read from the file. :func: click.command defines a command line command called init-db that calls the init_db function and shows a success message to the user. You can read :ref: cli to learn more about writing commands. Register with the Application \u00b6 The close_db and init_db_command functions need to be registered with the application instance; otherwise, they won't be used by the application. However, since you're using a factory function, that instance isn't available when writing the functions. Instead, write a function that takes an application and does the registration. .. code-block:: python :caption: flaskr/db.py def init_app(app): app.teardown_appcontext(close_db) app.cli.add_command(init_db_command) :meth: app.teardown_appcontext() <Flask.teardown_appcontext> tells Flask to call that function when cleaning up after returning the response. :meth: app.cli.add_command() <click.Group.add_command> adds a new command that can be called with the flask command. Import and call this function from the factory. Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import db db . init_app ( app ) return app Initialize the Database File \u00b6 Now that init-db has been registered with the app, it can be called using the flask command, similar to the run command from the previous page. .. note:: If you're still running the server from the previous page, you can either stop the server, or run this command in a new terminal. If you use a new terminal, remember to change to your project directory and activate the env as described in :ref:`install-activate-env`. You'll also need to set ``FLASK_APP`` and ``FLASK_ENV`` as shown on the previous page. Run the init-db command: .. code-block:: none $ flask init-db Initialized the database. There will now be a flaskr.sqlite file in the instance folder in your project. Continue to :doc: views .","title":"Database"},{"location":"tutorial/database/#define-and-access-the-database","text":"The application will use a SQLite _ database to store users and posts. Python comes with built-in support for SQLite in the :mod: sqlite3 module. SQLite is convenient because it doesn't require setting up a separate database server and is built-in to Python. However, if concurrent requests try to write to the database at the same time, they will slow down as each write happens sequentially. Small applications won't notice this. Once you become big, you may want to switch to a different database. The tutorial doesn't go into detail about SQL. If you are not familiar with it, the SQLite docs describe the language _. .. _SQLite: https://sqlite.org/about.html .. _language: https://sqlite.org/lang.html","title":"Define and Access the Database"},{"location":"tutorial/database/#connect-to-the-database","text":"The first thing to do when working with a SQLite database (and most other Python database libraries) is to create a connection to it. Any queries and operations are performed using the connection, which is closed after the work is finished. In web applications this connection is typically tied to the request. It is created at some point when handling a request, and closed before the response is sent. .. code-block:: python :caption: flaskr/db.py import sqlite3 import click from flask import current_app , g from flask.cli import with_appcontext def get_db (): if 'db' not in g : g . db = sqlite3 . connect ( current_app . config [ 'DATABASE' ], detect_types = sqlite3 . PARSE_DECLTYPES ) g . db . row_factory = sqlite3 . Row return g . db def close_db ( e = None ): db = g . pop ( 'db' , None ) if db is not None : db . close () :data: g is a special object that is unique for each request. It is used to store data that might be accessed by multiple functions during the request. The connection is stored and reused instead of creating a new connection if get_db is called a second time in the same request. :data: current_app is another special object that points to the Flask application handling the request. Since you used an application factory, there is no application object when writing the rest of your code. get_db will be called when the application has been created and is handling a request, so :data: current_app can be used. :func: sqlite3.connect establishes a connection to the file pointed at by the DATABASE configuration key. This file doesn't have to exist yet, and won't until you initialize the database later. :class: sqlite3.Row tells the connection to return rows that behave like dicts. This allows accessing the columns by name. close_db checks if a connection was created by checking if g.db was set. If the connection exists, it is closed. Further down you will tell your application about the close_db function in the application factory so that it is called after each request.","title":"Connect to the Database"},{"location":"tutorial/database/#create-the-tables","text":"In SQLite, data is stored in tables and columns . These need to be created before you can store and retrieve data. Flaskr will store users in the user table, and posts in the post table. Create a file with the SQL commands needed to create empty tables: .. code-block:: sql :caption: flaskr/schema.sql DROP TABLE IF EXISTS user; DROP TABLE IF EXISTS post; CREATE TABLE user ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL ); CREATE TABLE post ( id INTEGER PRIMARY KEY AUTOINCREMENT, author_id INTEGER NOT NULL, created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, title TEXT NOT NULL, body TEXT NOT NULL, FOREIGN KEY (author_id) REFERENCES user (id) ); Add the Python functions that will run these SQL commands to the db.py file: .. code-block:: python :caption: flaskr/db.py def init_db(): db = get_db() with current_app.open_resource('schema.sql') as f: db.executescript(f.read().decode('utf8')) @click.command('init-db') @with_appcontext def init_db_command(): \"\"\"Clear the existing data and create new tables.\"\"\" init_db() click.echo('Initialized the database.') :meth: open_resource() <Flask.open_resource> opens a file relative to the flaskr package, which is useful since you won't necessarily know where that location is when deploying the application later. get_db returns a database connection, which is used to execute the commands read from the file. :func: click.command defines a command line command called init-db that calls the init_db function and shows a success message to the user. You can read :ref: cli to learn more about writing commands.","title":"Create the Tables"},{"location":"tutorial/database/#register-with-the-application","text":"The close_db and init_db_command functions need to be registered with the application instance; otherwise, they won't be used by the application. However, since you're using a factory function, that instance isn't available when writing the functions. Instead, write a function that takes an application and does the registration. .. code-block:: python :caption: flaskr/db.py def init_app(app): app.teardown_appcontext(close_db) app.cli.add_command(init_db_command) :meth: app.teardown_appcontext() <Flask.teardown_appcontext> tells Flask to call that function when cleaning up after returning the response. :meth: app.cli.add_command() <click.Group.add_command> adds a new command that can be called with the flask command. Import and call this function from the factory. Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import db db . init_app ( app ) return app","title":"Register with the Application"},{"location":"tutorial/database/#initialize-the-database-file","text":"Now that init-db has been registered with the app, it can be called using the flask command, similar to the run command from the previous page. .. note:: If you're still running the server from the previous page, you can either stop the server, or run this command in a new terminal. If you use a new terminal, remember to change to your project directory and activate the env as described in :ref:`install-activate-env`. You'll also need to set ``FLASK_APP`` and ``FLASK_ENV`` as shown on the previous page. Run the init-db command: .. code-block:: none $ flask init-db Initialized the database. There will now be a flaskr.sqlite file in the instance folder in your project. Continue to :doc: views .","title":"Initialize the Database File"},{"location":"tutorial/deploy/","text":"Deploy to Production \u00b6 This part of the tutorial assumes you have a server that you want to deploy your application to. It gives an overview of how to create the distribution file and install it, but won't go into specifics about what server or software to use. You can set up a new environment on your development computer to try out the instructions below, but probably shouldn't use it for hosting a real public application. See :doc: /deploying/index for a list of many different ways to host your application. Build and Install \u00b6 When you want to deploy your application elsewhere, you build a distribution file. The current standard for Python distribution is the wheel format, with the .whl extension. Make sure the wheel library is installed first: .. code-block:: none $ pip install wheel Running setup.py with Python gives you a command line tool to issue build-related commands. The bdist_wheel command will build a wheel distribution file. .. code-block:: none $ python setup.py bdist_wheel You can find the file in dist/flaskr-1.0.0-py3-none-any.whl . The file name is the name of the project, the version, and some tags about the file can install. Copy this file to another machine, :ref: set up a new virtualenv <install-create-env> , then install the file with pip . .. code-block:: none $ pip install flaskr-1.0.0-py3-none-any.whl Pip will install your project along with its dependencies. Since this is a different machine, you need to run init-db again to create the database in the instance folder. .. code-block:: none $ export FLASK_APP = flaskr $ flask init-db When Flask detects that it's installed (not in editable mode), it uses a different directory for the instance folder. You can find it at venv/var/flaskr-instance instead. Configure the Secret Key \u00b6 In the beginning of the tutorial that you gave a default value for :data: SECRET_KEY . This should be changed to some random bytes in production. Otherwise, attackers could use the public 'dev' key to modify the session cookie, or anything else that uses the secret key. You can use the following command to output a random secret key: .. code-block:: none $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' Create the config.py file in the instance folder, which the factory will read from if it exists. Copy the generated value into it. .. code-block:: python :caption: venv/var/flaskr-instance/config.py SECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/' You can also set any other necessary configuration here, although SECRET_KEY is the only one needed for Flaskr. Run with a Production Server \u00b6 When running publicly rather than in development, you should not use the built-in development server ( flask run ). The development server is provided by Werkzeug for convenience, but is not designed to be particularly efficient, stable, or secure. Instead, use a production WSGI server. For example, to use Waitress _, first install it in the virtual environment: .. code-block:: none $ pip install waitress You need to tell Waitress about your application, but it doesn't use FLASK_APP like flask run does. You need to tell it to import and call the application factory to get an application object. .. code-block:: none $ waitress-serve --call 'flaskr:create_app' Serving on http://0.0.0.0:8080 See :doc: /deploying/index for a list of many different ways to host your application. Waitress is just an example, chosen for the tutorial because it supports both Windows and Linux. There are many more WSGI servers and deployment options that you may choose for your project. .. _Waitress: https://docs.pylonsproject.org/projects/waitress/ Continue to :doc: next .","title":"Deploy to Production"},{"location":"tutorial/deploy/#deploy-to-production","text":"This part of the tutorial assumes you have a server that you want to deploy your application to. It gives an overview of how to create the distribution file and install it, but won't go into specifics about what server or software to use. You can set up a new environment on your development computer to try out the instructions below, but probably shouldn't use it for hosting a real public application. See :doc: /deploying/index for a list of many different ways to host your application.","title":"Deploy to Production"},{"location":"tutorial/deploy/#build-and-install","text":"When you want to deploy your application elsewhere, you build a distribution file. The current standard for Python distribution is the wheel format, with the .whl extension. Make sure the wheel library is installed first: .. code-block:: none $ pip install wheel Running setup.py with Python gives you a command line tool to issue build-related commands. The bdist_wheel command will build a wheel distribution file. .. code-block:: none $ python setup.py bdist_wheel You can find the file in dist/flaskr-1.0.0-py3-none-any.whl . The file name is the name of the project, the version, and some tags about the file can install. Copy this file to another machine, :ref: set up a new virtualenv <install-create-env> , then install the file with pip . .. code-block:: none $ pip install flaskr-1.0.0-py3-none-any.whl Pip will install your project along with its dependencies. Since this is a different machine, you need to run init-db again to create the database in the instance folder. .. code-block:: none $ export FLASK_APP = flaskr $ flask init-db When Flask detects that it's installed (not in editable mode), it uses a different directory for the instance folder. You can find it at venv/var/flaskr-instance instead.","title":"Build and Install"},{"location":"tutorial/deploy/#configure-the-secret-key","text":"In the beginning of the tutorial that you gave a default value for :data: SECRET_KEY . This should be changed to some random bytes in production. Otherwise, attackers could use the public 'dev' key to modify the session cookie, or anything else that uses the secret key. You can use the following command to output a random secret key: .. code-block:: none $ python - c 'import os; print(os.urandom(16))' b '_5#y2L\"F4Q8z \\n\\xec ]/' Create the config.py file in the instance folder, which the factory will read from if it exists. Copy the generated value into it. .. code-block:: python :caption: venv/var/flaskr-instance/config.py SECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/' You can also set any other necessary configuration here, although SECRET_KEY is the only one needed for Flaskr.","title":"Configure the Secret Key"},{"location":"tutorial/deploy/#run-with-a-production-server","text":"When running publicly rather than in development, you should not use the built-in development server ( flask run ). The development server is provided by Werkzeug for convenience, but is not designed to be particularly efficient, stable, or secure. Instead, use a production WSGI server. For example, to use Waitress _, first install it in the virtual environment: .. code-block:: none $ pip install waitress You need to tell Waitress about your application, but it doesn't use FLASK_APP like flask run does. You need to tell it to import and call the application factory to get an application object. .. code-block:: none $ waitress-serve --call 'flaskr:create_app' Serving on http://0.0.0.0:8080 See :doc: /deploying/index for a list of many different ways to host your application. Waitress is just an example, chosen for the tutorial because it supports both Windows and Linux. There are many more WSGI servers and deployment options that you may choose for your project. .. _Waitress: https://docs.pylonsproject.org/projects/waitress/ Continue to :doc: next .","title":"Run with a Production Server"},{"location":"tutorial/factory/","text":".. currentmodule:: flask Application Setup \u00b6 A Flask application is an instance of the :class: Flask class. Everything about the application, such as configuration and URLs, will be registered with this class. The most straightforward way to create a Flask application is to create a global :class: Flask instance directly at the top of your code, like how the \"Hello, World!\" example did on the previous page. While this is simple and useful in some cases, it can cause some tricky issues as the project grows. Instead of creating a :class: Flask instance globally, you will create it inside a function. This function is known as the application factory . Any configuration, registration, and other setup the application needs will happen inside the function, then the application will be returned. The Application Factory \u00b6 It's time to start coding! Create the flaskr directory and add the __init__.py file. The __init__.py serves double duty: it will contain the application factory, and it tells Python that the flaskr directory should be treated as a package. .. code-block:: none $ mkdir flaskr .. code-block:: python :caption: flaskr/__init__.py import os from flask import Flask def create_app ( test_config = None ): # create and configure the app app = Flask ( __name__ , instance_relative_config = True ) app . config . from_mapping ( SECRET_KEY = 'dev' , DATABASE = os . path . join ( app . instance_path , 'flaskr.sqlite' ), ) if test_config is None : # load the instance config, if it exists, when not testing app . config . from_pyfile ( 'config.py' , silent = True ) else : # load the test config if passed in app . config . from_mapping ( test_config ) # ensure the instance folder exists try : os . makedirs ( app . instance_path ) except OSError : pass # a simple page that says hello @app.route ( '/hello' ) def hello (): return 'Hello, World!' return app create_app is the application factory function. You'll add to it later in the tutorial, but it already does a lot. . app = Flask(__name__, instance_relative_config=True) creates the \u00b6 :class: Flask instance. * `` __name__ `` is the name of the current Python module . The app needs to know where it 's located to set up some paths, and ``__name__`` is a convenient way to tell it that. * ``instance_relative_config=True`` tells the app that configuration files are relative to the :ref:`instance folder &lt;instance-folders&gt;`. The instance folder is located outside the ``flaskr`` package and can hold local data that shouldn' t be committed to version control , such as configuration secrets and the database file . . :meth: app.config.from_mapping() <Config.from_mapping> sets \u00b6 some default configuration that the app will use: * : data : ` SECRET_KEY ` is used by Flask and extensions to keep data safe . It 's set to ``' dev '`` to provide a convenient value during development, but it should be overridden with a random value when deploying. * ``DATABASE`` is the path where the SQLite database file will be saved. It' s under : attr : ` app . instance_path & lt ; Flask . instance_path & gt ; ` , which is the path that Flask has chosen for the instance folder . You ' ll learn more about the database in the next section . . :meth: app.config.from_pyfile() <Config.from_pyfile> overrides \u00b6 the default configuration with values taken from the config.py file in the instance folder if it exists. For example, when deploying, this can be used to set a real SECRET_KEY . * ``test_config`` can also be passed to the factory, and will be used instead of the instance configuration. This is so the tests you'll write later in the tutorial can be configured independently of any development values you have configured. . :func: os.makedirs ensures that \u00b6 :attr: app.instance_path <Flask.instance_path> exists. Flask doesn't create the instance folder automatically, but it needs to be created because your project will create the SQLite database file there. . :meth: @app.route() <Flask.route> creates a simple route so you can \u00b6 see the application working before getting into the rest of the tutorial. It creates a connection between the URL /hello and a function that returns a response, the string 'Hello, World!' in this case. Run The Application \u00b6 Now you can run your application using the flask command. From the terminal, tell Flask where to find your application, then run it in development mode. Remember, you should still be in the top-level flask-tutorial directory, not the flaskr package. Development mode shows an interactive debugger whenever a page raises an exception, and restarts the server whenever you make changes to the code. You can leave it running and just reload the browser page as you follow the tutorial. For Linux and Mac: .. code-block:: none $ export FLASK_APP = flaskr $ export FLASK_ENV = development $ flask run For Windows cmd, use set instead of export : .. code-block:: none &gt; set FLASK_APP=flaskr &gt; set FLASK_ENV=development &gt; flask run For Windows PowerShell, use $env: instead of export : .. code-block:: none &gt; $env:FLASK_APP = \"flaskr\" &gt; $env:FLASK_ENV = \"development\" &gt; flask run You'll see output similar to this: .. code-block:: none * Serving Flask app \"flaskr\" * Environment: development * Debug mode: on * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 855-212-761 Visit http://127.0.0.1:5000/hello in a browser and you should see the \"Hello, World!\" message. Congratulations, you're now running your Flask web application! Continue to :doc: database .","title":"Factory"},{"location":"tutorial/factory/#application-setup","text":"A Flask application is an instance of the :class: Flask class. Everything about the application, such as configuration and URLs, will be registered with this class. The most straightforward way to create a Flask application is to create a global :class: Flask instance directly at the top of your code, like how the \"Hello, World!\" example did on the previous page. While this is simple and useful in some cases, it can cause some tricky issues as the project grows. Instead of creating a :class: Flask instance globally, you will create it inside a function. This function is known as the application factory . Any configuration, registration, and other setup the application needs will happen inside the function, then the application will be returned.","title":"Application Setup"},{"location":"tutorial/factory/#the-application-factory","text":"It's time to start coding! Create the flaskr directory and add the __init__.py file. The __init__.py serves double duty: it will contain the application factory, and it tells Python that the flaskr directory should be treated as a package. .. code-block:: none $ mkdir flaskr .. code-block:: python :caption: flaskr/__init__.py import os from flask import Flask def create_app ( test_config = None ): # create and configure the app app = Flask ( __name__ , instance_relative_config = True ) app . config . from_mapping ( SECRET_KEY = 'dev' , DATABASE = os . path . join ( app . instance_path , 'flaskr.sqlite' ), ) if test_config is None : # load the instance config, if it exists, when not testing app . config . from_pyfile ( 'config.py' , silent = True ) else : # load the test config if passed in app . config . from_mapping ( test_config ) # ensure the instance folder exists try : os . makedirs ( app . instance_path ) except OSError : pass # a simple page that says hello @app.route ( '/hello' ) def hello (): return 'Hello, World!' return app create_app is the application factory function. You'll add to it later in the tutorial, but it already does a lot.","title":"The Application Factory"},{"location":"tutorial/factory/#app-flask__name__-instance_relative_configtrue-creates-the","text":":class: Flask instance. * `` __name__ `` is the name of the current Python module . The app needs to know where it 's located to set up some paths, and ``__name__`` is a convenient way to tell it that. * ``instance_relative_config=True`` tells the app that configuration files are relative to the :ref:`instance folder &lt;instance-folders&gt;`. The instance folder is located outside the ``flaskr`` package and can hold local data that shouldn' t be committed to version control , such as configuration secrets and the database file .","title":". app = Flask(__name__, instance_relative_config=True) creates the"},{"location":"tutorial/factory/#methappconfigfrom_mapping-ltconfigfrom_mappinggt-sets","text":"some default configuration that the app will use: * : data : ` SECRET_KEY ` is used by Flask and extensions to keep data safe . It 's set to ``' dev '`` to provide a convenient value during development, but it should be overridden with a random value when deploying. * ``DATABASE`` is the path where the SQLite database file will be saved. It' s under : attr : ` app . instance_path & lt ; Flask . instance_path & gt ; ` , which is the path that Flask has chosen for the instance folder . You ' ll learn more about the database in the next section .","title":". :meth:app.config.from_mapping() &lt;Config.from_mapping&gt; sets"},{"location":"tutorial/factory/#methappconfigfrom_pyfile-ltconfigfrom_pyfilegt-overrides","text":"the default configuration with values taken from the config.py file in the instance folder if it exists. For example, when deploying, this can be used to set a real SECRET_KEY . * ``test_config`` can also be passed to the factory, and will be used instead of the instance configuration. This is so the tests you'll write later in the tutorial can be configured independently of any development values you have configured.","title":". :meth:app.config.from_pyfile() &lt;Config.from_pyfile&gt; overrides"},{"location":"tutorial/factory/#funcosmakedirs-ensures-that","text":":attr: app.instance_path <Flask.instance_path> exists. Flask doesn't create the instance folder automatically, but it needs to be created because your project will create the SQLite database file there.","title":". :func:os.makedirs ensures that"},{"location":"tutorial/factory/#methapproute-ltflaskroutegt-creates-a-simple-route-so-you-can","text":"see the application working before getting into the rest of the tutorial. It creates a connection between the URL /hello and a function that returns a response, the string 'Hello, World!' in this case.","title":". :meth:@app.route() &lt;Flask.route&gt; creates a simple route so you can"},{"location":"tutorial/factory/#run-the-application","text":"Now you can run your application using the flask command. From the terminal, tell Flask where to find your application, then run it in development mode. Remember, you should still be in the top-level flask-tutorial directory, not the flaskr package. Development mode shows an interactive debugger whenever a page raises an exception, and restarts the server whenever you make changes to the code. You can leave it running and just reload the browser page as you follow the tutorial. For Linux and Mac: .. code-block:: none $ export FLASK_APP = flaskr $ export FLASK_ENV = development $ flask run For Windows cmd, use set instead of export : .. code-block:: none &gt; set FLASK_APP=flaskr &gt; set FLASK_ENV=development &gt; flask run For Windows PowerShell, use $env: instead of export : .. code-block:: none &gt; $env:FLASK_APP = \"flaskr\" &gt; $env:FLASK_ENV = \"development\" &gt; flask run You'll see output similar to this: .. code-block:: none * Serving Flask app \"flaskr\" * Environment: development * Debug mode: on * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 855-212-761 Visit http://127.0.0.1:5000/hello in a browser and you should see the \"Hello, World!\" message. Congratulations, you're now running your Flask web application! Continue to :doc: database .","title":"Run The Application"},{"location":"tutorial/install/","text":"Make the Project Installable \u00b6 Making your project installable means that you can build a distribution file and install that in another environment, just like you installed Flask in your project's environment. This makes deploying your project the same as installing any other library, so you're using all the standard Python tools to manage everything. Installing also comes with other benefits that might not be obvious from the tutorial or as a new Python user, including: Currently, Python and Flask understand how to use the flaskr package only because you're running from your project's directory. Installing means you can import it no matter where you run from. You can manage your project's dependencies just like other packages do, so pip install yourproject.whl installs them. Test tools can isolate your test environment from your development environment. .. note:: This is being introduced late in the tutorial, but in your future projects you should always start with this. Describe the Project \u00b6 The setup.py file describes your project and the files that belong to it. .. code-block:: python :caption: setup.py from setuptools import find_packages , setup setup ( name = 'flaskr' , version = '1.0.0' , packages = find_packages (), include_package_data = True , zip_safe = False , install_requires = [ 'flask' , ], ) packages tells Python what package directories (and the Python files they contain) to include. find_packages() finds these directories automatically so you don't have to type them out. To include other files, such as the static and templates directories, include_package_data is set. Python needs another file named MANIFEST.in to tell what this other data is. .. code-block:: none :caption: MANIFEST.in include flaskr/schema.sql graft flaskr/static graft flaskr/templates global-exclude *.pyc This tells Python to copy everything in the static and templates directories, and the schema.sql file, but to exclude all bytecode files. See the official packaging guide _ for another explanation of the files and options used. .. _official packaging guide: https://packaging.python.org/tutorials/distributing-packages/ Install the Project \u00b6 Use pip to install your project in the virtual environment. .. code-block:: none $ pip install -e . This tells pip to find setup.py in the current directory and install it in editable or development mode. Editable mode means that as you make changes to your local code, you'll only need to re-install if you change the metadata about the project, such as its dependencies. You can observe that the project is now installed with pip list . .. code-block:: none $ pip list Package Version Location -------------- --------- ---------------------------------- click 6 .7 Flask 1 .0 flaskr 1 .0.0 /home/user/Projects/flask-tutorial itsdangerous 0 .24 Jinja2 2 .10 MarkupSafe 1 .0 pip 9 .0.3 setuptools 39 .0.1 Werkzeug 0 .14.1 wheel 0 .30.0 Nothing changes from how you've been running your project so far. FLASK_APP is still set to flaskr and flask run still runs the application, but you can call it from anywhere, not just the flask-tutorial directory. Continue to :doc: tests .","title":"Make the Project Installable"},{"location":"tutorial/install/#make-the-project-installable","text":"Making your project installable means that you can build a distribution file and install that in another environment, just like you installed Flask in your project's environment. This makes deploying your project the same as installing any other library, so you're using all the standard Python tools to manage everything. Installing also comes with other benefits that might not be obvious from the tutorial or as a new Python user, including: Currently, Python and Flask understand how to use the flaskr package only because you're running from your project's directory. Installing means you can import it no matter where you run from. You can manage your project's dependencies just like other packages do, so pip install yourproject.whl installs them. Test tools can isolate your test environment from your development environment. .. note:: This is being introduced late in the tutorial, but in your future projects you should always start with this.","title":"Make the Project Installable"},{"location":"tutorial/install/#describe-the-project","text":"The setup.py file describes your project and the files that belong to it. .. code-block:: python :caption: setup.py from setuptools import find_packages , setup setup ( name = 'flaskr' , version = '1.0.0' , packages = find_packages (), include_package_data = True , zip_safe = False , install_requires = [ 'flask' , ], ) packages tells Python what package directories (and the Python files they contain) to include. find_packages() finds these directories automatically so you don't have to type them out. To include other files, such as the static and templates directories, include_package_data is set. Python needs another file named MANIFEST.in to tell what this other data is. .. code-block:: none :caption: MANIFEST.in include flaskr/schema.sql graft flaskr/static graft flaskr/templates global-exclude *.pyc This tells Python to copy everything in the static and templates directories, and the schema.sql file, but to exclude all bytecode files. See the official packaging guide _ for another explanation of the files and options used. .. _official packaging guide: https://packaging.python.org/tutorials/distributing-packages/","title":"Describe the Project"},{"location":"tutorial/install/#install-the-project","text":"Use pip to install your project in the virtual environment. .. code-block:: none $ pip install -e . This tells pip to find setup.py in the current directory and install it in editable or development mode. Editable mode means that as you make changes to your local code, you'll only need to re-install if you change the metadata about the project, such as its dependencies. You can observe that the project is now installed with pip list . .. code-block:: none $ pip list Package Version Location -------------- --------- ---------------------------------- click 6 .7 Flask 1 .0 flaskr 1 .0.0 /home/user/Projects/flask-tutorial itsdangerous 0 .24 Jinja2 2 .10 MarkupSafe 1 .0 pip 9 .0.3 setuptools 39 .0.1 Werkzeug 0 .14.1 wheel 0 .30.0 Nothing changes from how you've been running your project so far. FLASK_APP is still set to flaskr and flask run still runs the application, but you can call it from anywhere, not just the flask-tutorial directory. Continue to :doc: tests .","title":"Install the Project"},{"location":"tutorial/layout/","text":"Project Layout \u00b6 Create a project directory and enter it: .. code-block:: none $ mkdir flask-tutorial $ cd flask-tutorial Then follow the :doc: installation instructions </installation> to set up a Python virtual environment and install Flask for your project. The tutorial will assume you're working from the flask-tutorial directory from now on. The file names at the top of each code block are relative to this directory. A Flask application can be as simple as a single file. .. code-block:: python :caption: hello.py from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello (): return 'Hello, World!' However, as a project gets bigger, it becomes overwhelming to keep all the code in one file. Python projects use packages to organize code into multiple modules that can be imported where needed, and the tutorial will do this as well. The project directory will contain: flaskr/ , a Python package containing your application code and files. tests/ , a directory containing test modules. venv/ , a Python virtual environment where Flask and other dependencies are installed. Installation files telling Python how to install your project. Version control config, such as git _. You should make a habit of using some type of version control for all your projects, no matter the size. Any other project files you might add in the future. .. _git: https://git-scm.com/ By the end, your project layout will look like this: .. code-block:: none /home/user/Projects/flask-tutorial \u251c\u2500\u2500 flaskr/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 db.py \u2502 \u251c\u2500\u2500 schema.sql \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 blog.py \u2502 \u251c\u2500\u2500 templates/ \u2502 \u2502 \u251c\u2500\u2500 base.html \u2502 \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 login.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 register.html \u2502 \u2502 \u2514\u2500\u2500 blog/ \u2502 \u2502 \u251c\u2500\u2500 create.html \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u2502 \u2514\u2500\u2500 update.html \u2502 \u2514\u2500\u2500 static/ \u2502 \u2514\u2500\u2500 style.css \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 conftest.py \u2502 \u251c\u2500\u2500 data.sql \u2502 \u251c\u2500\u2500 test_factory.py \u2502 \u251c\u2500\u2500 test_db.py \u2502 \u251c\u2500\u2500 test_auth.py \u2502 \u2514\u2500\u2500 test_blog.py \u251c\u2500\u2500 venv/ \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 MANIFEST.in If you're using version control, the following files that are generated while running your project should be ignored. There may be other files based on the editor you use. In general, ignore files that you didn't write. For example, with git: .. code-block:: none :caption: .gitignore venv/ *.pyc __pycache__/ instance/ .pytest_cache/ .coverage htmlcov/ dist/ build/ *.egg-info/ Continue to :doc: factory .","title":"Project Layout"},{"location":"tutorial/layout/#project-layout","text":"Create a project directory and enter it: .. code-block:: none $ mkdir flask-tutorial $ cd flask-tutorial Then follow the :doc: installation instructions </installation> to set up a Python virtual environment and install Flask for your project. The tutorial will assume you're working from the flask-tutorial directory from now on. The file names at the top of each code block are relative to this directory. A Flask application can be as simple as a single file. .. code-block:: python :caption: hello.py from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello (): return 'Hello, World!' However, as a project gets bigger, it becomes overwhelming to keep all the code in one file. Python projects use packages to organize code into multiple modules that can be imported where needed, and the tutorial will do this as well. The project directory will contain: flaskr/ , a Python package containing your application code and files. tests/ , a directory containing test modules. venv/ , a Python virtual environment where Flask and other dependencies are installed. Installation files telling Python how to install your project. Version control config, such as git _. You should make a habit of using some type of version control for all your projects, no matter the size. Any other project files you might add in the future. .. _git: https://git-scm.com/ By the end, your project layout will look like this: .. code-block:: none /home/user/Projects/flask-tutorial \u251c\u2500\u2500 flaskr/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 db.py \u2502 \u251c\u2500\u2500 schema.sql \u2502 \u251c\u2500\u2500 auth.py \u2502 \u251c\u2500\u2500 blog.py \u2502 \u251c\u2500\u2500 templates/ \u2502 \u2502 \u251c\u2500\u2500 base.html \u2502 \u2502 \u251c\u2500\u2500 auth/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 login.html \u2502 \u2502 \u2502 \u2514\u2500\u2500 register.html \u2502 \u2502 \u2514\u2500\u2500 blog/ \u2502 \u2502 \u251c\u2500\u2500 create.html \u2502 \u2502 \u251c\u2500\u2500 index.html \u2502 \u2502 \u2514\u2500\u2500 update.html \u2502 \u2514\u2500\u2500 static/ \u2502 \u2514\u2500\u2500 style.css \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 conftest.py \u2502 \u251c\u2500\u2500 data.sql \u2502 \u251c\u2500\u2500 test_factory.py \u2502 \u251c\u2500\u2500 test_db.py \u2502 \u251c\u2500\u2500 test_auth.py \u2502 \u2514\u2500\u2500 test_blog.py \u251c\u2500\u2500 venv/ \u251c\u2500\u2500 setup.py \u2514\u2500\u2500 MANIFEST.in If you're using version control, the following files that are generated while running your project should be ignored. There may be other files based on the editor you use. In general, ignore files that you didn't write. For example, with git: .. code-block:: none :caption: .gitignore venv/ *.pyc __pycache__/ instance/ .pytest_cache/ .coverage htmlcov/ dist/ build/ *.egg-info/ Continue to :doc: factory .","title":"Project Layout"},{"location":"tutorial/next/","text":"Keep Developing! \u00b6 You've learned about quite a few Flask and Python concepts throughout the tutorial. Go back and review the tutorial and compare your code with the steps you took to get there. Compare your project to the :gh: example project <examples/tutorial> , which might look a bit different due to the step-by-step nature of the tutorial. There's a lot more to Flask than what you've seen so far. Even so, you're now equipped to start developing your own web applications. Check out the :ref: quickstart for an overview of what Flask can do, then dive into the docs to keep learning. Flask uses Jinja , Click , Werkzeug , and ItsDangerous behind the scenes, and they all have their own documentation too. You'll also be interested in :ref: extensions which make tasks like working with the database or validating form data easier and more powerful. If you want to keep developing your Flaskr project, here are some ideas for what to try next: A detail view to show a single post. Click a post's title to go to its page. Like / unlike a post. Comments. Tags. Clicking a tag shows all the posts with that tag. A search box that filters the index page by name. Paged display. Only show 5 posts per page. Upload an image to go along with a post. Format posts using Markdown. An RSS feed of new posts. Have fun and make awesome applications! .. _Jinja: https://palletsprojects.com/p/jinja/ .. _Click: https://palletsprojects.com/p/click/ .. _Werkzeug: https://palletsprojects.com/p/werkzeug/ .. _ItsDangerous: https://palletsprojects.com/p/itsdangerous/","title":"Keep Developing!"},{"location":"tutorial/next/#keep-developing","text":"You've learned about quite a few Flask and Python concepts throughout the tutorial. Go back and review the tutorial and compare your code with the steps you took to get there. Compare your project to the :gh: example project <examples/tutorial> , which might look a bit different due to the step-by-step nature of the tutorial. There's a lot more to Flask than what you've seen so far. Even so, you're now equipped to start developing your own web applications. Check out the :ref: quickstart for an overview of what Flask can do, then dive into the docs to keep learning. Flask uses Jinja , Click , Werkzeug , and ItsDangerous behind the scenes, and they all have their own documentation too. You'll also be interested in :ref: extensions which make tasks like working with the database or validating form data easier and more powerful. If you want to keep developing your Flaskr project, here are some ideas for what to try next: A detail view to show a single post. Click a post's title to go to its page. Like / unlike a post. Comments. Tags. Clicking a tag shows all the posts with that tag. A search box that filters the index page by name. Paged display. Only show 5 posts per page. Upload an image to go along with a post. Format posts using Markdown. An RSS feed of new posts. Have fun and make awesome applications! .. _Jinja: https://palletsprojects.com/p/jinja/ .. _Click: https://palletsprojects.com/p/click/ .. _Werkzeug: https://palletsprojects.com/p/werkzeug/ .. _ItsDangerous: https://palletsprojects.com/p/itsdangerous/","title":"Keep Developing!"},{"location":"tutorial/static/","text":"Static Files \u00b6 The authentication views and templates work, but they look very plain right now. Some CSS _ can be added to add style to the HTML layout you constructed. The style won't change, so it's a static file rather than a template. Flask automatically adds a static view that takes a path relative to the flaskr/static directory and serves it. The base.html template already has a link to the style.css file: .. code-block:: html+jinja {{ url_for ( 'static' , filename = 'style.css' ) }} Besides CSS, other types of static files might be files with JavaScript functions, or a logo image. They are all placed under the flaskr/static directory and referenced with url_for('static', filename='...') . This tutorial isn't focused on how to write CSS, so you can just copy the following into the flaskr/static/style.css file: .. code-block:: css :caption: flaskr/static/style.css html { font-family : sans-serif ; background : #eee ; padding : 1 rem ; } body { max-width : 960 px ; margin : 0 auto ; background : white ; } h1 { font-family : serif ; color : #377ba8 ; margin : 1 rem 0 ; } a { color : #377ba8 ; } hr { border : none ; border-top : 1 px solid lightgray ; } nav { background : lightgray ; display : flex ; align-items : center ; padding : 0 0.5 rem ; } nav h1 { flex : auto ; margin : 0 ; } nav h1 a { text-decoration : none ; padding : 0.25 rem 0.5 rem ; } nav ul { display : flex ; list-style : none ; margin : 0 ; padding : 0 ; } nav ul li a , nav ul li span , header . action { display : block ; padding : 0.5 rem ; } . content { padding : 0 1 rem 1 rem ; } . content & gt ; header { border-bottom : 1 px solid lightgray ; display : flex ; align-items : flex-end ; } . content & gt ; header h1 { flex : auto ; margin : 1 rem 0 0.25 rem 0 ; } . flash { margin : 1 em 0 ; padding : 1 em ; background : #cae6f6 ; border : 1 px solid #377ba8 ; } . post & gt ; header { display : flex ; align-items : flex-end ; font-size : 0.85 em ; } . post & gt ; header & gt ; div : first-of-type { flex : auto ; } . post & gt ; header h1 { font-size : 1.5 em ; margin-bottom : 0 ; } . post . about { color : slategray ; font-style : italic ; } . post . body { white-space : pre-line ; } . content : last-child { margin-bottom : 0 ; } . content form { margin : 1 em 0 ; display : flex ; flex-direction : column ; } . content label { font-weight : bold ; margin-bottom : 0.5 em ; } . content input , . content textarea { margin-bottom : 1 em ; } . content textarea { min-height : 12 em ; resize : vertical ; } input . danger { color : #cc2f2e ; } input [ type = submit ] { align-self : start ; min-width : 10 em ; } You can find a less compact version of style.css in the :gh: example code <examples/tutorial/flaskr/static/style.css> . Go to http://127.0.0.1:5000/auth/login and the page should look like the screenshot below. .. image:: flaskr_login.png :align: center :class: screenshot :alt: screenshot of login page You can read more about CSS from Mozilla's documentation <CSS_> _. If you change a static file, refresh the browser page. If the change doesn't show up, try clearing your browser's cache. .. _CSS: https://developer.mozilla.org/docs/Web/CSS Continue to :doc: blog .","title":"Static Files"},{"location":"tutorial/static/#static-files","text":"The authentication views and templates work, but they look very plain right now. Some CSS _ can be added to add style to the HTML layout you constructed. The style won't change, so it's a static file rather than a template. Flask automatically adds a static view that takes a path relative to the flaskr/static directory and serves it. The base.html template already has a link to the style.css file: .. code-block:: html+jinja {{ url_for ( 'static' , filename = 'style.css' ) }} Besides CSS, other types of static files might be files with JavaScript functions, or a logo image. They are all placed under the flaskr/static directory and referenced with url_for('static', filename='...') . This tutorial isn't focused on how to write CSS, so you can just copy the following into the flaskr/static/style.css file: .. code-block:: css :caption: flaskr/static/style.css html { font-family : sans-serif ; background : #eee ; padding : 1 rem ; } body { max-width : 960 px ; margin : 0 auto ; background : white ; } h1 { font-family : serif ; color : #377ba8 ; margin : 1 rem 0 ; } a { color : #377ba8 ; } hr { border : none ; border-top : 1 px solid lightgray ; } nav { background : lightgray ; display : flex ; align-items : center ; padding : 0 0.5 rem ; } nav h1 { flex : auto ; margin : 0 ; } nav h1 a { text-decoration : none ; padding : 0.25 rem 0.5 rem ; } nav ul { display : flex ; list-style : none ; margin : 0 ; padding : 0 ; } nav ul li a , nav ul li span , header . action { display : block ; padding : 0.5 rem ; } . content { padding : 0 1 rem 1 rem ; } . content & gt ; header { border-bottom : 1 px solid lightgray ; display : flex ; align-items : flex-end ; } . content & gt ; header h1 { flex : auto ; margin : 1 rem 0 0.25 rem 0 ; } . flash { margin : 1 em 0 ; padding : 1 em ; background : #cae6f6 ; border : 1 px solid #377ba8 ; } . post & gt ; header { display : flex ; align-items : flex-end ; font-size : 0.85 em ; } . post & gt ; header & gt ; div : first-of-type { flex : auto ; } . post & gt ; header h1 { font-size : 1.5 em ; margin-bottom : 0 ; } . post . about { color : slategray ; font-style : italic ; } . post . body { white-space : pre-line ; } . content : last-child { margin-bottom : 0 ; } . content form { margin : 1 em 0 ; display : flex ; flex-direction : column ; } . content label { font-weight : bold ; margin-bottom : 0.5 em ; } . content input , . content textarea { margin-bottom : 1 em ; } . content textarea { min-height : 12 em ; resize : vertical ; } input . danger { color : #cc2f2e ; } input [ type = submit ] { align-self : start ; min-width : 10 em ; } You can find a less compact version of style.css in the :gh: example code <examples/tutorial/flaskr/static/style.css> . Go to http://127.0.0.1:5000/auth/login and the page should look like the screenshot below. .. image:: flaskr_login.png :align: center :class: screenshot :alt: screenshot of login page You can read more about CSS from Mozilla's documentation <CSS_> _. If you change a static file, refresh the browser page. If the change doesn't show up, try clearing your browser's cache. .. _CSS: https://developer.mozilla.org/docs/Web/CSS Continue to :doc: blog .","title":"Static Files"},{"location":"tutorial/templates/","text":".. currentmodule:: flask Templates \u00b6 You've written the authentication views for your application, but if you're running the server and try to go to any of the URLs, you'll see a TemplateNotFound error. That's because the views are calling :func: render_template , but you haven't written the templates yet. The template files will be stored in the templates directory inside the flaskr package. Templates are files that contain static data as well as placeholders for dynamic data. A template is rendered with specific data to produce a final document. Flask uses the Jinja _ template library to render templates. In your application, you will use templates to render HTML _ which will display in the user's browser. In Flask, Jinja is configured to autoescape any data that is rendered in HTML templates. This means that it's safe to render user input; any characters they've entered that could mess with the HTML, such as < and > will be escaped with safe values that look the same in the browser but don't cause unwanted effects. Jinja looks and behaves mostly like Python. Special delimiters are used to distinguish Jinja syntax from the static data in the template. Anything between {{ and }} is an expression that will be output to the final document. {% and %} denotes a control flow statement like if and for . Unlike Python, blocks are denoted by start and end tags rather than indentation since static text within a block could change indentation. .. _Jinja: http://jinja.pocoo.org/docs/templates/ .. _HTML: https://developer.mozilla.org/docs/Web/HTML The Base Layout \u00b6 Each page in the application will have the same basic layout around a different body. Instead of writing the entire HTML structure in each template, each template will extend a base template and override specific sections. .. code-block:: html+jinja :caption: flaskr/templates/base.html &lt;!doctype html&gt; &lt;title&gt; {% block title %}{% endblock %} - Flaskr&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\" {{ url_for ( 'static' , filename = 'style.css' ) }} \"&gt; &lt;nav&gt; &lt;h1&gt;Flaskr&lt;/h1&gt; &lt;ul&gt; {% if g.user %} &lt;li&gt;&lt;span&gt; {{ g.user [ 'username' ] }} &lt;/span&gt; &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.logout' ) }} \"&gt;Log Out&lt;/a&gt; {% else %} &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.register' ) }} \"&gt;Register&lt;/a&gt; &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.login' ) }} \"&gt;Log In&lt;/a&gt; {% endif %} &lt;/ul&gt; &lt;/nav&gt; &lt;section class=\"content\"&gt; &lt;header&gt; {% block header %}{% endblock %} &lt;/header&gt; {% for message in get_flashed_messages () %} &lt;div class=\"flash\"&gt; {{ message }} &lt;/div&gt; {% endfor %} {% block content %}{% endblock %} &lt;/section&gt; :data: g is automatically available in templates. Based on if g.user is set (from load_logged_in_user ), either the username and a log out link are displayed, otherwise links to register and log in are displayed. :func: url_for is also automatically available, and is used to generate URLs to views instead of writing them out manually. After the page title, and before the content, the template loops over each message returned by :func: get_flashed_messages . You used :func: flash in the views to show error messages, and this is the code that will display them. There are three blocks defined here that will be overridden in the other templates: . {% block title %} will change the title displayed in the \u00b6 browser's tab and window title. . {% block header %} is similar to title but will change the \u00b6 title displayed on the page. . {% block content %} is where the content of each page goes, such \u00b6 as the login form or a blog post. The base template is directly in the templates directory. To keep the others organized, the templates for a blueprint will be placed in a directory with the same name as the blueprint. Register \u00b6 .. code-block:: html+jinja :caption: flaskr/templates/auth/register.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Register {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"username\"&gt;Username&lt;/label&gt; &lt;input name=\"username\" id=\"username\" required&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required&gt; &lt;input type=\"submit\" value=\"Register\"&gt; &lt;/form&gt; {% endblock %} {% extends 'base.html' %} tells Jinja that this template should replace the blocks from the base template. All the rendered content must appear inside {% block %} tags that override blocks from the base template. A useful pattern used here is to place {% block title %} inside {% block header %} . This will set the title block and then output the value of it into the header block, so that both the window and page share the same title without writing it twice. The input tags are using the required attribute here. This tells the browser not to submit the form until those fields are filled in. If the user is using an older browser that doesn't support that attribute, or if they are using something besides a browser to make requests, you still want to validate the data in the Flask view. It's important to always fully validate the data on the server, even if the client does some validation as well. Log In \u00b6 This is identical to the register template except for the title and submit button. .. code-block:: html+jinja :caption: flaskr/templates/auth/login.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Log In {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"username\"&gt;Username&lt;/label&gt; &lt;input name=\"username\" id=\"username\" required&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required&gt; &lt;input type=\"submit\" value=\"Log In\"&gt; &lt;/form&gt; {% endblock %} Register A User \u00b6 Now that the authentication templates are written, you can register a user. Make sure the server is still running ( flask run if it's not), then go to http://127.0.0.1:5000/auth/register. Try clicking the \"Register\" button without filling out the form and see that the browser shows an error message. Try removing the required attributes from the register.html template and click \"Register\" again. Instead of the browser showing an error, the page will reload and the error from :func: flash in the view will be shown. Fill out a username and password and you'll be redirected to the login page. Try entering an incorrect username, or the correct username and incorrect password. If you log in you'll get an error because there's no index view to redirect to yet. Continue to :doc: static .","title":"Templates"},{"location":"tutorial/templates/#templates","text":"You've written the authentication views for your application, but if you're running the server and try to go to any of the URLs, you'll see a TemplateNotFound error. That's because the views are calling :func: render_template , but you haven't written the templates yet. The template files will be stored in the templates directory inside the flaskr package. Templates are files that contain static data as well as placeholders for dynamic data. A template is rendered with specific data to produce a final document. Flask uses the Jinja _ template library to render templates. In your application, you will use templates to render HTML _ which will display in the user's browser. In Flask, Jinja is configured to autoescape any data that is rendered in HTML templates. This means that it's safe to render user input; any characters they've entered that could mess with the HTML, such as < and > will be escaped with safe values that look the same in the browser but don't cause unwanted effects. Jinja looks and behaves mostly like Python. Special delimiters are used to distinguish Jinja syntax from the static data in the template. Anything between {{ and }} is an expression that will be output to the final document. {% and %} denotes a control flow statement like if and for . Unlike Python, blocks are denoted by start and end tags rather than indentation since static text within a block could change indentation. .. _Jinja: http://jinja.pocoo.org/docs/templates/ .. _HTML: https://developer.mozilla.org/docs/Web/HTML","title":"Templates"},{"location":"tutorial/templates/#the-base-layout","text":"Each page in the application will have the same basic layout around a different body. Instead of writing the entire HTML structure in each template, each template will extend a base template and override specific sections. .. code-block:: html+jinja :caption: flaskr/templates/base.html &lt;!doctype html&gt; &lt;title&gt; {% block title %}{% endblock %} - Flaskr&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\" {{ url_for ( 'static' , filename = 'style.css' ) }} \"&gt; &lt;nav&gt; &lt;h1&gt;Flaskr&lt;/h1&gt; &lt;ul&gt; {% if g.user %} &lt;li&gt;&lt;span&gt; {{ g.user [ 'username' ] }} &lt;/span&gt; &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.logout' ) }} \"&gt;Log Out&lt;/a&gt; {% else %} &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.register' ) }} \"&gt;Register&lt;/a&gt; &lt;li&gt;&lt;a href=\" {{ url_for ( 'auth.login' ) }} \"&gt;Log In&lt;/a&gt; {% endif %} &lt;/ul&gt; &lt;/nav&gt; &lt;section class=\"content\"&gt; &lt;header&gt; {% block header %}{% endblock %} &lt;/header&gt; {% for message in get_flashed_messages () %} &lt;div class=\"flash\"&gt; {{ message }} &lt;/div&gt; {% endfor %} {% block content %}{% endblock %} &lt;/section&gt; :data: g is automatically available in templates. Based on if g.user is set (from load_logged_in_user ), either the username and a log out link are displayed, otherwise links to register and log in are displayed. :func: url_for is also automatically available, and is used to generate URLs to views instead of writing them out manually. After the page title, and before the content, the template loops over each message returned by :func: get_flashed_messages . You used :func: flash in the views to show error messages, and this is the code that will display them. There are three blocks defined here that will be overridden in the other templates:","title":"The Base Layout"},{"location":"tutorial/templates/#block-title-will-change-the-title-displayed-in-the","text":"browser's tab and window title.","title":". {% block title %} will change the title displayed in the"},{"location":"tutorial/templates/#block-header-is-similar-to-title-but-will-change-the","text":"title displayed on the page.","title":". {% block header %} is similar to title but will change the"},{"location":"tutorial/templates/#block-content-is-where-the-content-of-each-page-goes-such","text":"as the login form or a blog post. The base template is directly in the templates directory. To keep the others organized, the templates for a blueprint will be placed in a directory with the same name as the blueprint.","title":". {% block content %} is where the content of each page goes, such"},{"location":"tutorial/templates/#register","text":".. code-block:: html+jinja :caption: flaskr/templates/auth/register.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Register {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"username\"&gt;Username&lt;/label&gt; &lt;input name=\"username\" id=\"username\" required&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required&gt; &lt;input type=\"submit\" value=\"Register\"&gt; &lt;/form&gt; {% endblock %} {% extends 'base.html' %} tells Jinja that this template should replace the blocks from the base template. All the rendered content must appear inside {% block %} tags that override blocks from the base template. A useful pattern used here is to place {% block title %} inside {% block header %} . This will set the title block and then output the value of it into the header block, so that both the window and page share the same title without writing it twice. The input tags are using the required attribute here. This tells the browser not to submit the form until those fields are filled in. If the user is using an older browser that doesn't support that attribute, or if they are using something besides a browser to make requests, you still want to validate the data in the Flask view. It's important to always fully validate the data on the server, even if the client does some validation as well.","title":"Register"},{"location":"tutorial/templates/#log-in","text":"This is identical to the register template except for the title and submit button. .. code-block:: html+jinja :caption: flaskr/templates/auth/login.html {% extends 'base.html' %} {% block header %} &lt;h1&gt; {% block title %} Log In {% endblock %} &lt;/h1&gt; {% endblock %} {% block content %} &lt;form method=\"post\"&gt; &lt;label for=\"username\"&gt;Username&lt;/label&gt; &lt;input name=\"username\" id=\"username\" required&gt; &lt;label for=\"password\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" required&gt; &lt;input type=\"submit\" value=\"Log In\"&gt; &lt;/form&gt; {% endblock %}","title":"Log In"},{"location":"tutorial/templates/#register-a-user","text":"Now that the authentication templates are written, you can register a user. Make sure the server is still running ( flask run if it's not), then go to http://127.0.0.1:5000/auth/register. Try clicking the \"Register\" button without filling out the form and see that the browser shows an error message. Try removing the required attributes from the register.html template and click \"Register\" again. Instead of the browser showing an error, the page will reload and the error from :func: flash in the view will be shown. Fill out a username and password and you'll be redirected to the login page. Try entering an incorrect username, or the correct username and incorrect password. If you log in you'll get an error because there's no index view to redirect to yet. Continue to :doc: static .","title":"Register A User"},{"location":"tutorial/tests/","text":".. currentmodule:: flask Test Coverage \u00b6 Writing unit tests for your application lets you check that the code you wrote works the way you expect. Flask provides a test client that simulates requests to the application and returns the response data. You should test as much of your code as possible. Code in functions only runs when the function is called, and code in branches, such as if blocks, only runs when the condition is met. You want to make sure that each function is tested with data that covers each branch. The closer you get to 100% coverage, the more comfortable you can be that making a change won't unexpectedly change other behavior. However, 100% coverage doesn't guarantee that your application doesn't have bugs. In particular, it doesn't test how the user interacts with the application in the browser. Despite this, test coverage is an important tool to use during development. .. note:: This is being introduced late in the tutorial, but in your future projects you should test as you develop. You'll use pytest and coverage to test and measure your code. Install them both: .. code-block:: none $ pip install pytest coverage .. _pytest: https://pytest.readthedocs.io/ .. _coverage: https://coverage.readthedocs.io/ Setup and Fixtures \u00b6 The test code is located in the tests directory. This directory is next to the flaskr package, not inside it. The tests/conftest.py file contains setup functions called fixtures that each test will use. Tests are in Python modules that start with test_ , and each test function in those modules also starts with test_ . Each test will create a new temporary database file and populate some data that will be used in the tests. Write a SQL file to insert that data. .. code-block:: sql :caption: tests/data.sql INSERT INTO user ( username , password ) VALUES ( 'test' , 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f' ), ( 'other' , 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79' ); INSERT INTO post ( title , body , author_id , created ) VALUES ( 'test title' , 'test' || x '0a' || 'body' , 1 , '2018-01-01 00:00:00' ); The app fixture will call the factory and pass test_config to configure the application and database for testing instead of using your local development configuration. .. code-block:: python :caption: tests/conftest.py import os import tempfile import pytest from flaskr import create_app from flaskr.db import get_db , init_db with open ( os . path . join ( os . path . dirname ( __file__ ), 'data.sql' ), 'rb' ) as f : _data_sql = f . read () . decode ( 'utf8' ) @pytest.fixture def app (): db_fd , db_path = tempfile . mkstemp () app = create_app ({ 'TESTING' : True , 'DATABASE' : db_path , }) with app . app_context (): init_db () get_db () . executescript ( _data_sql ) yield app os . close ( db_fd ) os . unlink ( db_path ) @pytest.fixture def client ( app ): return app . test_client () @pytest.fixture def runner ( app ): return app . test_cli_runner () :func: tempfile.mkstemp creates and opens a temporary file, returning the file object and the path to it. The DATABASE path is overridden so it points to this temporary path instead of the instance folder. After setting the path, the database tables are created and the test data is inserted. After the test is over, the temporary file is closed and removed. :data: TESTING tells Flask that the app is in test mode. Flask changes some internal behavior so it's easier to test, and other extensions can also use the flag to make testing them easier. The client fixture calls :meth: app.test_client() <Flask.test_client> with the application object created by the app fixture. Tests will use the client to make requests to the application without running the server. The runner fixture is similar to client . :meth: app.test_cli_runner() <Flask.test_cli_runner> creates a runner that can call the Click commands registered with the application. Pytest uses fixtures by matching their function names with the names of arguments in the test functions. For example, the test_hello function you'll write next takes a client argument. Pytest matches that with the client fixture function, calls it, and passes the returned value to the test function. Factory \u00b6 There's not much to test about the factory itself. Most of the code will be executed for each test already, so if something fails the other tests will notice. The only behavior that can change is passing test config. If config is not passed, there should be some default configuration, otherwise the configuration should be overridden. .. code-block:: python :caption: tests/test_factory.py from flaskr import create_app def test_config (): assert not create_app () . testing assert create_app ({ 'TESTING' : True }) . testing def test_hello ( client ): response = client . get ( '/hello' ) assert response . data == b 'Hello, World!' You added the hello route as an example when writing the factory at the beginning of the tutorial. It returns \"Hello, World!\", so the test checks that the response data matches. Database \u00b6 Within an application context, get_db should return the same connection each time it's called. After the context, the connection should be closed. .. code-block:: python :caption: tests/test_db.py import sqlite3 import pytest from flaskr.db import get_db def test_get_close_db ( app ): with app . app_context (): db = get_db () assert db is get_db () with pytest . raises ( sqlite3 . ProgrammingError ) as e : db . execute ( 'SELECT 1' ) assert 'closed' in str ( e ) The init-db command should call the init_db function and output a message. .. code-block:: python :caption: tests/test_db.py def test_init_db_command(runner, monkeypatch): class Recorder(object): called = False def fake_init_db(): Recorder.called = True monkeypatch.setattr('flaskr.db.init_db', fake_init_db) result = runner.invoke(args=['init-db']) assert 'Initialized' in result.output assert Recorder.called This test uses Pytest's monkeypatch fixture to replace the init_db function with one that records that it's been called. The runner fixture you wrote above is used to call the init-db command by name. Authentication \u00b6 For most of the views, a user needs to be logged in. The easiest way to do this in tests is to make a POST request to the login view with the client. Rather than writing that out every time, you can write a class with methods to do that, and use a fixture to pass it the client for each test. .. code-block:: python :caption: tests/conftest.py class AuthActions ( object ) : def __init__ ( self , client ) : self . _client = client def login ( self , username = 'test' , password = 'test' ) : return self . _client . post ( '/auth/login' , data = { 'username' : username , 'password' : password } ) def logout ( self ) : return self . _client . get ( '/auth/logout' ) @pytest . fixture def auth ( client ) : return AuthActions ( client ) With the auth fixture, you can call auth.login() in a test to log in as the test user, which was inserted as part of the test data in the app fixture. The register view should render successfully on GET . On POST with valid form data, it should redirect to the login URL and the user's data should be in the database. Invalid data should display error messages. .. code-block:: python :caption: tests/test_auth.py import pytest from flask import g , session from flaskr.db import get_db def test_register ( client , app ): assert client . get ( '/auth/register' ) . status_code == 200 response = client . post ( '/auth/register' , data = { 'username' : 'a' , 'password' : 'a' } ) assert 'http://localhost/auth/login' == response . headers [ 'Location' ] with app . app_context (): assert get_db () . execute ( \"select * from user where username = 'a'\" , ) . fetchone () is not None @pytest.mark.parametrize (( 'username' , 'password' , 'message' ), ( ( '' , '' , b 'Username is required.' ), ( 'a' , '' , b 'Password is required.' ), ( 'test' , 'test' , b 'already registered' ), )) def test_register_validate_input ( client , username , password , message ): response = client . post ( '/auth/register' , data = { 'username' : username , 'password' : password } ) assert message in response . data :meth: client.get() <werkzeug.test.Client.get> makes a GET request and returns the :class: Response object returned by Flask. Similarly, :meth: client.post() <werkzeug.test.Client.post> makes a POST request, converting the data dict into form data. To test that the page renders successfully, a simple request is made and checked for a 200 OK :attr: ~Response.status_code . If rendering failed, Flask would return a 500 Internal Server Error code. :attr: ~Response.headers will have a Location header with the login URL when the register view redirects to the login view. :attr: ~Response.data contains the body of the response as bytes. If you expect a certain value to render on the page, check that it's in data . Bytes must be compared to bytes. If you want to compare Unicode text, use :meth: get_data(as_text=True) <werkzeug.wrappers.BaseResponse.get_data> instead. pytest.mark.parametrize tells Pytest to run the same test function with different arguments. You use it here to test different invalid input and error messages without writing the same code three times. The tests for the login view are very similar to those for register . Rather than testing the data in the database, :data: session should have user_id set after logging in. .. code-block:: python :caption: tests/test_auth.py def test_login(client, auth): assert client.get('/auth/login').status_code == 200 response = auth.login() assert response.headers['Location'] == 'http://localhost/' with client: client.get('/') assert session['user_id'] == 1 assert g.user['username'] == 'test' @pytest.mark.parametrize(('username', 'password', 'message'), ( ('a', 'test', b'Incorrect username.'), ('test', 'a', b'Incorrect password.'), )) def test_login_validate_input(auth, username, password, message): response = auth.login(username, password) assert message in response.data Using client in a with block allows accessing context variables such as :data: session after the response is returned. Normally, accessing session outside of a request would raise an error. Testing logout is the opposite of login . :data: session should not contain user_id after logging out. .. code-block:: python :caption: tests/test_auth.py def test_logout(client, auth): auth.login() with client: auth.logout() assert 'user_id' not in session Blog \u00b6 All the blog views use the auth fixture you wrote earlier. Call auth.login() and subsequent requests from the client will be logged in as the test user. The index view should display information about the post that was added with the test data. When logged in as the author, there should be a link to edit the post. You can also test some more authentication behavior while testing the index view. When not logged in, each page shows links to log in or register. When logged in, there's a link to log out. .. code-block:: python :caption: tests/test_blog.py import pytest from flaskr.db import get_db def test_index ( client , auth ): response = client . get ( '/' ) assert b \"Log In\" in response . data assert b \"Register\" in response . data auth . login () response = client . get ( '/' ) assert b 'Log Out' in response . data assert b 'test title' in response . data assert b 'by test on 2018-01-01' in response . data assert b 'test \\n body' in response . data assert b 'href=\"/1/update\"' in response . data A user must be logged in to access the create , update , and delete views. The logged in user must be the author of the post to access update and delete , otherwise a 403 Forbidden status is returned. If a post with the given id doesn't exist, update and delete should return 404 Not Found . .. code-block:: python :caption: tests/test_blog.py @pytest.mark.parametrize('path', ( '/create', '/1/update', '/1/delete', )) def test_login_required(client, path): response = client.post(path) assert response.headers['Location'] == 'http://localhost/auth/login' def test_author_required(app, client, auth): # change the post author to another user with app.app_context(): db = get_db() db.execute('UPDATE post SET author_id = 2 WHERE id = 1') db.commit() auth.login() # current user can't modify other user's post assert client.post('/1/update').status_code == 403 assert client.post('/1/delete').status_code == 403 # current user doesn't see edit link assert b'href=\"/1/update\"' not in client.get('/').data @pytest.mark.parametrize('path', ( '/2/update', '/2/delete', )) def test_exists_required(client, auth, path): auth.login() assert client.post(path).status_code == 404 The create and update views should render and return a 200 OK status for a GET request. When valid data is sent in a POST request, create should insert the new post data into the database, and update should modify the existing data. Both pages should show an error message on invalid data. .. code-block:: python :caption: tests/test_blog.py def test_create(client, auth, app): auth.login() assert client.get('/create').status_code == 200 client.post('/create', data={'title': 'created', 'body': ''}) with app.app_context(): db = get_db() count = db.execute('SELECT COUNT(id) FROM post').fetchone()[0] assert count == 2 def test_update(client, auth, app): auth.login() assert client.get('/1/update').status_code == 200 client.post('/1/update', data={'title': 'updated', 'body': ''}) with app.app_context(): db = get_db() post = db.execute('SELECT * FROM post WHERE id = 1').fetchone() assert post['title'] == 'updated' @pytest.mark.parametrize('path', ( '/create', '/1/update', )) def test_create_update_validate(client, auth, path): auth.login() response = client.post(path, data={'title': '', 'body': ''}) assert b'Title is required.' in response.data The delete view should redirect to the index URL and the post should no longer exist in the database. .. code-block:: python :caption: tests/test_blog.py def test_delete(client, auth, app): auth.login() response = client.post('/1/delete') assert response.headers['Location'] == 'http://localhost/' with app.app_context(): db = get_db() post = db.execute('SELECT * FROM post WHERE id = 1').fetchone() assert post is None Running the Tests \u00b6 Some extra configuration, which is not required but makes running tests with coverage less verbose, can be added to the project's setup.cfg file. .. code-block:: none :caption: setup.cfg [tool:pytest] testpaths = tests [coverage:run] branch = True source = flaskr To run the tests, use the pytest command. It will find and run all the test functions you've written. .. code-block:: none $ pytest ========================= test session starts ========================== platform linux -- Python 3 .6.4, pytest-3.5.0, py-1.5.3, pluggy-0.6.0 rootdir: /home/user/Projects/flask-tutorial, inifile: setup.cfg collected 23 items tests/test_auth.py ........ [ 34 % ] tests/test_blog.py ............ [ 86 % ] tests/test_db.py .. [ 95 % ] tests/test_factory.py .. [ 100 % ] ====================== 24 passed in 0 .64 seconds ======================= If any tests fail, pytest will show the error that was raised. You can run pytest -v to get a list of each test function rather than dots. To measure the code coverage of your tests, use the coverage command to run pytest instead of running it directly. .. code-block:: none $ coverage run -m pytest You can either view a simple coverage report in the terminal: .. code-block:: none $ coverage report Name Stmts Miss Branch BrPart Cover ------------------------------------------------------ flaskr/__init__.py 21 0 2 0 100 % flaskr/auth.py 54 0 22 0 100 % flaskr/blog.py 54 0 16 0 100 % flaskr/db.py 24 0 4 0 100 % ------------------------------------------------------ TOTAL 153 0 44 0 100 % An HTML report allows you to see which lines were covered in each file: .. code-block:: none $ coverage html This generates files in the htmlcov directory. Open htmlcov/index.html in your browser to see the report. Continue to :doc: deploy .","title":"Tests"},{"location":"tutorial/tests/#test-coverage","text":"Writing unit tests for your application lets you check that the code you wrote works the way you expect. Flask provides a test client that simulates requests to the application and returns the response data. You should test as much of your code as possible. Code in functions only runs when the function is called, and code in branches, such as if blocks, only runs when the condition is met. You want to make sure that each function is tested with data that covers each branch. The closer you get to 100% coverage, the more comfortable you can be that making a change won't unexpectedly change other behavior. However, 100% coverage doesn't guarantee that your application doesn't have bugs. In particular, it doesn't test how the user interacts with the application in the browser. Despite this, test coverage is an important tool to use during development. .. note:: This is being introduced late in the tutorial, but in your future projects you should test as you develop. You'll use pytest and coverage to test and measure your code. Install them both: .. code-block:: none $ pip install pytest coverage .. _pytest: https://pytest.readthedocs.io/ .. _coverage: https://coverage.readthedocs.io/","title":"Test Coverage"},{"location":"tutorial/tests/#setup-and-fixtures","text":"The test code is located in the tests directory. This directory is next to the flaskr package, not inside it. The tests/conftest.py file contains setup functions called fixtures that each test will use. Tests are in Python modules that start with test_ , and each test function in those modules also starts with test_ . Each test will create a new temporary database file and populate some data that will be used in the tests. Write a SQL file to insert that data. .. code-block:: sql :caption: tests/data.sql INSERT INTO user ( username , password ) VALUES ( 'test' , 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f' ), ( 'other' , 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79' ); INSERT INTO post ( title , body , author_id , created ) VALUES ( 'test title' , 'test' || x '0a' || 'body' , 1 , '2018-01-01 00:00:00' ); The app fixture will call the factory and pass test_config to configure the application and database for testing instead of using your local development configuration. .. code-block:: python :caption: tests/conftest.py import os import tempfile import pytest from flaskr import create_app from flaskr.db import get_db , init_db with open ( os . path . join ( os . path . dirname ( __file__ ), 'data.sql' ), 'rb' ) as f : _data_sql = f . read () . decode ( 'utf8' ) @pytest.fixture def app (): db_fd , db_path = tempfile . mkstemp () app = create_app ({ 'TESTING' : True , 'DATABASE' : db_path , }) with app . app_context (): init_db () get_db () . executescript ( _data_sql ) yield app os . close ( db_fd ) os . unlink ( db_path ) @pytest.fixture def client ( app ): return app . test_client () @pytest.fixture def runner ( app ): return app . test_cli_runner () :func: tempfile.mkstemp creates and opens a temporary file, returning the file object and the path to it. The DATABASE path is overridden so it points to this temporary path instead of the instance folder. After setting the path, the database tables are created and the test data is inserted. After the test is over, the temporary file is closed and removed. :data: TESTING tells Flask that the app is in test mode. Flask changes some internal behavior so it's easier to test, and other extensions can also use the flag to make testing them easier. The client fixture calls :meth: app.test_client() <Flask.test_client> with the application object created by the app fixture. Tests will use the client to make requests to the application without running the server. The runner fixture is similar to client . :meth: app.test_cli_runner() <Flask.test_cli_runner> creates a runner that can call the Click commands registered with the application. Pytest uses fixtures by matching their function names with the names of arguments in the test functions. For example, the test_hello function you'll write next takes a client argument. Pytest matches that with the client fixture function, calls it, and passes the returned value to the test function.","title":"Setup and Fixtures"},{"location":"tutorial/tests/#factory","text":"There's not much to test about the factory itself. Most of the code will be executed for each test already, so if something fails the other tests will notice. The only behavior that can change is passing test config. If config is not passed, there should be some default configuration, otherwise the configuration should be overridden. .. code-block:: python :caption: tests/test_factory.py from flaskr import create_app def test_config (): assert not create_app () . testing assert create_app ({ 'TESTING' : True }) . testing def test_hello ( client ): response = client . get ( '/hello' ) assert response . data == b 'Hello, World!' You added the hello route as an example when writing the factory at the beginning of the tutorial. It returns \"Hello, World!\", so the test checks that the response data matches.","title":"Factory"},{"location":"tutorial/tests/#database","text":"Within an application context, get_db should return the same connection each time it's called. After the context, the connection should be closed. .. code-block:: python :caption: tests/test_db.py import sqlite3 import pytest from flaskr.db import get_db def test_get_close_db ( app ): with app . app_context (): db = get_db () assert db is get_db () with pytest . raises ( sqlite3 . ProgrammingError ) as e : db . execute ( 'SELECT 1' ) assert 'closed' in str ( e ) The init-db command should call the init_db function and output a message. .. code-block:: python :caption: tests/test_db.py def test_init_db_command(runner, monkeypatch): class Recorder(object): called = False def fake_init_db(): Recorder.called = True monkeypatch.setattr('flaskr.db.init_db', fake_init_db) result = runner.invoke(args=['init-db']) assert 'Initialized' in result.output assert Recorder.called This test uses Pytest's monkeypatch fixture to replace the init_db function with one that records that it's been called. The runner fixture you wrote above is used to call the init-db command by name.","title":"Database"},{"location":"tutorial/tests/#authentication","text":"For most of the views, a user needs to be logged in. The easiest way to do this in tests is to make a POST request to the login view with the client. Rather than writing that out every time, you can write a class with methods to do that, and use a fixture to pass it the client for each test. .. code-block:: python :caption: tests/conftest.py class AuthActions ( object ) : def __init__ ( self , client ) : self . _client = client def login ( self , username = 'test' , password = 'test' ) : return self . _client . post ( '/auth/login' , data = { 'username' : username , 'password' : password } ) def logout ( self ) : return self . _client . get ( '/auth/logout' ) @pytest . fixture def auth ( client ) : return AuthActions ( client ) With the auth fixture, you can call auth.login() in a test to log in as the test user, which was inserted as part of the test data in the app fixture. The register view should render successfully on GET . On POST with valid form data, it should redirect to the login URL and the user's data should be in the database. Invalid data should display error messages. .. code-block:: python :caption: tests/test_auth.py import pytest from flask import g , session from flaskr.db import get_db def test_register ( client , app ): assert client . get ( '/auth/register' ) . status_code == 200 response = client . post ( '/auth/register' , data = { 'username' : 'a' , 'password' : 'a' } ) assert 'http://localhost/auth/login' == response . headers [ 'Location' ] with app . app_context (): assert get_db () . execute ( \"select * from user where username = 'a'\" , ) . fetchone () is not None @pytest.mark.parametrize (( 'username' , 'password' , 'message' ), ( ( '' , '' , b 'Username is required.' ), ( 'a' , '' , b 'Password is required.' ), ( 'test' , 'test' , b 'already registered' ), )) def test_register_validate_input ( client , username , password , message ): response = client . post ( '/auth/register' , data = { 'username' : username , 'password' : password } ) assert message in response . data :meth: client.get() <werkzeug.test.Client.get> makes a GET request and returns the :class: Response object returned by Flask. Similarly, :meth: client.post() <werkzeug.test.Client.post> makes a POST request, converting the data dict into form data. To test that the page renders successfully, a simple request is made and checked for a 200 OK :attr: ~Response.status_code . If rendering failed, Flask would return a 500 Internal Server Error code. :attr: ~Response.headers will have a Location header with the login URL when the register view redirects to the login view. :attr: ~Response.data contains the body of the response as bytes. If you expect a certain value to render on the page, check that it's in data . Bytes must be compared to bytes. If you want to compare Unicode text, use :meth: get_data(as_text=True) <werkzeug.wrappers.BaseResponse.get_data> instead. pytest.mark.parametrize tells Pytest to run the same test function with different arguments. You use it here to test different invalid input and error messages without writing the same code three times. The tests for the login view are very similar to those for register . Rather than testing the data in the database, :data: session should have user_id set after logging in. .. code-block:: python :caption: tests/test_auth.py def test_login(client, auth): assert client.get('/auth/login').status_code == 200 response = auth.login() assert response.headers['Location'] == 'http://localhost/' with client: client.get('/') assert session['user_id'] == 1 assert g.user['username'] == 'test' @pytest.mark.parametrize(('username', 'password', 'message'), ( ('a', 'test', b'Incorrect username.'), ('test', 'a', b'Incorrect password.'), )) def test_login_validate_input(auth, username, password, message): response = auth.login(username, password) assert message in response.data Using client in a with block allows accessing context variables such as :data: session after the response is returned. Normally, accessing session outside of a request would raise an error. Testing logout is the opposite of login . :data: session should not contain user_id after logging out. .. code-block:: python :caption: tests/test_auth.py def test_logout(client, auth): auth.login() with client: auth.logout() assert 'user_id' not in session","title":"Authentication"},{"location":"tutorial/tests/#blog","text":"All the blog views use the auth fixture you wrote earlier. Call auth.login() and subsequent requests from the client will be logged in as the test user. The index view should display information about the post that was added with the test data. When logged in as the author, there should be a link to edit the post. You can also test some more authentication behavior while testing the index view. When not logged in, each page shows links to log in or register. When logged in, there's a link to log out. .. code-block:: python :caption: tests/test_blog.py import pytest from flaskr.db import get_db def test_index ( client , auth ): response = client . get ( '/' ) assert b \"Log In\" in response . data assert b \"Register\" in response . data auth . login () response = client . get ( '/' ) assert b 'Log Out' in response . data assert b 'test title' in response . data assert b 'by test on 2018-01-01' in response . data assert b 'test \\n body' in response . data assert b 'href=\"/1/update\"' in response . data A user must be logged in to access the create , update , and delete views. The logged in user must be the author of the post to access update and delete , otherwise a 403 Forbidden status is returned. If a post with the given id doesn't exist, update and delete should return 404 Not Found . .. code-block:: python :caption: tests/test_blog.py @pytest.mark.parametrize('path', ( '/create', '/1/update', '/1/delete', )) def test_login_required(client, path): response = client.post(path) assert response.headers['Location'] == 'http://localhost/auth/login' def test_author_required(app, client, auth): # change the post author to another user with app.app_context(): db = get_db() db.execute('UPDATE post SET author_id = 2 WHERE id = 1') db.commit() auth.login() # current user can't modify other user's post assert client.post('/1/update').status_code == 403 assert client.post('/1/delete').status_code == 403 # current user doesn't see edit link assert b'href=\"/1/update\"' not in client.get('/').data @pytest.mark.parametrize('path', ( '/2/update', '/2/delete', )) def test_exists_required(client, auth, path): auth.login() assert client.post(path).status_code == 404 The create and update views should render and return a 200 OK status for a GET request. When valid data is sent in a POST request, create should insert the new post data into the database, and update should modify the existing data. Both pages should show an error message on invalid data. .. code-block:: python :caption: tests/test_blog.py def test_create(client, auth, app): auth.login() assert client.get('/create').status_code == 200 client.post('/create', data={'title': 'created', 'body': ''}) with app.app_context(): db = get_db() count = db.execute('SELECT COUNT(id) FROM post').fetchone()[0] assert count == 2 def test_update(client, auth, app): auth.login() assert client.get('/1/update').status_code == 200 client.post('/1/update', data={'title': 'updated', 'body': ''}) with app.app_context(): db = get_db() post = db.execute('SELECT * FROM post WHERE id = 1').fetchone() assert post['title'] == 'updated' @pytest.mark.parametrize('path', ( '/create', '/1/update', )) def test_create_update_validate(client, auth, path): auth.login() response = client.post(path, data={'title': '', 'body': ''}) assert b'Title is required.' in response.data The delete view should redirect to the index URL and the post should no longer exist in the database. .. code-block:: python :caption: tests/test_blog.py def test_delete(client, auth, app): auth.login() response = client.post('/1/delete') assert response.headers['Location'] == 'http://localhost/' with app.app_context(): db = get_db() post = db.execute('SELECT * FROM post WHERE id = 1').fetchone() assert post is None","title":"Blog"},{"location":"tutorial/tests/#running-the-tests","text":"Some extra configuration, which is not required but makes running tests with coverage less verbose, can be added to the project's setup.cfg file. .. code-block:: none :caption: setup.cfg [tool:pytest] testpaths = tests [coverage:run] branch = True source = flaskr To run the tests, use the pytest command. It will find and run all the test functions you've written. .. code-block:: none $ pytest ========================= test session starts ========================== platform linux -- Python 3 .6.4, pytest-3.5.0, py-1.5.3, pluggy-0.6.0 rootdir: /home/user/Projects/flask-tutorial, inifile: setup.cfg collected 23 items tests/test_auth.py ........ [ 34 % ] tests/test_blog.py ............ [ 86 % ] tests/test_db.py .. [ 95 % ] tests/test_factory.py .. [ 100 % ] ====================== 24 passed in 0 .64 seconds ======================= If any tests fail, pytest will show the error that was raised. You can run pytest -v to get a list of each test function rather than dots. To measure the code coverage of your tests, use the coverage command to run pytest instead of running it directly. .. code-block:: none $ coverage run -m pytest You can either view a simple coverage report in the terminal: .. code-block:: none $ coverage report Name Stmts Miss Branch BrPart Cover ------------------------------------------------------ flaskr/__init__.py 21 0 2 0 100 % flaskr/auth.py 54 0 22 0 100 % flaskr/blog.py 54 0 16 0 100 % flaskr/db.py 24 0 4 0 100 % ------------------------------------------------------ TOTAL 153 0 44 0 100 % An HTML report allows you to see which lines were covered in each file: .. code-block:: none $ coverage html This generates files in the htmlcov directory. Open htmlcov/index.html in your browser to see the report. Continue to :doc: deploy .","title":"Running the Tests"},{"location":"tutorial/views/","text":".. currentmodule:: flask Blueprints and Views \u00b6 A view function is the code you write to respond to requests to your application. Flask uses patterns to match the incoming request URL to the view that should handle it. The view returns data that Flask turns into an outgoing response. Flask can also go the other direction and generate a URL to a view based on its name and arguments. Create a Blueprint \u00b6 A :class: Blueprint is a way to organize a group of related views and other code. Rather than registering views and other code directly with an application, they are registered with a blueprint. Then the blueprint is registered with the application when it is available in the factory function. Flaskr will have two blueprints, one for authentication functions and one for the blog posts functions. The code for each blueprint will go in a separate module. Since the blog needs to know about authentication, you'll write the authentication one first. .. code-block:: python :caption: flaskr/auth.py import functools from flask import ( Blueprint , flash , g , redirect , render_template , request , session , url_for ) from werkzeug.security import check_password_hash , generate_password_hash from flaskr.db import get_db bp = Blueprint ( 'auth' , __name__ , url_prefix = '/auth' ) This creates a :class: Blueprint named 'auth' . Like the application object, the blueprint needs to know where it's defined, so __name__ is passed as the second argument. The url_prefix will be prepended to all the URLs associated with the blueprint. Import and register the blueprint from the factory using :meth: app.register_blueprint() <Flask.register_blueprint> . Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import auth app . register_blueprint ( auth . bp ) return app The authentication blueprint will have views to register new users and to log in and log out. The First View: Register \u00b6 When the user visits the /auth/register URL, the register view will return HTML _ with a form for them to fill out. When they submit the form, it will validate their input and either show the form again with an error message or create the new user and go to the login page. .. _HTML: https://developer.mozilla.org/docs/Web/HTML For now you will just write the view code. On the next page, you'll write templates to generate the HTML form. .. code-block:: python :caption: flaskr/auth.py @bp.route('/register', methods=('GET', 'POST')) def register(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] db = get_db() error = None if not username: error = 'Username is required.' elif not password: error = 'Password is required.' elif db.execute( 'SELECT id FROM user WHERE username = ?', (username,) ).fetchone() is not None: error = 'User {} is already registered.'.format(username) if error is None: db.execute( 'INSERT INTO user (username, password) VALUES (?, ?)', (username, generate_password_hash(password)) ) db.commit() return redirect(url_for('auth.login')) flash(error) return render_template('auth/register.html') Here's what the register view function is doing: . :meth: @bp.route <Blueprint.route> associates the URL /register \u00b6 with the register view function. When Flask receives a request to /auth/register , it will call the register view and use the return value as the response. . If the user submitted the form, \u00b6 :attr: request.method <Request.method> will be 'POST' . In this case, start validating the input. . :attr: request.form <Request.form> is a special type of \u00b6 :class: dict mapping submitted form keys and values. The user will input their username and password . . Validate that username and password are not empty. \u00b6 . Validate that username is not already registered by querying the \u00b6 database and checking if a result is returned. :meth: db.execute <sqlite3.Connection.execute> takes a SQL query with ? placeholders for any user input, and a tuple of values to replace the placeholders with. The database library will take care of escaping the values so you are not vulnerable to a SQL injection attack . :meth:`~sqlite3.Cursor.fetchone` returns one row from the query. If the query returned no results, it returns ``None``. Later, :meth:`~sqlite3.Cursor.fetchall` is used, which returns a list of all results. . If validation succeeds, insert the new user data into the database. \u00b6 For security, passwords should never be stored in the database directly. Instead, :func: ~werkzeug.security.generate_password_hash is used to securely hash the password, and that hash is stored. Since this query modifies data, :meth: db.commit() <sqlite3.Connection.commit> needs to be called afterwards to save the changes. . After storing the user, they are redirected to the login page. \u00b6 :func: url_for generates the URL for the login view based on its name. This is preferable to writing the URL directly as it allows you to change the URL later without changing all code that links to it. :func: redirect generates a redirect response to the generated URL. . If validation fails, the error is shown to the user. :func: flash \u00b6 stores messages that can be retrieved when rendering the template. . When the user initially navigates to auth/register , or \u00b6 there was a validation error, an HTML page with the registration form should be shown. :func: render_template will render a template containing the HTML, which you'll write in the next step of the tutorial. Login \u00b6 This view follows the same pattern as the register view above. .. code-block:: python :caption: flaskr/auth.py @bp.route('/login', methods=('GET', 'POST')) def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] db = get_db() error = None user = db.execute( 'SELECT * FROM user WHERE username = ?', (username,) ).fetchone() if user is None: error = 'Incorrect username.' elif not check_password_hash(user['password'], password): error = 'Incorrect password.' if error is None: session.clear() session['user_id'] = user['id'] return redirect(url_for('index')) flash(error) return render_template('auth/login.html') There are a few differences from the register view: . The user is queried first and stored in a variable for later use. \u00b6 . :func: ~werkzeug.security.check_password_hash hashes the submitted \u00b6 password in the same way as the stored hash and securely compares them. If they match, the password is valid. . :data: session is a :class: dict that stores data across requests. \u00b6 When validation succeeds, the user's id is stored in a new session. The data is stored in a cookie that is sent to the browser, and the browser then sends it back with subsequent requests. Flask securely signs the data so that it can't be tampered with. Now that the user's id is stored in the :data: session , it will be available on subsequent requests. At the beginning of each request, if a user is logged in their information should be loaded and made available to other views. .. code-block:: python :caption: flaskr/auth.py @bp.before_app_request def load_logged_in_user(): user_id = session.get('user_id') if user_id is None: g.user = None else: g.user = get_db().execute( 'SELECT * FROM user WHERE id = ?', (user_id,) ).fetchone() :meth: bp.before_app_request() <Blueprint.before_app_request> registers a function that runs before the view function, no matter what URL is requested. load_logged_in_user checks if a user id is stored in the :data: session and gets that user's data from the database, storing it on :data: g.user <g> , which lasts for the length of the request. If there is no user id, or if the id doesn't exist, g.user will be None . Logout \u00b6 To log out, you need to remove the user id from the :data: session . Then load_logged_in_user won't load a user on subsequent requests. .. code-block:: python :caption: flaskr/auth.py @bp.route('/logout') def logout(): session.clear() return redirect(url_for('index')) Require Authentication in Other Views \u00b6 Creating, editing, and deleting blog posts will require a user to be logged in. A decorator can be used to check this for each view it's applied to. .. code-block:: python :caption: flaskr/auth.py def login_required(view): @functools.wraps(view) def wrapped_view(**kwargs): if g.user is None: return redirect(url_for('auth.login')) return view(**kwargs) return wrapped_view This decorator returns a new view function that wraps the original view it's applied to. The new function checks if a user is loaded and redirects to the login page otherwise. If a user is loaded the original view is called and continues normally. You'll use this decorator when writing the blog views. Endpoints and URLs \u00b6 The :func: url_for function generates the URL to a view based on a name and arguments. The name associated with a view is also called the endpoint , and by default it's the same as the name of the view function. For example, the hello() view that was added to the app factory earlier in the tutorial has the name 'hello' and can be linked to with url_for('hello') . If it took an argument, which you'll see later, it would be linked to using url_for('hello', who='World') . When using a blueprint, the name of the blueprint is prepended to the name of the function, so the endpoint for the login function you wrote above is 'auth.login' because you added it to the 'auth' blueprint. Continue to :doc: templates .","title":"Views"},{"location":"tutorial/views/#blueprints-and-views","text":"A view function is the code you write to respond to requests to your application. Flask uses patterns to match the incoming request URL to the view that should handle it. The view returns data that Flask turns into an outgoing response. Flask can also go the other direction and generate a URL to a view based on its name and arguments.","title":"Blueprints and Views"},{"location":"tutorial/views/#create-a-blueprint","text":"A :class: Blueprint is a way to organize a group of related views and other code. Rather than registering views and other code directly with an application, they are registered with a blueprint. Then the blueprint is registered with the application when it is available in the factory function. Flaskr will have two blueprints, one for authentication functions and one for the blog posts functions. The code for each blueprint will go in a separate module. Since the blog needs to know about authentication, you'll write the authentication one first. .. code-block:: python :caption: flaskr/auth.py import functools from flask import ( Blueprint , flash , g , redirect , render_template , request , session , url_for ) from werkzeug.security import check_password_hash , generate_password_hash from flaskr.db import get_db bp = Blueprint ( 'auth' , __name__ , url_prefix = '/auth' ) This creates a :class: Blueprint named 'auth' . Like the application object, the blueprint needs to know where it's defined, so __name__ is passed as the second argument. The url_prefix will be prepended to all the URLs associated with the blueprint. Import and register the blueprint from the factory using :meth: app.register_blueprint() <Flask.register_blueprint> . Place the new code at the end of the factory function before returning the app. .. code-block:: python :caption: flaskr/__init__.py def create_app (): app = ... # existing code omitted from . import auth app . register_blueprint ( auth . bp ) return app The authentication blueprint will have views to register new users and to log in and log out.","title":"Create a Blueprint"},{"location":"tutorial/views/#the-first-view-register","text":"When the user visits the /auth/register URL, the register view will return HTML _ with a form for them to fill out. When they submit the form, it will validate their input and either show the form again with an error message or create the new user and go to the login page. .. _HTML: https://developer.mozilla.org/docs/Web/HTML For now you will just write the view code. On the next page, you'll write templates to generate the HTML form. .. code-block:: python :caption: flaskr/auth.py @bp.route('/register', methods=('GET', 'POST')) def register(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] db = get_db() error = None if not username: error = 'Username is required.' elif not password: error = 'Password is required.' elif db.execute( 'SELECT id FROM user WHERE username = ?', (username,) ).fetchone() is not None: error = 'User {} is already registered.'.format(username) if error is None: db.execute( 'INSERT INTO user (username, password) VALUES (?, ?)', (username, generate_password_hash(password)) ) db.commit() return redirect(url_for('auth.login')) flash(error) return render_template('auth/register.html') Here's what the register view function is doing:","title":"The First View: Register"},{"location":"tutorial/views/#methbproute-ltblueprintroutegt-associates-the-url-register","text":"with the register view function. When Flask receives a request to /auth/register , it will call the register view and use the return value as the response.","title":". :meth:@bp.route &lt;Blueprint.route&gt; associates the URL /register"},{"location":"tutorial/views/#if-the-user-submitted-the-form","text":":attr: request.method <Request.method> will be 'POST' . In this case, start validating the input.","title":". If the user submitted the form,"},{"location":"tutorial/views/#attrrequestform-ltrequestformgt-is-a-special-type-of","text":":class: dict mapping submitted form keys and values. The user will input their username and password .","title":". :attr:request.form &lt;Request.form&gt; is a special type of"},{"location":"tutorial/views/#validate-that-username-and-password-are-not-empty","text":"","title":". Validate that username and password are not empty."},{"location":"tutorial/views/#validate-that-username-is-not-already-registered-by-querying-the","text":"database and checking if a result is returned. :meth: db.execute <sqlite3.Connection.execute> takes a SQL query with ? placeholders for any user input, and a tuple of values to replace the placeholders with. The database library will take care of escaping the values so you are not vulnerable to a SQL injection attack . :meth:`~sqlite3.Cursor.fetchone` returns one row from the query. If the query returned no results, it returns ``None``. Later, :meth:`~sqlite3.Cursor.fetchall` is used, which returns a list of all results.","title":". Validate that username is not already registered by querying the"},{"location":"tutorial/views/#if-validation-succeeds-insert-the-new-user-data-into-the-database","text":"For security, passwords should never be stored in the database directly. Instead, :func: ~werkzeug.security.generate_password_hash is used to securely hash the password, and that hash is stored. Since this query modifies data, :meth: db.commit() <sqlite3.Connection.commit> needs to be called afterwards to save the changes.","title":". If validation succeeds, insert the new user data into the database."},{"location":"tutorial/views/#after-storing-the-user-they-are-redirected-to-the-login-page","text":":func: url_for generates the URL for the login view based on its name. This is preferable to writing the URL directly as it allows you to change the URL later without changing all code that links to it. :func: redirect generates a redirect response to the generated URL.","title":". After storing the user, they are redirected to the login page."},{"location":"tutorial/views/#if-validation-fails-the-error-is-shown-to-the-user-funcflash","text":"stores messages that can be retrieved when rendering the template.","title":". If validation fails, the error is shown to the user. :func:flash"},{"location":"tutorial/views/#when-the-user-initially-navigates-to-authregister-or","text":"there was a validation error, an HTML page with the registration form should be shown. :func: render_template will render a template containing the HTML, which you'll write in the next step of the tutorial.","title":". When the user initially navigates to auth/register, or"},{"location":"tutorial/views/#login","text":"This view follows the same pattern as the register view above. .. code-block:: python :caption: flaskr/auth.py @bp.route('/login', methods=('GET', 'POST')) def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] db = get_db() error = None user = db.execute( 'SELECT * FROM user WHERE username = ?', (username,) ).fetchone() if user is None: error = 'Incorrect username.' elif not check_password_hash(user['password'], password): error = 'Incorrect password.' if error is None: session.clear() session['user_id'] = user['id'] return redirect(url_for('index')) flash(error) return render_template('auth/login.html') There are a few differences from the register view:","title":"Login"},{"location":"tutorial/views/#the-user-is-queried-first-and-stored-in-a-variable-for-later-use","text":"","title":". The user is queried first and stored in a variable for later use."},{"location":"tutorial/views/#funcwerkzeugsecuritycheck_password_hash-hashes-the-submitted","text":"password in the same way as the stored hash and securely compares them. If they match, the password is valid.","title":". :func:~werkzeug.security.check_password_hash hashes the submitted"},{"location":"tutorial/views/#datasession-is-a-classdict-that-stores-data-across-requests","text":"When validation succeeds, the user's id is stored in a new session. The data is stored in a cookie that is sent to the browser, and the browser then sends it back with subsequent requests. Flask securely signs the data so that it can't be tampered with. Now that the user's id is stored in the :data: session , it will be available on subsequent requests. At the beginning of each request, if a user is logged in their information should be loaded and made available to other views. .. code-block:: python :caption: flaskr/auth.py @bp.before_app_request def load_logged_in_user(): user_id = session.get('user_id') if user_id is None: g.user = None else: g.user = get_db().execute( 'SELECT * FROM user WHERE id = ?', (user_id,) ).fetchone() :meth: bp.before_app_request() <Blueprint.before_app_request> registers a function that runs before the view function, no matter what URL is requested. load_logged_in_user checks if a user id is stored in the :data: session and gets that user's data from the database, storing it on :data: g.user <g> , which lasts for the length of the request. If there is no user id, or if the id doesn't exist, g.user will be None .","title":". :data:session is a :class:dict that stores data across requests."},{"location":"tutorial/views/#logout","text":"To log out, you need to remove the user id from the :data: session . Then load_logged_in_user won't load a user on subsequent requests. .. code-block:: python :caption: flaskr/auth.py @bp.route('/logout') def logout(): session.clear() return redirect(url_for('index'))","title":"Logout"},{"location":"tutorial/views/#require-authentication-in-other-views","text":"Creating, editing, and deleting blog posts will require a user to be logged in. A decorator can be used to check this for each view it's applied to. .. code-block:: python :caption: flaskr/auth.py def login_required(view): @functools.wraps(view) def wrapped_view(**kwargs): if g.user is None: return redirect(url_for('auth.login')) return view(**kwargs) return wrapped_view This decorator returns a new view function that wraps the original view it's applied to. The new function checks if a user is loaded and redirects to the login page otherwise. If a user is loaded the original view is called and continues normally. You'll use this decorator when writing the blog views.","title":"Require Authentication in Other Views"},{"location":"tutorial/views/#endpoints-and-urls","text":"The :func: url_for function generates the URL to a view based on a name and arguments. The name associated with a view is also called the endpoint , and by default it's the same as the name of the view function. For example, the hello() view that was added to the app factory earlier in the tutorial has the name 'hello' and can be linked to with url_for('hello') . If it took an argument, which you'll see later, it would be linked to using url_for('hello', who='World') . When using a blueprint, the name of the blueprint is prepended to the name of the function, so the endpoint for the login function you wrote above is 'auth.login' because you added it to the 'auth' blueprint. Continue to :doc: templates .","title":"Endpoints and URLs"}]}